
clockmg168.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000002f2  00800100  0000280a  0000289e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000280a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000061  008003f2  008003f2  00002b90  2**0
                  ALLOC
  3 .debug_aranges 00000020  00000000  00000000  00002b90  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00000580  00000000  00000000  00002bb0  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00002e7c  00000000  00000000  00003130  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000004a1  00000000  00000000  00005fac  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00002989  00000000  00000000  0000644d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000470  00000000  00000000  00008dd8  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000618  00000000  00000000  00009248  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000015ab  00000000  00000000  00009860  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000510  00000000  00000000  0000ae0b  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
       4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      24:	0c 94 56 07 	jmp	0xeac	; 0xeac <__vector_9>
      28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      2c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      40:	0c 94 92 04 	jmp	0x924	; 0x924 <__vector_16>
      44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      48:	0c 94 40 05 	jmp	0xa80	; 0xa80 <__vector_18>
      4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
      68:	11 24       	eor	r1, r1
      6a:	1f be       	out	0x3f, r1	; 63
      6c:	cf ef       	ldi	r28, 0xFF	; 255
      6e:	d4 e0       	ldi	r29, 0x04	; 4
      70:	de bf       	out	0x3e, r29	; 62
      72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
      74:	13 e0       	ldi	r17, 0x03	; 3
      76:	a0 e0       	ldi	r26, 0x00	; 0
      78:	b1 e0       	ldi	r27, 0x01	; 1
      7a:	ea e0       	ldi	r30, 0x0A	; 10
      7c:	f8 e2       	ldi	r31, 0x28	; 40
      7e:	02 c0       	rjmp	.+4      	; 0x84 <.do_copy_data_start>

00000080 <.do_copy_data_loop>:
      80:	05 90       	lpm	r0, Z+
      82:	0d 92       	st	X+, r0

00000084 <.do_copy_data_start>:
      84:	a2 3f       	cpi	r26, 0xF2	; 242
      86:	b1 07       	cpc	r27, r17
      88:	d9 f7       	brne	.-10     	; 0x80 <.do_copy_data_loop>

0000008a <__do_clear_bss>:
      8a:	14 e0       	ldi	r17, 0x04	; 4
      8c:	a2 ef       	ldi	r26, 0xF2	; 242
      8e:	b3 e0       	ldi	r27, 0x03	; 3
      90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
      92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
      94:	a3 35       	cpi	r26, 0x53	; 83
      96:	b1 07       	cpc	r27, r17
      98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
      9a:	0e 94 84 10 	call	0x2108	; 0x2108 <main>
      9e:	0c 94 03 14 	jmp	0x2806	; 0x2806 <_exit>

000000a2 <__bad_interrupt>:
      a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <one_reset>:
#include <util/delay.h>

char one_reset(void)
{
  char r;
  asm("cli");
      a6:	f8 94       	cli
  DDR |= DQ;
      a8:	57 9a       	sbi	0x0a, 7	; 10
  PORT &= ~DQ;
      aa:	5f 98       	cbi	0x0b, 7	; 11
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
      ac:	88 ee       	ldi	r24, 0xE8	; 232
      ae:	93 e0       	ldi	r25, 0x03	; 3
      b0:	01 97       	sbiw	r24, 0x01	; 1
      b2:	f1 f7       	brne	.-4      	; 0xb0 <one_reset+0xa>
  _delay_us(500);
  DDR &= ~DQ;
      b4:	57 98       	cbi	0x0a, 7	; 10
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
      b6:	8a e6       	ldi	r24, 0x6A	; 106
      b8:	8a 95       	dec	r24
      ba:	f1 f7       	brne	.-4      	; 0xb8 <one_reset+0x12>
  _delay_us(40);
  r = (DDR & DQ) ? 0 : 1;
      bc:	8a b1       	in	r24, 0x0a	; 10
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
      be:	e0 ee       	ldi	r30, 0xE0	; 224
      c0:	f1 e0       	ldi	r31, 0x01	; 1
      c2:	31 97       	sbiw	r30, 0x01	; 1
      c4:	f1 f7       	brne	.-4      	; 0xc2 <one_reset+0x1c>
  _delay_us(240);
  asm("sei");
      c6:	78 94       	sei
      c8:	80 95       	com	r24
  return r;
}
      ca:	88 1f       	adc	r24, r24
      cc:	88 27       	eor	r24, r24
      ce:	88 1f       	adc	r24, r24
      d0:	08 95       	ret

000000d2 <one_read_byte>:
*/

char one_read_byte(void)
{
  char i, data = 0;
  asm("cli");
      d2:	f8 94       	cli
      d4:	20 e0       	ldi	r18, 0x00	; 0
      d6:	90 e0       	ldi	r25, 0x00	; 0
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
      d8:	3a e1       	ldi	r19, 0x1A	; 26
  for (i = 0; i < 8; i++) {
    data >>= 1;
    DDR |= DQ;
      da:	40 ea       	ldi	r20, 0xA0	; 160
      dc:	57 9a       	sbi	0x0a, 7	; 10
    PORT &= ~DQ;
      de:	5f 98       	cbi	0x0b, 7	; 11
      e0:	83 2f       	mov	r24, r19
      e2:	8a 95       	dec	r24
      e4:	f1 f7       	brne	.-4      	; 0xe2 <one_read_byte+0x10>
    _delay_us(10);
    DDR &= ~DQ;
      e6:	57 98       	cbi	0x0a, 7	; 10
      e8:	83 2f       	mov	r24, r19
      ea:	8a 95       	dec	r24
      ec:	f1 f7       	brne	.-4      	; 0xea <one_read_byte+0x18>
    _delay_us(10);
    data |= (PIN & DQ) ? 0b10000000 : 0;
      ee:	89 b1       	in	r24, 0x09	; 9
      f0:	96 95       	lsr	r25
      f2:	80 78       	andi	r24, 0x80	; 128
      f4:	98 2b       	or	r25, r24
      f6:	84 2f       	mov	r24, r20
      f8:	8a 95       	dec	r24
      fa:	f1 f7       	brne	.-4      	; 0xf8 <one_read_byte+0x26>

char one_read_byte(void)
{
  char i, data = 0;
  asm("cli");
  for (i = 0; i < 8; i++) {
      fc:	2f 5f       	subi	r18, 0xFF	; 255
      fe:	28 30       	cpi	r18, 0x08	; 8
     100:	69 f7       	brne	.-38     	; 0xdc <one_read_byte+0xa>
    DDR &= ~DQ;
    _delay_us(10);
    data |= (PIN & DQ) ? 0b10000000 : 0;
    _delay_us(60);
  }   
  asm("sei");
     102:	78 94       	sei
  return data;
}
     104:	89 2f       	mov	r24, r25
     106:	08 95       	ret

00000108 <one_write_byte>:
*/

void one_write_byte(char data)
{
  char i;
  asm("cli");
     108:	f8 94       	cli
     10a:	20 e0       	ldi	r18, 0x00	; 0
     10c:	4a e1       	ldi	r20, 0x1A	; 26
  for (i = 0; i < 8; i++) {
    DDR |= DQ;
     10e:	35 e8       	ldi	r19, 0x85	; 133
     110:	57 9a       	sbi	0x0a, 7	; 10
    PORT &= ~DQ;
     112:	5f 98       	cbi	0x0b, 7	; 11
    if ((data & 1) == 0) {
     114:	80 fd       	sbrc	r24, 0
     116:	06 c0       	rjmp	.+12     	; 0x124 <one_write_byte+0x1c>
     118:	93 2f       	mov	r25, r19
     11a:	9a 95       	dec	r25
     11c:	f1 f7       	brne	.-4      	; 0x11a <one_write_byte+0x12>
      _delay_us(50);
      DDR &= ~DQ;
     11e:	57 98       	cbi	0x0a, 7	; 10
     120:	94 2f       	mov	r25, r20
     122:	05 c0       	rjmp	.+10     	; 0x12e <one_write_byte+0x26>
     124:	94 2f       	mov	r25, r20
     126:	9a 95       	dec	r25
     128:	f1 f7       	brne	.-4      	; 0x126 <one_write_byte+0x1e>
      _delay_us(10);
    }
    else {
      _delay_us(10);
      DDR &= ~DQ;
     12a:	57 98       	cbi	0x0a, 7	; 10
     12c:	93 2f       	mov	r25, r19
     12e:	9a 95       	dec	r25
     130:	f1 f7       	brne	.-4      	; 0x12e <one_write_byte+0x26>

void one_write_byte(char data)
{
  char i;
  asm("cli");
  for (i = 0; i < 8; i++) {
     132:	2f 5f       	subi	r18, 0xFF	; 255
     134:	28 30       	cpi	r18, 0x08	; 8
     136:	11 f0       	breq	.+4      	; 0x13c <one_write_byte+0x34>
    else {
      _delay_us(10);
      DDR &= ~DQ;
      _delay_us(50);
    }
    data >>= 1;
     138:	86 95       	lsr	r24
     13a:	ea cf       	rjmp	.-44     	; 0x110 <one_write_byte+0x8>
  }
  asm("sei");
     13c:	78 94       	sei
}
     13e:	08 95       	ret

00000140 <send_convert>:
   Funkcia vysle prikaz pre konvertovanie
*/

void send_convert(void)
{
  one_write_byte(0xcc);
     140:	8c ec       	ldi	r24, 0xCC	; 204
     142:	0e 94 84 00 	call	0x108	; 0x108 <one_write_byte>
  one_write_byte(0x44);
     146:	84 e4       	ldi	r24, 0x44	; 68
     148:	0e 94 84 00 	call	0x108	; 0x108 <one_write_byte>
}
     14c:	08 95       	ret

0000014e <send_getTemp>:
   Pre DS1820 je nutne pockat min 400ms na skonvertovanie
*/

void send_getTemp(void)
{
  one_write_byte(0xcc);
     14e:	8c ec       	ldi	r24, 0xCC	; 204
     150:	0e 94 84 00 	call	0x108	; 0x108 <one_write_byte>
  one_write_byte(0xbe);
     154:	8e eb       	ldi	r24, 0xBE	; 190
     156:	0e 94 84 00 	call	0x108	; 0x108 <one_write_byte>
}
     15a:	08 95       	ret

0000015c <i2c_start>:
   Vrati 0 ak sa senzor nenachadza na zbernici.
*/

char i2c_start(void)
{
  asm("cli");
     15c:	f8 94       	cli
  i2c_DDR &= ~(1 << SCL);
     15e:	56 98       	cbi	0x0a, 6	; 10
  i2c_DDR &= ~(1 << SDA);
     160:	55 98       	cbi	0x0a, 5	; 10
  asm("nop");
     162:	00 00       	nop
  asm("nop");
     164:	00 00       	nop
  if (bit_is_clear(i2c_PIN, SDA))
     166:	4d 9b       	sbis	0x09, 5	; 9
     168:	0f c0       	rjmp	.+30     	; 0x188 <i2c_start+0x2c>
    return 0;
  if (bit_is_clear(i2c_PIN, SCL))
     16a:	4e 9b       	sbis	0x09, 6	; 9
     16c:	0d c0       	rjmp	.+26     	; 0x188 <i2c_start+0x2c>
     16e:	8d e0       	ldi	r24, 0x0D	; 13
     170:	98 2f       	mov	r25, r24
     172:	9a 95       	dec	r25
     174:	f1 f7       	brne	.-4      	; 0x172 <i2c_start+0x16>
    return 0;
  _delay_us(5);
  i2c_DDR |= (1 << SDA);
     176:	55 9a       	sbi	0x0a, 5	; 10
  i2c_PORT &= ~(1 << SDA);
     178:	5d 98       	cbi	0x0b, 5	; 11
     17a:	8a 95       	dec	r24
     17c:	f1 f7       	brne	.-4      	; 0x17a <i2c_start+0x1e>
  _delay_us(5);
  i2c_DDR |= (1 << SCL);
     17e:	56 9a       	sbi	0x0a, 6	; 10
  i2c_PORT &= ~(1 << SCL);
     180:	5e 98       	cbi	0x0b, 6	; 11
  asm("sei");
     182:	78 94       	sei
     184:	81 e0       	ldi	r24, 0x01	; 1
     186:	08 95       	ret
  return 1;
     188:	80 e0       	ldi	r24, 0x00	; 0
}
     18a:	08 95       	ret

0000018c <i2c_stop>:
   Nevrati ziadnu hodnotu a nepozaduje parametre
*/

void i2c_stop(void)
{
  asm("cli");
     18c:	f8 94       	cli
  i2c_DDR |= (1 << SDA);
     18e:	55 9a       	sbi	0x0a, 5	; 10
  i2c_PORT &= ~(1 << SDA);
     190:	5d 98       	cbi	0x0b, 5	; 11
  i2c_DDR |= (1 << SCL);
     192:	56 9a       	sbi	0x0a, 6	; 10
  i2c_PORT &= ~(1 << SCL);
     194:	5e 98       	cbi	0x0b, 6	; 11
     196:	8a e1       	ldi	r24, 0x1A	; 26
     198:	8a 95       	dec	r24
     19a:	f1 f7       	brne	.-4      	; 0x198 <i2c_stop+0xc>
  _delay_us(10);
  i2c_DDR &= ~(1 << SCL);
     19c:	56 98       	cbi	0x0a, 6	; 10
     19e:	8d e0       	ldi	r24, 0x0D	; 13
     1a0:	8a 95       	dec	r24
     1a2:	f1 f7       	brne	.-4      	; 0x1a0 <i2c_stop+0x14>
  _delay_us(5);
  i2c_DDR &= ~(1 << SDA);
     1a4:	55 98       	cbi	0x0a, 5	; 10
  asm("sei");
     1a6:	78 94       	sei
}
     1a8:	08 95       	ret

000001aa <i2c_write>:

char i2c_write(char data)
{
  char i, res = 1;
  
  asm("cli");
     1aa:	f8 94       	cli
     1ac:	20 e0       	ldi	r18, 0x00	; 0
     1ae:	4a e1       	ldi	r20, 0x1A	; 26
  for (i = 0; i < 8; i++) {
    if ((data & 0x80) == 0) {
     1b0:	3d e0       	ldi	r19, 0x0D	; 13
     1b2:	87 fd       	sbrc	r24, 7
     1b4:	03 c0       	rjmp	.+6      	; 0x1bc <i2c_write+0x12>
	  i2c_DDR |= (1 << SDA);
     1b6:	55 9a       	sbi	0x0a, 5	; 10
	  i2c_PORT &= ~(1 << SDA);
     1b8:	5d 98       	cbi	0x0b, 5	; 11
     1ba:	01 c0       	rjmp	.+2      	; 0x1be <i2c_write+0x14>
	}
	else
	  i2c_DDR &= ~(1 << SDA);
     1bc:	55 98       	cbi	0x0a, 5	; 10
     1be:	94 2f       	mov	r25, r20
     1c0:	9a 95       	dec	r25
     1c2:	f1 f7       	brne	.-4      	; 0x1c0 <i2c_write+0x16>
	
	_delay_us(10);
	i2c_DDR &= ~(1 << SCL);
     1c4:	56 98       	cbi	0x0a, 6	; 10
     1c6:	93 2f       	mov	r25, r19
     1c8:	9a 95       	dec	r25
     1ca:	f1 f7       	brne	.-4      	; 0x1c8 <i2c_write+0x1e>
	_delay_us(5);
	while (bit_is_clear(i2c_PIN, SCL))
     1cc:	4e 9b       	sbis	0x09, 6	; 9
     1ce:	fe cf       	rjmp	.-4      	; 0x1cc <i2c_write+0x22>
     1d0:	93 2f       	mov	r25, r19
     1d2:	9a 95       	dec	r25
     1d4:	f1 f7       	brne	.-4      	; 0x1d2 <i2c_write+0x28>
	  ;
	_delay_us(5);
	i2c_DDR |= (1 << SCL);
     1d6:	56 9a       	sbi	0x0a, 6	; 10
	i2c_PORT &= ~(1 << SCL);
     1d8:	5e 98       	cbi	0x0b, 6	; 11
char i2c_write(char data)
{
  char i, res = 1;
  
  asm("cli");
  for (i = 0; i < 8; i++) {
     1da:	2f 5f       	subi	r18, 0xFF	; 255
     1dc:	28 30       	cpi	r18, 0x08	; 8
     1de:	11 f0       	breq	.+4      	; 0x1e4 <i2c_write+0x3a>
	while (bit_is_clear(i2c_PIN, SCL))
	  ;
	_delay_us(5);
	i2c_DDR |= (1 << SCL);
	i2c_PORT &= ~(1 << SCL);
	data <<= 1;
     1e0:	88 0f       	add	r24, r24
     1e2:	e7 cf       	rjmp	.-50     	; 0x1b2 <i2c_write+0x8>
  }
  i2c_DDR &= ~(1 << SDA);
     1e4:	55 98       	cbi	0x0a, 5	; 10
     1e6:	8d e0       	ldi	r24, 0x0D	; 13
     1e8:	8a 95       	dec	r24
     1ea:	f1 f7       	brne	.-4      	; 0x1e8 <i2c_write+0x3e>
  _delay_us(5);
  i2c_DDR &= ~(1 << SCL);
     1ec:	56 98       	cbi	0x0a, 6	; 10
     1ee:	8a e1       	ldi	r24, 0x1A	; 26
     1f0:	8a 95       	dec	r24
     1f2:	f1 f7       	brne	.-4      	; 0x1f0 <i2c_write+0x46>
  _delay_us(10);
  if (bit_is_set(i2c_PIN, SDA))
     1f4:	89 b1       	in	r24, 0x09	; 9
    res = 0;
  i2c_DDR |= (1 << SCL);
     1f6:	56 9a       	sbi	0x0a, 6	; 10
  i2c_PORT &= ~(1 << SCL);
     1f8:	5e 98       	cbi	0x0b, 6	; 11
  asm("sei");
     1fa:	78 94       	sei
     1fc:	82 95       	swap	r24
     1fe:	86 95       	lsr	r24
     200:	87 70       	andi	r24, 0x07	; 7
     202:	80 95       	com	r24
  return res;
}
     204:	81 70       	andi	r24, 0x01	; 1
     206:	08 95       	ret

00000208 <i2c_read>:

char i2c_read(void)
{
  char i, data = 0;
  
  asm("cli");
     208:	f8 94       	cli
     20a:	90 e0       	ldi	r25, 0x00	; 0
     20c:	20 e0       	ldi	r18, 0x00	; 0
     20e:	4d e0       	ldi	r20, 0x0D	; 13
  for (i = 0; i < 8; i++) {
    data <<= 1;
     210:	3a e1       	ldi	r19, 0x1A	; 26
     212:	22 0f       	add	r18, r18
    i2c_DDR &= ~(1 << SCL);
     214:	56 98       	cbi	0x0a, 6	; 10
	while (bit_is_clear(i2c_PIN, SCL))
     216:	4e 9b       	sbis	0x09, 6	; 9
     218:	fe cf       	rjmp	.-4      	; 0x216 <i2c_read+0xe>
     21a:	84 2f       	mov	r24, r20
     21c:	8a 95       	dec	r24
     21e:	f1 f7       	brne	.-4      	; 0x21c <i2c_read+0x14>
	  ;
	_delay_us(5);
	if (bit_is_clear(i2c_PIN, SDA))
     220:	4d 99       	sbic	0x09, 5	; 9
	  data |= 0;
	else data |= 1;
     222:	21 60       	ori	r18, 0x01	; 1
     224:	83 2f       	mov	r24, r19
     226:	8a 95       	dec	r24
     228:	f1 f7       	brne	.-4      	; 0x226 <i2c_read+0x1e>
	_delay_us(10);
	i2c_DDR |= (1 << SCL);
     22a:	56 9a       	sbi	0x0a, 6	; 10
	i2c_PORT &= ~(1 << SCL);
     22c:	5e 98       	cbi	0x0b, 6	; 11
     22e:	83 2f       	mov	r24, r19
     230:	8a 95       	dec	r24
     232:	f1 f7       	brne	.-4      	; 0x230 <i2c_read+0x28>
char i2c_read(void)
{
  char i, data = 0;
  
  asm("cli");
  for (i = 0; i < 8; i++) {
     234:	9f 5f       	subi	r25, 0xFF	; 255
     236:	98 30       	cpi	r25, 0x08	; 8
     238:	61 f7       	brne	.-40     	; 0x212 <i2c_read+0xa>
	_delay_us(10);
	i2c_DDR |= (1 << SCL);
	i2c_PORT &= ~(1 << SCL);
	_delay_us(10);
  }
  i2c_DDR &= ~(1 << SDA);
     23a:	55 98       	cbi	0x0a, 5	; 10
     23c:	8d e0       	ldi	r24, 0x0D	; 13
     23e:	98 2f       	mov	r25, r24
     240:	9a 95       	dec	r25
     242:	f1 f7       	brne	.-4      	; 0x240 <i2c_read+0x38>
  _delay_us(5);
  i2c_DDR &= ~(1 << SCL);
     244:	56 98       	cbi	0x0a, 6	; 10
     246:	9a e1       	ldi	r25, 0x1A	; 26
     248:	9a 95       	dec	r25
     24a:	f1 f7       	brne	.-4      	; 0x248 <i2c_read+0x40>
  _delay_us(10);
  i2c_DDR |= (1 << SCL);
     24c:	56 9a       	sbi	0x0a, 6	; 10
  i2c_PORT &= ~(1 << SCL);
     24e:	5e 98       	cbi	0x0b, 6	; 11
     250:	98 2f       	mov	r25, r24
     252:	9a 95       	dec	r25
     254:	f1 f7       	brne	.-4      	; 0x252 <i2c_read+0x4a>
  _delay_us(5);
  i2c_DDR &= ~(1 << SDA);
     256:	55 98       	cbi	0x0a, 5	; 10
     258:	8a 95       	dec	r24
     25a:	f1 f7       	brne	.-4      	; 0x258 <i2c_read+0x50>
  _delay_us(5);
  asm("sei");
     25c:	78 94       	sei
  return data;
}
     25e:	82 2f       	mov	r24, r18
     260:	08 95       	ret

00000262 <write_ds1307>:
   Funkcia:	 void write_ds1307(char addr, char data)
   Funkcia zapise 'data' na adresu 'addr'
*/

void write_ds1307(char addr, char data)
{
     262:	0f 93       	push	r16
     264:	1f 93       	push	r17
     266:	18 2f       	mov	r17, r24
     268:	06 2f       	mov	r16, r22
 i2c_start();
     26a:	0e 94 ae 00 	call	0x15c	; 0x15c <i2c_start>
 i2c_write(0xD0);
     26e:	80 ed       	ldi	r24, 0xD0	; 208
     270:	0e 94 d5 00 	call	0x1aa	; 0x1aa <i2c_write>
 i2c_write(addr);
     274:	81 2f       	mov	r24, r17
     276:	0e 94 d5 00 	call	0x1aa	; 0x1aa <i2c_write>
 i2c_write(data);
     27a:	80 2f       	mov	r24, r16
     27c:	0e 94 d5 00 	call	0x1aa	; 0x1aa <i2c_write>
 i2c_stop();
     280:	0e 94 c6 00 	call	0x18c	; 0x18c <i2c_stop>
}
     284:	1f 91       	pop	r17
     286:	0f 91       	pop	r16
     288:	08 95       	ret

0000028a <read_ds1307>:
   Funkcia nacita byte z adresy 'addr'
   Vrati nacitane byte
*/

char read_ds1307(char addr)
{       
     28a:	1f 93       	push	r17
     28c:	18 2f       	mov	r17, r24
 char data;
 i2c_start();
     28e:	0e 94 ae 00 	call	0x15c	; 0x15c <i2c_start>
 i2c_write(0xD0);
     292:	80 ed       	ldi	r24, 0xD0	; 208
     294:	0e 94 d5 00 	call	0x1aa	; 0x1aa <i2c_write>
 i2c_write(addr);
     298:	81 2f       	mov	r24, r17
     29a:	0e 94 d5 00 	call	0x1aa	; 0x1aa <i2c_write>
 i2c_start();
     29e:	0e 94 ae 00 	call	0x15c	; 0x15c <i2c_start>
 i2c_write(0xD1);
     2a2:	81 ed       	ldi	r24, 0xD1	; 209
     2a4:	0e 94 d5 00 	call	0x1aa	; 0x1aa <i2c_write>
 data = i2c_read();
     2a8:	0e 94 04 01 	call	0x208	; 0x208 <i2c_read>
     2ac:	18 2f       	mov	r17, r24
 i2c_stop();
     2ae:	0e 94 c6 00 	call	0x18c	; 0x18c <i2c_stop>
 return data;
     2b2:	81 2f       	mov	r24, r17
     2b4:	1f 91       	pop	r17
     2b6:	08 95       	ret

000002b8 <LCDsendChar>:
#include <avr/pgmspace.h>
#include <util/delay.h>

void LCDsendChar(uint8_t ch)		//Sends Char to LCD
{
	asm("cli");
     2b8:	f8 94       	cli
	LDP=(ch&0b11110000);
     2ba:	28 2f       	mov	r18, r24
     2bc:	20 7f       	andi	r18, 0xF0	; 240
     2be:	25 b9       	out	0x05, r18	; 5
	LCP|=1<<LCD_RS;
     2c0:	28 9a       	sbi	0x05, 0	; 5
	LCP|=1<<LCD_E;		
     2c2:	2a 9a       	sbi	0x05, 2	; 5
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     2c4:	20 ed       	ldi	r18, 0xD0	; 208
     2c6:	37 e0       	ldi	r19, 0x07	; 7
     2c8:	f9 01       	movw	r30, r18
     2ca:	31 97       	sbiw	r30, 0x01	; 1
     2cc:	f1 f7       	brne	.-4      	; 0x2ca <LCDsendChar+0x12>
	_delay_ms(1);
	LCP&=~(1<<LCD_E);	
     2ce:	2a 98       	cbi	0x05, 2	; 5
	LCP&=~(1<<LCD_RS);
     2d0:	28 98       	cbi	0x05, 0	; 5
     2d2:	f9 01       	movw	r30, r18
     2d4:	31 97       	sbiw	r30, 0x01	; 1
     2d6:	f1 f7       	brne	.-4      	; 0x2d4 <LCDsendChar+0x1c>
	_delay_ms(1);
	LDP=((ch&0b00001111)<<4);
     2d8:	90 e0       	ldi	r25, 0x00	; 0
     2da:	44 e0       	ldi	r20, 0x04	; 4
     2dc:	88 0f       	add	r24, r24
     2de:	99 1f       	adc	r25, r25
     2e0:	4a 95       	dec	r20
     2e2:	e1 f7       	brne	.-8      	; 0x2dc <LCDsendChar+0x24>
     2e4:	85 b9       	out	0x05, r24	; 5
	LCP|=1<<LCD_RS;
     2e6:	28 9a       	sbi	0x05, 0	; 5
	LCP|=1<<LCD_E;		
     2e8:	2a 9a       	sbi	0x05, 2	; 5
     2ea:	c9 01       	movw	r24, r18
     2ec:	01 97       	sbiw	r24, 0x01	; 1
     2ee:	f1 f7       	brne	.-4      	; 0x2ec <LCDsendChar+0x34>
	_delay_ms(1);
	LCP&=~(1<<LCD_E);	
     2f0:	2a 98       	cbi	0x05, 2	; 5
	LCP&=~(1<<LCD_RS);
     2f2:	28 98       	cbi	0x05, 0	; 5
     2f4:	c9 01       	movw	r24, r18
     2f6:	01 97       	sbiw	r24, 0x01	; 1
     2f8:	f1 f7       	brne	.-4      	; 0x2f6 <LCDsendChar+0x3e>
	_delay_ms(1);
	asm("sei");
     2fa:	78 94       	sei
}
     2fc:	08 95       	ret

000002fe <LCDsendCommand>:
void LCDsendCommand(uint8_t cmd)	//Sends Command to LCD
{
	asm("cli");
     2fe:	f8 94       	cli
	LDP=(cmd&0b11110000);
     300:	28 2f       	mov	r18, r24
     302:	20 7f       	andi	r18, 0xF0	; 240
     304:	25 b9       	out	0x05, r18	; 5
	LCP|=1<<LCD_E;		
     306:	2a 9a       	sbi	0x05, 2	; 5
     308:	20 ed       	ldi	r18, 0xD0	; 208
     30a:	37 e0       	ldi	r19, 0x07	; 7
     30c:	f9 01       	movw	r30, r18
     30e:	31 97       	sbiw	r30, 0x01	; 1
     310:	f1 f7       	brne	.-4      	; 0x30e <LCDsendCommand+0x10>
	_delay_ms(1);
	LCP&=~(1<<LCD_E);
     312:	2a 98       	cbi	0x05, 2	; 5
     314:	f9 01       	movw	r30, r18
     316:	31 97       	sbiw	r30, 0x01	; 1
     318:	f1 f7       	brne	.-4      	; 0x316 <LCDsendCommand+0x18>
	_delay_ms(1);
	LDP=((cmd&0b00001111)<<4);	
     31a:	90 e0       	ldi	r25, 0x00	; 0
     31c:	54 e0       	ldi	r21, 0x04	; 4
     31e:	88 0f       	add	r24, r24
     320:	99 1f       	adc	r25, r25
     322:	5a 95       	dec	r21
     324:	e1 f7       	brne	.-8      	; 0x31e <LCDsendCommand+0x20>
     326:	85 b9       	out	0x05, r24	; 5
	LCP|=1<<LCD_E;		
     328:	2a 9a       	sbi	0x05, 2	; 5
     32a:	c9 01       	movw	r24, r18
     32c:	01 97       	sbiw	r24, 0x01	; 1
     32e:	f1 f7       	brne	.-4      	; 0x32c <LCDsendCommand+0x2e>
	_delay_ms(1);
	LCP&=~(1<<LCD_E);
     330:	2a 98       	cbi	0x05, 2	; 5
     332:	c9 01       	movw	r24, r18
     334:	01 97       	sbiw	r24, 0x01	; 1
     336:	f1 f7       	brne	.-4      	; 0x334 <LCDsendCommand+0x36>
	_delay_ms(1);
	asm("sei");
     338:	78 94       	sei
}
     33a:	08 95       	ret

0000033c <LCDinit>:
void LCDinit(void)//Initializes LCD
{
	asm("cli");
     33c:	f8 94       	cli
     33e:	80 e3       	ldi	r24, 0x30	; 48
     340:	95 e7       	ldi	r25, 0x75	; 117
     342:	01 97       	sbiw	r24, 0x01	; 1
     344:	f1 f7       	brne	.-4      	; 0x342 <LCDinit+0x6>
	_delay_ms(15);
	LDP=0x00;
     346:	15 b8       	out	0x05, r1	; 5
	LCP=0x00;
     348:	15 b8       	out	0x05, r1	; 5
	LDDR|=1<<LCD_D7|1<<LCD_D6|1<<LCD_D5|1<<LCD_D4;
     34a:	84 b1       	in	r24, 0x04	; 4
     34c:	80 6f       	ori	r24, 0xF0	; 240
     34e:	84 b9       	out	0x04, r24	; 4
	LCDR|=1<<LCD_E|1<<LCD_RW|1<<LCD_RS;
     350:	84 b1       	in	r24, 0x04	; 4
     352:	87 60       	ori	r24, 0x07	; 7
     354:	84 b9       	out	0x04, r24	; 4
   //---------one------
	LDP=0<<LCD_D7|0<<LCD_D6|1<<LCD_D5|1<<LCD_D4; //4 bit mode
     356:	80 e3       	ldi	r24, 0x30	; 48
     358:	85 b9       	out	0x05, r24	; 5
	LCP|=1<<LCD_E|0<<LCD_RW|0<<LCD_RS;		
     35a:	2a 9a       	sbi	0x05, 2	; 5
     35c:	20 ed       	ldi	r18, 0xD0	; 208
     35e:	37 e0       	ldi	r19, 0x07	; 7
     360:	f9 01       	movw	r30, r18
     362:	31 97       	sbiw	r30, 0x01	; 1
     364:	f1 f7       	brne	.-4      	; 0x362 <LCDinit+0x26>
	_delay_ms(1);
	LCP&=~(1<<LCD_E);
     366:	2a 98       	cbi	0x05, 2	; 5
     368:	f9 01       	movw	r30, r18
     36a:	31 97       	sbiw	r30, 0x01	; 1
     36c:	f1 f7       	brne	.-4      	; 0x36a <LCDinit+0x2e>
	_delay_ms(1);
	//-----------two-----------
	LDP=0<<LCD_D7|0<<LCD_D6|1<<LCD_D5|1<<LCD_D4; //4 bit mode
     36e:	85 b9       	out	0x05, r24	; 5
	LCP|=1<<LCD_E|0<<LCD_RW|0<<LCD_RS;		
     370:	2a 9a       	sbi	0x05, 2	; 5
     372:	c9 01       	movw	r24, r18
     374:	01 97       	sbiw	r24, 0x01	; 1
     376:	f1 f7       	brne	.-4      	; 0x374 <LCDinit+0x38>
	_delay_ms(1);
	LCP&=~(1<<LCD_E);
     378:	2a 98       	cbi	0x05, 2	; 5
     37a:	c9 01       	movw	r24, r18
     37c:	01 97       	sbiw	r24, 0x01	; 1
     37e:	f1 f7       	brne	.-4      	; 0x37c <LCDinit+0x40>
	_delay_ms(1);
	//-------three-------------
	LDP=0<<LCD_D7|0<<LCD_D6|1<<LCD_D5|0<<LCD_D4; //4 bit mode
     380:	80 e2       	ldi	r24, 0x20	; 32
     382:	85 b9       	out	0x05, r24	; 5
	LCP|=1<<LCD_E|0<<LCD_RW|0<<LCD_RS;		
     384:	2a 9a       	sbi	0x05, 2	; 5
     386:	c9 01       	movw	r24, r18
     388:	01 97       	sbiw	r24, 0x01	; 1
     38a:	f1 f7       	brne	.-4      	; 0x388 <LCDinit+0x4c>
	_delay_ms(1);
	LCP&=~(1<<LCD_E);
     38c:	2a 98       	cbi	0x05, 2	; 5
     38e:	c9 01       	movw	r24, r18
     390:	01 97       	sbiw	r24, 0x01	; 1
     392:	f1 f7       	brne	.-4      	; 0x390 <LCDinit+0x54>
	_delay_ms(1);
	//--------4 bit--dual line---------------
	LCDsendCommand(0b00101000);
     394:	88 e2       	ldi	r24, 0x28	; 40
     396:	0e 94 7f 01 	call	0x2fe	; 0x2fe <LCDsendCommand>
   //-----increment address, cursor shift------
	LCDsendCommand(0b00001110);
     39a:	8e e0       	ldi	r24, 0x0E	; 14
     39c:	0e 94 7f 01 	call	0x2fe	; 0x2fe <LCDsendCommand>
	asm("sei");
     3a0:	78 94       	sei
}			
     3a2:	08 95       	ret

000003a4 <LCDclr>:
void LCDclr(void)				//Clears LCD
{
	LCDsendCommand(1<<LCD_CLR);
     3a4:	81 e0       	ldi	r24, 0x01	; 1
     3a6:	0e 94 7f 01 	call	0x2fe	; 0x2fe <LCDsendCommand>
}
     3aa:	08 95       	ret

000003ac <LCDhome>:
void LCDhome(void)			//LCD cursor home
{
	LCDsendCommand(1<<LCD_HOME);
     3ac:	82 e0       	ldi	r24, 0x02	; 2
     3ae:	0e 94 7f 01 	call	0x2fe	; 0x2fe <LCDsendCommand>
}
     3b2:	08 95       	ret

000003b4 <LCDstring>:
void LCDstring(uint8_t* data, uint8_t nBytes)	//Outputs string to LCD
{
     3b4:	0f 93       	push	r16
     3b6:	1f 93       	push	r17
     3b8:	cf 93       	push	r28
     3ba:	df 93       	push	r29
     3bc:	06 2f       	mov	r16, r22
register uint8_t i;

	// check to make sure we have a good pointer
	if (!data) return;
     3be:	00 97       	sbiw	r24, 0x00	; 0
     3c0:	49 f0       	breq	.+18     	; 0x3d4 <LCDstring+0x20>
     3c2:	ec 01       	movw	r28, r24
     3c4:	10 e0       	ldi	r17, 0x00	; 0
     3c6:	04 c0       	rjmp	.+8      	; 0x3d0 <LCDstring+0x1c>

	// print data
	for(i=0; i<nBytes; i++)
	{
		LCDsendChar(data[i]);
     3c8:	89 91       	ld	r24, Y+
     3ca:	0e 94 5c 01 	call	0x2b8	; 0x2b8 <LCDsendChar>

	// check to make sure we have a good pointer
	if (!data) return;

	// print data
	for(i=0; i<nBytes; i++)
     3ce:	1f 5f       	subi	r17, 0xFF	; 255
     3d0:	10 17       	cp	r17, r16
     3d2:	d0 f3       	brcs	.-12     	; 0x3c8 <LCDstring+0x14>
	{
		LCDsendChar(data[i]);
	}
}
     3d4:	df 91       	pop	r29
     3d6:	cf 91       	pop	r28
     3d8:	1f 91       	pop	r17
     3da:	0f 91       	pop	r16
     3dc:	08 95       	ret

000003de <LCDGotoXY>:
void LCDGotoXY(uint8_t x, uint8_t y)	//Cursor to X Y position
{
	asm("cli");
     3de:	f8 94       	cli
	register uint8_t DDRAMAddr;
	// remap lines into proper order
	switch(y)
     3e0:	62 30       	cpi	r22, 0x02	; 2
     3e2:	31 f0       	breq	.+12     	; 0x3f0 <LCDGotoXY+0x12>
     3e4:	63 30       	cpi	r22, 0x03	; 3
     3e6:	31 f0       	breq	.+12     	; 0x3f4 <LCDGotoXY+0x16>
     3e8:	61 30       	cpi	r22, 0x01	; 1
     3ea:	29 f4       	brne	.+10     	; 0x3f6 <LCDGotoXY+0x18>
	{
	case 0: DDRAMAddr = LCD_LINE0_DDRAMADDR+x; break;
	case 1: DDRAMAddr = LCD_LINE1_DDRAMADDR+x; break;
     3ec:	80 5c       	subi	r24, 0xC0	; 192
     3ee:	03 c0       	rjmp	.+6      	; 0x3f6 <LCDGotoXY+0x18>
	case 2: DDRAMAddr = LCD_LINE2_DDRAMADDR+x; break;
     3f0:	8c 5e       	subi	r24, 0xEC	; 236
     3f2:	01 c0       	rjmp	.+2      	; 0x3f6 <LCDGotoXY+0x18>
	case 3: DDRAMAddr = LCD_LINE3_DDRAMADDR+x; break;
     3f4:	8c 5a       	subi	r24, 0xAC	; 172
	default: DDRAMAddr = LCD_LINE0_DDRAMADDR+x;
	}
	// set data address
	LCDsendCommand(1<<LCD_DDRAM | DDRAMAddr);
     3f6:	80 68       	ori	r24, 0x80	; 128
     3f8:	0e 94 7f 01 	call	0x2fe	; 0x2fe <LCDsendCommand>
	asm("sei");
     3fc:	78 94       	sei
}
     3fe:	08 95       	ret

00000400 <CopyStringtoLCD>:
//Copies string from flash memory to LCD at x y position
//const uint8_t welcomeln1[] PROGMEM="AVR LCD DEMO\0";
//CopyStringtoLCD(welcomeln1, 3, 1);	
void CopyStringtoLCD(const uint8_t *FlashLoc, uint8_t x, uint8_t y)
{
     400:	1f 93       	push	r17
     402:	cf 93       	push	r28
     404:	df 93       	push	r29
     406:	ec 01       	movw	r28, r24
     408:	86 2f       	mov	r24, r22
	uint8_t i;
	LCDGotoXY(x,y);
     40a:	64 2f       	mov	r22, r20
     40c:	0e 94 ef 01 	call	0x3de	; 0x3de <LCDGotoXY>
     410:	10 e0       	ldi	r17, 0x00	; 0
     412:	03 c0       	rjmp	.+6      	; 0x41a <CopyStringtoLCD+0x1a>
	for(i=0;(uint8_t)pgm_read_byte(&FlashLoc[i]);i++)
	{
		LCDsendChar((uint8_t)pgm_read_byte(&FlashLoc[i]));
     414:	0e 94 5c 01 	call	0x2b8	; 0x2b8 <LCDsendChar>
//CopyStringtoLCD(welcomeln1, 3, 1);	
void CopyStringtoLCD(const uint8_t *FlashLoc, uint8_t x, uint8_t y)
{
	uint8_t i;
	LCDGotoXY(x,y);
	for(i=0;(uint8_t)pgm_read_byte(&FlashLoc[i]);i++)
     418:	1f 5f       	subi	r17, 0xFF	; 255
     41a:	fe 01       	movw	r30, r28
     41c:	e1 0f       	add	r30, r17
     41e:	f1 1d       	adc	r31, r1
     420:	84 91       	lpm	r24, Z+
     422:	88 23       	and	r24, r24
     424:	b9 f7       	brne	.-18     	; 0x414 <CopyStringtoLCD+0x14>
	{
		LCDsendChar((uint8_t)pgm_read_byte(&FlashLoc[i]));
	}
}
     426:	df 91       	pop	r29
     428:	cf 91       	pop	r28
     42a:	1f 91       	pop	r17
     42c:	08 95       	ret

0000042e <LCDdefinechar>:
0b00000000,
0b00000000
};
LCDdefinechar(backslash,0);
*/
void LCDdefinechar(const uint8_t *pc,uint8_t char_code){
     42e:	ef 92       	push	r14
     430:	ff 92       	push	r15
     432:	0f 93       	push	r16
     434:	1f 93       	push	r17
     436:	cf 93       	push	r28
     438:	df 93       	push	r29
     43a:	7c 01       	movw	r14, r24
     43c:	16 2f       	mov	r17, r22
	uint8_t a, pcc;
	uint16_t i;
	a=(char_code<<3)|0x40;
     43e:	11 0f       	add	r17, r17
     440:	11 0f       	add	r17, r17
     442:	11 0f       	add	r17, r17
     444:	10 64       	ori	r17, 0x40	; 64
     446:	c0 e0       	ldi	r28, 0x00	; 0
     448:	d0 e0       	ldi	r29, 0x00	; 0
	for (i=0; i<8; i++){
		pcc=pgm_read_byte(&pc[i]);
     44a:	f7 01       	movw	r30, r14
     44c:	ec 0f       	add	r30, r28
     44e:	fd 1f       	adc	r31, r29
     450:	04 91       	lpm	r16, Z+
		LCDsendCommand(a++);
     452:	81 2f       	mov	r24, r17
     454:	8c 0f       	add	r24, r28
     456:	0e 94 7f 01 	call	0x2fe	; 0x2fe <LCDsendCommand>
		LCDsendChar(pcc);
     45a:	80 2f       	mov	r24, r16
     45c:	0e 94 5c 01 	call	0x2b8	; 0x2b8 <LCDsendChar>
*/
void LCDdefinechar(const uint8_t *pc,uint8_t char_code){
	uint8_t a, pcc;
	uint16_t i;
	a=(char_code<<3)|0x40;
	for (i=0; i<8; i++){
     460:	21 96       	adiw	r28, 0x01	; 1
     462:	c8 30       	cpi	r28, 0x08	; 8
     464:	d1 05       	cpc	r29, r1
     466:	89 f7       	brne	.-30     	; 0x44a <LCDdefinechar+0x1c>
		pcc=pgm_read_byte(&pc[i]);
		LCDsendCommand(a++);
		LCDsendChar(pcc);
		}
}
     468:	df 91       	pop	r29
     46a:	cf 91       	pop	r28
     46c:	1f 91       	pop	r17
     46e:	0f 91       	pop	r16
     470:	ff 90       	pop	r15
     472:	ef 90       	pop	r14
     474:	08 95       	ret

00000476 <LCDshiftLeft>:

void LCDshiftLeft(uint8_t n)	//Scrol n of characters Right
{
     476:	0f 93       	push	r16
     478:	1f 93       	push	r17
     47a:	08 2f       	mov	r16, r24
     47c:	10 e0       	ldi	r17, 0x00	; 0
     47e:	04 c0       	rjmp	.+8      	; 0x488 <LCDshiftLeft+0x12>
	for (uint8_t i=0;i<n;i++)
	{
		LCDsendCommand(0x1E);
     480:	8e e1       	ldi	r24, 0x1E	; 30
     482:	0e 94 7f 01 	call	0x2fe	; 0x2fe <LCDsendCommand>
		}
}

void LCDshiftLeft(uint8_t n)	//Scrol n of characters Right
{
	for (uint8_t i=0;i<n;i++)
     486:	1f 5f       	subi	r17, 0xFF	; 255
     488:	10 17       	cp	r17, r16
     48a:	d0 f3       	brcs	.-12     	; 0x480 <LCDshiftLeft+0xa>
	{
		LCDsendCommand(0x1E);
	}
}
     48c:	1f 91       	pop	r17
     48e:	0f 91       	pop	r16
     490:	08 95       	ret

00000492 <LCDshiftRight>:
void LCDshiftRight(uint8_t n)	//Scrol n of characters Left
{
     492:	0f 93       	push	r16
     494:	1f 93       	push	r17
     496:	08 2f       	mov	r16, r24
     498:	10 e0       	ldi	r17, 0x00	; 0
     49a:	04 c0       	rjmp	.+8      	; 0x4a4 <LCDshiftRight+0x12>
	for (uint8_t i=0;i<n;i++)
	{
		LCDsendCommand(0x18);
     49c:	88 e1       	ldi	r24, 0x18	; 24
     49e:	0e 94 7f 01 	call	0x2fe	; 0x2fe <LCDsendCommand>
		LCDsendCommand(0x1E);
	}
}
void LCDshiftRight(uint8_t n)	//Scrol n of characters Left
{
	for (uint8_t i=0;i<n;i++)
     4a2:	1f 5f       	subi	r17, 0xFF	; 255
     4a4:	10 17       	cp	r17, r16
     4a6:	d0 f3       	brcs	.-12     	; 0x49c <LCDshiftRight+0xa>
	{
		LCDsendCommand(0x18);
	}
}
     4a8:	1f 91       	pop	r17
     4aa:	0f 91       	pop	r16
     4ac:	08 95       	ret

000004ae <LCDcursorOn>:
void LCDcursorOn(void) //displays LCD cursor
{
	LCDsendCommand(0x0E);
     4ae:	8e e0       	ldi	r24, 0x0E	; 14
     4b0:	0e 94 7f 01 	call	0x2fe	; 0x2fe <LCDsendCommand>
}
     4b4:	08 95       	ret

000004b6 <LCDcursorOnBlink>:
void LCDcursorOnBlink(void)	//displays LCD blinking cursor
{
	LCDsendCommand(0x0F);
     4b6:	8f e0       	ldi	r24, 0x0F	; 15
     4b8:	0e 94 7f 01 	call	0x2fe	; 0x2fe <LCDsendCommand>
}
     4bc:	08 95       	ret

000004be <LCDcursorOFF>:
void LCDcursorOFF(void)	//turns OFF cursor
{
	LCDsendCommand(0x0C);
     4be:	8c e0       	ldi	r24, 0x0C	; 12
     4c0:	0e 94 7f 01 	call	0x2fe	; 0x2fe <LCDsendCommand>
}
     4c4:	08 95       	ret

000004c6 <LCDblank>:
void LCDblank(void)		//blanks LCD
{
	LCDsendCommand(0x08);
     4c6:	88 e0       	ldi	r24, 0x08	; 8
     4c8:	0e 94 7f 01 	call	0x2fe	; 0x2fe <LCDsendCommand>
}
     4cc:	08 95       	ret

000004ce <LCDvisible>:
void LCDvisible(void)		//Shows LCD
{
	LCDsendCommand(0x0C);
     4ce:	8c e0       	ldi	r24, 0x0C	; 12
     4d0:	0e 94 7f 01 	call	0x2fe	; 0x2fe <LCDsendCommand>
}
     4d4:	08 95       	ret

000004d6 <LCDcursorLeft>:
void LCDcursorLeft(uint8_t n)	//Moves cursor by n poisitions left
{
     4d6:	0f 93       	push	r16
     4d8:	1f 93       	push	r17
     4da:	08 2f       	mov	r16, r24
     4dc:	10 e0       	ldi	r17, 0x00	; 0
     4de:	04 c0       	rjmp	.+8      	; 0x4e8 <LCDcursorLeft+0x12>
	for (uint8_t i=0;i<n;i++)
	{
		LCDsendCommand(0x10);
     4e0:	80 e1       	ldi	r24, 0x10	; 16
     4e2:	0e 94 7f 01 	call	0x2fe	; 0x2fe <LCDsendCommand>
{
	LCDsendCommand(0x0C);
}
void LCDcursorLeft(uint8_t n)	//Moves cursor by n poisitions left
{
	for (uint8_t i=0;i<n;i++)
     4e6:	1f 5f       	subi	r17, 0xFF	; 255
     4e8:	10 17       	cp	r17, r16
     4ea:	d0 f3       	brcs	.-12     	; 0x4e0 <LCDcursorLeft+0xa>
	{
		LCDsendCommand(0x10);
	}
}
     4ec:	1f 91       	pop	r17
     4ee:	0f 91       	pop	r16
     4f0:	08 95       	ret

000004f2 <LCDcursorRight>:
void LCDcursorRight(uint8_t n)	//Moves cursor by n poisitions left
{
     4f2:	0f 93       	push	r16
     4f4:	1f 93       	push	r17
     4f6:	08 2f       	mov	r16, r24
     4f8:	10 e0       	ldi	r17, 0x00	; 0
     4fa:	04 c0       	rjmp	.+8      	; 0x504 <__stack+0x5>
	for (uint8_t i=0;i<n;i++)
	{
		LCDsendCommand(0x14);
     4fc:	84 e1       	ldi	r24, 0x14	; 20
     4fe:	0e 94 7f 01 	call	0x2fe	; 0x2fe <LCDsendCommand>
		LCDsendCommand(0x10);
	}
}
void LCDcursorRight(uint8_t n)	//Moves cursor by n poisitions left
{
	for (uint8_t i=0;i<n;i++)
     502:	1f 5f       	subi	r17, 0xFF	; 255
     504:	10 17       	cp	r17, r16
     506:	d0 f3       	brcs	.-12     	; 0x4fc <LCDcursorRight+0xa>
	{
		LCDsendCommand(0x14);
	}
}
     508:	1f 91       	pop	r17
     50a:	0f 91       	pop	r16
     50c:	08 95       	ret

0000050e <CHbit_nastav>:
  }
}
//----------------------------------------------------------------------
void CHbit_nastav(void)
{
  udaje.sek = read_ds1307(0);
     50e:	80 e0       	ldi	r24, 0x00	; 0
     510:	0e 94 45 01 	call	0x28a	; 0x28a <read_ds1307>
     514:	68 2f       	mov	r22, r24
     516:	80 93 34 04 	sts	0x0434, r24
  write_ds1307(0, (udaje.sek|0x80));
     51a:	60 68       	ori	r22, 0x80	; 128
     51c:	80 e0       	ldi	r24, 0x00	; 0
     51e:	0e 94 31 01 	call	0x262	; 0x262 <write_ds1307>
}
     522:	08 95       	ret

00000524 <CHbit_nuluj>:
//----------------------------------------------------------------------
void CHbit_nuluj(void)
{
  udaje.sek = read_ds1307(0);
     524:	80 e0       	ldi	r24, 0x00	; 0
     526:	0e 94 45 01 	call	0x28a	; 0x28a <read_ds1307>
     52a:	68 2f       	mov	r22, r24
     52c:	80 93 34 04 	sts	0x0434, r24
  write_ds1307(0, (udaje.sek&0x7f));
     530:	6f 77       	andi	r22, 0x7F	; 127
     532:	80 e0       	ldi	r24, 0x00	; 0
     534:	0e 94 31 01 	call	0x262	; 0x262 <write_ds1307>
}
     538:	08 95       	ret

0000053a <cakaj>:
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
     53a:	21 e0       	ldi	r18, 0x01	; 1
     53c:	30 e0       	ldi	r19, 0x00	; 0
     53e:	02 c0       	rjmp	.+4      	; 0x544 <cakaj+0xa>
     540:	22 0f       	add	r18, r18
     542:	33 1f       	adc	r19, r19
     544:	8a 95       	dec	r24
     546:	e2 f7       	brpl	.-8      	; 0x540 <cakaj+0x6>
  while (bit_is_set(PINC, p)) ;
     548:	86 b1       	in	r24, 0x06	; 6
     54a:	90 e0       	ldi	r25, 0x00	; 0
     54c:	82 23       	and	r24, r18
     54e:	93 23       	and	r25, r19
     550:	89 2b       	or	r24, r25
     552:	d1 f7       	brne	.-12     	; 0x548 <cakaj+0xe>
}
     554:	08 95       	ret

00000556 <decToBcd>:
//----------------------------------------------------------------------
char decToBcd(char d)
{
     556:	28 2f       	mov	r18, r24
     558:	6a e0       	ldi	r22, 0x0A	; 10
     55a:	0e 94 99 13 	call	0x2732	; 0x2732 <__udivmodqi4>
     55e:	38 2f       	mov	r19, r24
     560:	32 95       	swap	r19
     562:	30 7f       	andi	r19, 0xF0	; 240
     564:	82 2f       	mov	r24, r18
     566:	0e 94 99 13 	call	0x2732	; 0x2732 <__udivmodqi4>
  return (((d/10)<<4) + (d%10));
}
     56a:	83 2f       	mov	r24, r19
     56c:	89 0f       	add	r24, r25
     56e:	08 95       	ret

00000570 <bcdToDec>:
//----------------------------------------------------------------------
char bcdToDec(char b)
{
     570:	28 2f       	mov	r18, r24
     572:	22 95       	swap	r18
     574:	2f 70       	andi	r18, 0x0F	; 15
     576:	9a e0       	ldi	r25, 0x0A	; 10
     578:	29 9f       	mul	r18, r25
     57a:	90 01       	movw	r18, r0
     57c:	11 24       	eor	r1, r1
     57e:	8f 70       	andi	r24, 0x0F	; 15
  return (((b>>4)*10) + ((b&0x0f)));
}
     580:	82 0f       	add	r24, r18
     582:	08 95       	ret

00000584 <zisti_den>:
//----------------------------------------------------------------------
void zisti_den(void)				//zisti den 
{
     584:	1f 93       	push	r17
     586:	cf 93       	push	r28
     588:	df 93       	push	r29
  char den, mesiac, rok, sum = 0;
									// POSTUP
  den = bcdToDec(udaje.den);		// vsetky hodnoty na dekadicke
     58a:	80 91 38 04 	lds	r24, 0x0438
  mesiac = bcdToDec(udaje.mes);
     58e:	90 91 39 04 	lds	r25, 0x0439
  return (((d/10)<<4) + (d%10));
}
//----------------------------------------------------------------------
char bcdToDec(char b)
{
  return (((b>>4)*10) + ((b&0x0f)));
     592:	29 2f       	mov	r18, r25
     594:	22 95       	swap	r18
     596:	2f 70       	andi	r18, 0x0F	; 15
     598:	5a e0       	ldi	r21, 0x0A	; 10
     59a:	25 9f       	mul	r18, r21
     59c:	90 01       	movw	r18, r0
     59e:	11 24       	eor	r1, r1
     5a0:	19 2f       	mov	r17, r25
     5a2:	1f 70       	andi	r17, 0x0F	; 15
     5a4:	12 0f       	add	r17, r18
{
  char den, mesiac, rok, sum = 0;
									// POSTUP
  den = bcdToDec(udaje.den);		// vsetky hodnoty na dekadicke
  mesiac = bcdToDec(udaje.mes);
  rok = bcdToDec(udaje.rok);
     5a6:	40 91 3a 04 	lds	r20, 0x043A
  return (((d/10)<<4) + (d%10));
}
//----------------------------------------------------------------------
char bcdToDec(char b)
{
  return (((b>>4)*10) + ((b&0x0f)));
     5aa:	24 2f       	mov	r18, r20
     5ac:	22 95       	swap	r18
     5ae:	2f 70       	andi	r18, 0x0F	; 15
     5b0:	25 9f       	mul	r18, r21
     5b2:	90 01       	movw	r18, r0
     5b4:	11 24       	eor	r1, r1
     5b6:	4f 70       	andi	r20, 0x0F	; 15
     5b8:	42 0f       	add	r20, r18
  den = bcdToDec(udaje.den);		// vsetky hodnoty na dekadicke
  mesiac = bcdToDec(udaje.mes);
  rok = bcdToDec(udaje.rok);
  sum += (den % 7);
  sum += mon[mesiac-1];
  sum += ((rok + (rok / 4)) % 7);
     5ba:	c4 2f       	mov	r28, r20
     5bc:	d0 e0       	ldi	r29, 0x00	; 0
									// POSTUP
  den = bcdToDec(udaje.den);		// vsetky hodnoty na dekadicke
  mesiac = bcdToDec(udaje.mes);
  rok = bcdToDec(udaje.rok);
  sum += (den % 7);
  sum += mon[mesiac-1];
     5be:	28 2f       	mov	r18, r24
     5c0:	22 95       	swap	r18
     5c2:	2f 70       	andi	r18, 0x0F	; 15
     5c4:	25 9f       	mul	r18, r21
     5c6:	90 01       	movw	r18, r0
     5c8:	11 24       	eor	r1, r1
     5ca:	8f 70       	andi	r24, 0x0F	; 15
     5cc:	82 0f       	add	r24, r18
     5ce:	67 e0       	ldi	r22, 0x07	; 7
     5d0:	0e 94 99 13 	call	0x2732	; 0x2732 <__udivmodqi4>
     5d4:	29 2f       	mov	r18, r25
     5d6:	2a 5f       	subi	r18, 0xFA	; 250
  sum += ((rok + (rok / 4)) % 7);
     5d8:	e1 2f       	mov	r30, r17
     5da:	f0 e0       	ldi	r31, 0x00	; 0
     5dc:	ee 5d       	subi	r30, 0xDE	; 222
     5de:	fc 4f       	sbci	r31, 0xFC	; 252
     5e0:	80 81       	ld	r24, Z
     5e2:	28 0f       	add	r18, r24
  sum += STR;
     5e4:	46 95       	lsr	r20
     5e6:	46 95       	lsr	r20
     5e8:	ce 01       	movw	r24, r28
     5ea:	84 0f       	add	r24, r20
     5ec:	91 1d       	adc	r25, r1
     5ee:	67 e0       	ldi	r22, 0x07	; 7
     5f0:	70 e0       	ldi	r23, 0x00	; 0
     5f2:	0e 94 a5 13 	call	0x274a	; 0x274a <__divmodhi4>
  if ((sum %= 7) == 0)
     5f6:	82 0f       	add	r24, r18
     5f8:	67 e0       	ldi	r22, 0x07	; 7
     5fa:	0e 94 99 13 	call	0x2732	; 0x2732 <__udivmodqi4>
     5fe:	99 23       	and	r25, r25
     600:	09 f4       	brne	.+2      	; 0x604 <zisti_den+0x80>
     602:	97 e0       	ldi	r25, 0x07	; 7
    sum = 7;
  if ((rok % 4) == 0) {
     604:	c3 70       	andi	r28, 0x03	; 3
     606:	d0 70       	andi	r29, 0x00	; 0
     608:	cd 2b       	or	r28, r29
     60a:	39 f4       	brne	.+14     	; 0x61a <zisti_den+0x96>
    if ((mesiac == 1) || (mesiac == 2))
     60c:	11 50       	subi	r17, 0x01	; 1
     60e:	12 30       	cpi	r17, 0x02	; 2
     610:	20 f4       	brcc	.+8      	; 0x61a <zisti_den+0x96>
      if ((sum += 6) > 7)
     612:	9a 5f       	subi	r25, 0xFA	; 250
     614:	98 30       	cpi	r25, 0x08	; 8
     616:	08 f0       	brcs	.+2      	; 0x61a <zisti_den+0x96>
	    sum -= 7;
     618:	97 50       	subi	r25, 0x07	; 7
  }
  udaje.mDen = sum;
     61a:	90 93 37 04 	sts	0x0437, r25
}
     61e:	df 91       	pop	r29
     620:	cf 91       	pop	r28
     622:	1f 91       	pop	r17
     624:	08 95       	ret

00000626 <nastav_ukoncit>:
}
//----------------------------------------------------------------------
char nastav_ukoncit(void)
{
  return 1;
}
     626:	81 e0       	ldi	r24, 0x01	; 1
     628:	08 95       	ret

0000062a <LCDcistiXY>:
//----------------------------------------------------------------------
void LCDcistiXY(char x, char y, char pct)
{
     62a:	0f 93       	push	r16
     62c:	1f 93       	push	r17
     62e:	04 2f       	mov	r16, r20
  LCDGotoXY(x, y);
     630:	0e 94 ef 01 	call	0x3de	; 0x3de <LCDGotoXY>
     634:	10 e0       	ldi	r17, 0x00	; 0
     636:	04 c0       	rjmp	.+8      	; 0x640 <LCDcistiXY+0x16>
  for (unsigned char i = 0; i < pct; i++)
    LCDsendChar(' ');
     638:	80 e2       	ldi	r24, 0x20	; 32
     63a:	0e 94 5c 01 	call	0x2b8	; 0x2b8 <LCDsendChar>
}
//----------------------------------------------------------------------
void LCDcistiXY(char x, char y, char pct)
{
  LCDGotoXY(x, y);
  for (unsigned char i = 0; i < pct; i++)
     63e:	1f 5f       	subi	r17, 0xFF	; 255
     640:	10 17       	cp	r17, r16
     642:	d0 f3       	brcs	.-12     	; 0x638 <LCDcistiXY+0xe>
    LCDsendChar(' ');
}
     644:	1f 91       	pop	r17
     646:	0f 91       	pop	r16
     648:	08 95       	ret

0000064a <LCDstringXY>:
//----------------------------------------------------------------------
void LCDstringXY(char X, char Y, char *str, char pct)
{
     64a:	ff 92       	push	r15
     64c:	0f 93       	push	r16
     64e:	1f 93       	push	r17
     650:	8a 01       	movw	r16, r20
     652:	f2 2e       	mov	r15, r18
  LCDGotoXY(X, Y);
     654:	0e 94 ef 01 	call	0x3de	; 0x3de <LCDGotoXY>
  LCDstring(str, pct);
     658:	c8 01       	movw	r24, r16
     65a:	6f 2d       	mov	r22, r15
     65c:	0e 94 da 01 	call	0x3b4	; 0x3b4 <LCDstring>
}
     660:	1f 91       	pop	r17
     662:	0f 91       	pop	r16
     664:	ff 90       	pop	r15
     666:	08 95       	ret

00000668 <skenuj_tep>:
//----------------------------------------------------------------------

//----------------------------------------------------------------------
void skenuj_tep(void)		// funkcia pouzita len v casovaci
{
  if (udaje.teplota < 80) {
     668:	90 91 33 04 	lds	r25, 0x0433
     66c:	90 35       	cpi	r25, 0x50	; 80
     66e:	50 f5       	brcc	.+84     	; 0x6c4 <skenuj_tep+0x5c>
    if (udaje.teplota <= mon_udaje.min_temp) {
     670:	80 91 2b 04 	lds	r24, 0x042B
     674:	89 17       	cp	r24, r25
     676:	70 f0       	brcs	.+28     	; 0x694 <skenuj_tep+0x2c>
	  mon_udaje.min_temp = udaje.teplota;
     678:	90 93 2b 04 	sts	0x042B, r25
	  mon_udaje.min_den = udaje.den;
     67c:	80 91 38 04 	lds	r24, 0x0438
     680:	80 93 2c 04 	sts	0x042C, r24
	  mon_udaje.min_mes = udaje.mes;
     684:	80 91 39 04 	lds	r24, 0x0439
     688:	80 93 2d 04 	sts	0x042D, r24
	  mon_udaje.min_rok = udaje.rok;
     68c:	80 91 3a 04 	lds	r24, 0x043A
     690:	80 93 2e 04 	sts	0x042E, r24
	}
    if (udaje.teplota >= mon_udaje.max_temp) {
     694:	80 91 2f 04 	lds	r24, 0x042F
     698:	98 17       	cp	r25, r24
     69a:	a0 f0       	brcs	.+40     	; 0x6c4 <skenuj_tep+0x5c>
	  while (err1) 
     69c:	80 91 fb 03 	lds	r24, 0x03FB
     6a0:	88 23       	and	r24, r24
     6a2:	79 f4       	brne	.+30     	; 0x6c2 <skenuj_tep+0x5a>
	    ;
	  mon_udaje.max_temp = udaje.teplota;
     6a4:	90 93 2f 04 	sts	0x042F, r25
      mon_udaje.max_den = udaje.den;
     6a8:	80 91 38 04 	lds	r24, 0x0438
     6ac:	80 93 30 04 	sts	0x0430, r24
	  mon_udaje.max_mes = udaje.mes;
     6b0:	80 91 39 04 	lds	r24, 0x0439
     6b4:	80 93 31 04 	sts	0x0431, r24
	  mon_udaje.max_rok = udaje.rok;
     6b8:	80 91 3a 04 	lds	r24, 0x043A
     6bc:	80 93 32 04 	sts	0x0432, r24
     6c0:	08 95       	ret
     6c2:	ff cf       	rjmp	.-2      	; 0x6c2 <skenuj_tep+0x5a>
     6c4:	08 95       	ret

000006c6 <USART_Transmit>:
    }
  }
}
//----------------------------------------------------------------------
void USART_Transmit(char ch)
{
     6c6:	98 2f       	mov	r25, r24
   while (!(UCSR0A & (1<<UDRE0)));
     6c8:	80 91 c0 00 	lds	r24, 0x00C0
     6cc:	85 ff       	sbrs	r24, 5
     6ce:	fc cf       	rjmp	.-8      	; 0x6c8 <USART_Transmit+0x2>
   UDR0=ch;
     6d0:	90 93 c6 00 	sts	0x00C6, r25

   return 0;
}
     6d4:	08 95       	ret

000006d6 <USART_Receive>:
//----------------------------------------------------------------------
char USART_Receive(void)
{
   unsigned char ch;

   while (!(UCSR0A & (1<<RXC0)));
     6d6:	80 91 c0 00 	lds	r24, 0x00C0
     6da:	87 ff       	sbrs	r24, 7
     6dc:	fc cf       	rjmp	.-8      	; 0x6d6 <USART_Receive>
   ch=UDR0;  
     6de:	80 91 c6 00 	lds	r24, 0x00C6

   return ch;
}
     6e2:	08 95       	ret

000006e4 <USART_Init>:
//----------------------------------------------------------------------
/* 19200kbps 8N1 */
void USART_Init(void)
{
  UCSR0A = 0x00;
     6e4:	10 92 c0 00 	sts	0x00C0, r1
  UCSR0B = 0x98;
     6e8:	88 e9       	ldi	r24, 0x98	; 152
     6ea:	80 93 c1 00 	sts	0x00C1, r24
  UCSR0C = 0x06;
     6ee:	86 e0       	ldi	r24, 0x06	; 6
     6f0:	80 93 c2 00 	sts	0x00C2, r24
  UBRR0H = 0x00;
     6f4:	10 92 c5 00 	sts	0x00C5, r1
  UBRR0L = 0x19;
     6f8:	89 e1       	ldi	r24, 0x19	; 25
     6fa:	80 93 c4 00 	sts	0x00C4, r24
}
     6fe:	08 95       	ret

00000700 <USART_Flush>:
//----------------------------------------------------------------------
void USART_Flush(void)
{
     700:	02 c0       	rjmp	.+4      	; 0x706 <USART_Flush+0x6>
  unsigned char dummy;

  while ( UCSR0A & (1<<RXC0) ) 
    dummy = UDR0;
     702:	80 91 c6 00 	lds	r24, 0x00C6
//----------------------------------------------------------------------
void USART_Flush(void)
{
  unsigned char dummy;

  while ( UCSR0A & (1<<RXC0) ) 
     706:	80 91 c0 00 	lds	r24, 0x00C0
     70a:	87 fd       	sbrc	r24, 7
     70c:	fa cf       	rjmp	.-12     	; 0x702 <USART_Flush+0x2>
    dummy = UDR0;
}
     70e:	08 95       	ret

00000710 <nastav_casovac0>:
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void nastav_casovac0(char tcra, char tcrb, char tnt, char s)
{
  TCCR0A=tcra;
     710:	84 bd       	out	0x24, r24	; 36
  TCCR0B=tcrb;
     712:	65 bd       	out	0x25, r22	; 37
  TCNT0=tnt;
     714:	46 bd       	out	0x26, r20	; 38
  TIMSK0=s;
     716:	20 93 6e 00 	sts	0x006E, r18
}
     71a:	08 95       	ret

0000071c <nastav_casovac2>:
//----------------------------------------------------------------------
void nastav_casovac2(char tcra, char tcrb, char tnt, char s)
{
  TCCR2A=tcra;
     71c:	80 93 b0 00 	sts	0x00B0, r24
  TCCR2B=tcrb;
     720:	60 93 b1 00 	sts	0x00B1, r22
  TCNT2=tnt;
     724:	40 93 b2 00 	sts	0x00B2, r20
  TIMSK2=s;  
     728:	20 93 70 00 	sts	0x0070, r18
}
     72c:	08 95       	ret

0000072e <skenuj_alarm>:
//----------------------------------------------------------------------
void skenuj_alarm(void)
{
  if (alarm.al_den == 10)
     72e:	90 91 27 04 	lds	r25, 0x0427
     732:	9a 30       	cpi	r25, 0x0A	; 10
     734:	b1 f0       	breq	.+44     	; 0x762 <skenuj_alarm+0x34>
    goto pokr_al;
  if ((alarm.al_den <= 7) && (alarm.al_den == udaje.mDen))		// jeden den
     736:	98 30       	cpi	r25, 0x08	; 8
     738:	28 f4       	brcc	.+10     	; 0x744 <skenuj_alarm+0x16>
     73a:	80 91 37 04 	lds	r24, 0x0437
     73e:	98 17       	cp	r25, r24
     740:	41 f4       	brne	.+16     	; 0x752 <skenuj_alarm+0x24>
     742:	0f c0       	rjmp	.+30     	; 0x762 <skenuj_alarm+0x34>
    goto pokr_al;
  if ((alarm.al_den == 8) && (udaje.mDen <= 5))				// Po - Pia
     744:	98 30       	cpi	r25, 0x08	; 8
     746:	29 f4       	brne	.+10     	; 0x752 <skenuj_alarm+0x24>
     748:	80 91 37 04 	lds	r24, 0x0437
     74c:	86 30       	cpi	r24, 0x06	; 6
     74e:	48 f0       	brcs	.+18     	; 0x762 <skenuj_alarm+0x34>
     750:	08 95       	ret
    goto pokr_al;
  if ((alarm.al_den == 9) && (udaje.mDen >= 6))				// So - Ne
     752:	99 30       	cpi	r25, 0x09	; 9
     754:	09 f0       	breq	.+2      	; 0x758 <skenuj_alarm+0x2a>
     756:	5d c0       	rjmp	.+186    	; 0x812 <skenuj_alarm+0xe4>
     758:	80 91 37 04 	lds	r24, 0x0437
     75c:	86 30       	cpi	r24, 0x06	; 6
     75e:	08 f4       	brcc	.+2      	; 0x762 <skenuj_alarm+0x34>
     760:	58 c0       	rjmp	.+176    	; 0x812 <skenuj_alarm+0xe4>
    goto pokr_al;
  
  return;
  pokr_al:
  if ((alarm.clock == 1) && (alarm.temp == 0)) {
     762:	80 91 25 04 	lds	r24, 0x0425
     766:	81 30       	cpi	r24, 0x01	; 1
     768:	e9 f4       	brne	.+58     	; 0x7a4 <skenuj_alarm+0x76>
     76a:	80 91 24 04 	lds	r24, 0x0424
     76e:	88 23       	and	r24, r24
     770:	71 f5       	brne	.+92     	; 0x7ce <skenuj_alarm+0xa0>
    if ((alarm.al_hod == udaje.hod) && (alarm.al_min == udaje.min) && (alarm.al_sek == udaje.sek)) {
     772:	90 91 20 04 	lds	r25, 0x0420
     776:	80 91 36 04 	lds	r24, 0x0436
     77a:	98 17       	cp	r25, r24
     77c:	41 f5       	brne	.+80     	; 0x7ce <skenuj_alarm+0xa0>
     77e:	90 91 21 04 	lds	r25, 0x0421
     782:	80 91 35 04 	lds	r24, 0x0435
     786:	98 17       	cp	r25, r24
     788:	11 f5       	brne	.+68     	; 0x7ce <skenuj_alarm+0xa0>
     78a:	90 91 22 04 	lds	r25, 0x0422
     78e:	80 91 34 04 	lds	r24, 0x0434
     792:	98 17       	cp	r25, r24
     794:	e1 f4       	brne	.+56     	; 0x7ce <skenuj_alarm+0xa0>
	  PORTC |= 8;
     796:	43 9a       	sbi	0x08, 3	; 8
	  al_res.pipa = 1;
     798:	80 91 2a 04 	lds	r24, 0x042A
     79c:	81 60       	ori	r24, 0x01	; 1
     79e:	80 93 2a 04 	sts	0x042A, r24
     7a2:	15 c0       	rjmp	.+42     	; 0x7ce <skenuj_alarm+0xa0>
	}
  }
  if ((alarm.clock == 0) && (alarm.temp == 1)) {
     7a4:	88 23       	and	r24, r24
     7a6:	a9 f5       	brne	.+106    	; 0x812 <skenuj_alarm+0xe4>
     7a8:	80 91 24 04 	lds	r24, 0x0424
     7ac:	81 30       	cpi	r24, 0x01	; 1
     7ae:	89 f5       	brne	.+98     	; 0x812 <skenuj_alarm+0xe4>
    if (alarm.al_temp == udaje.teplota) {
     7b0:	90 91 23 04 	lds	r25, 0x0423
     7b4:	80 91 33 04 	lds	r24, 0x0433
     7b8:	98 17       	cp	r25, r24
     7ba:	59 f5       	brne	.+86     	; 0x812 <skenuj_alarm+0xe4>
	  PORTC |= 8;
     7bc:	43 9a       	sbi	0x08, 3	; 8
	  alarm.temp = 0;
     7be:	10 92 24 04 	sts	0x0424, r1
	  al_res.pipa = 1;
     7c2:	80 91 2a 04 	lds	r24, 0x042A
     7c6:	81 60       	ori	r24, 0x01	; 1
     7c8:	80 93 2a 04 	sts	0x042A, r24
     7cc:	08 95       	ret
	}
  }
  if ((alarm.clock == 1) && (alarm.temp == 1)) {
     7ce:	80 91 24 04 	lds	r24, 0x0424
     7d2:	81 30       	cpi	r24, 0x01	; 1
     7d4:	f1 f4       	brne	.+60     	; 0x812 <skenuj_alarm+0xe4>
    if (((alarm.al_hod == udaje.hod) && (alarm.al_min == udaje.min) && (alarm.al_sek == udaje.sek)) && (alarm.al_temp == udaje.teplota)) {
     7d6:	90 91 20 04 	lds	r25, 0x0420
     7da:	80 91 36 04 	lds	r24, 0x0436
     7de:	98 17       	cp	r25, r24
     7e0:	c1 f4       	brne	.+48     	; 0x812 <skenuj_alarm+0xe4>
     7e2:	90 91 21 04 	lds	r25, 0x0421
     7e6:	80 91 35 04 	lds	r24, 0x0435
     7ea:	98 17       	cp	r25, r24
     7ec:	91 f4       	brne	.+36     	; 0x812 <skenuj_alarm+0xe4>
     7ee:	90 91 22 04 	lds	r25, 0x0422
     7f2:	80 91 34 04 	lds	r24, 0x0434
     7f6:	98 17       	cp	r25, r24
     7f8:	61 f4       	brne	.+24     	; 0x812 <skenuj_alarm+0xe4>
     7fa:	90 91 23 04 	lds	r25, 0x0423
     7fe:	80 91 33 04 	lds	r24, 0x0433
     802:	98 17       	cp	r25, r24
     804:	31 f4       	brne	.+12     	; 0x812 <skenuj_alarm+0xe4>
	  PORTC |= 8;
     806:	43 9a       	sbi	0x08, 3	; 8
	  al_res.pipa = 1;
     808:	80 91 2a 04 	lds	r24, 0x042A
     80c:	81 60       	ori	r24, 0x01	; 1
     80e:	80 93 2a 04 	sts	0x042A, r24
     812:	08 95       	ret

00000814 <citaj_hodn>:
	}
  }
}
//----------------------------------------------------------------------
void citaj_hodn(void)
{
     814:	df 92       	push	r13
     816:	ef 92       	push	r14
     818:	ff 92       	push	r15
     81a:	0f 93       	push	r16
     81c:	1f 93       	push	r17
     81e:	cf 93       	push	r28
     820:	df 93       	push	r29
  if ((stav & 1) != 1) {
     822:	80 91 f8 03 	lds	r24, 0x03F8
     826:	80 fd       	sbrc	r24, 0
     828:	2b c0       	rjmp	.+86     	; 0x880 <citaj_hodn+0x6c>
#include <util/delay.h>

char one_reset(void)
{
  char r;
  asm("cli");
     82a:	f8 94       	cli
  DDR |= DQ;
     82c:	57 9a       	sbi	0x0a, 7	; 10
  PORT &= ~DQ;
     82e:	5f 98       	cbi	0x0b, 7	; 11
     830:	88 ee       	ldi	r24, 0xE8	; 232
     832:	93 e0       	ldi	r25, 0x03	; 3
     834:	01 97       	sbiw	r24, 0x01	; 1
     836:	f1 f7       	brne	.-4      	; 0x834 <citaj_hodn+0x20>
  _delay_us(500);
  DDR &= ~DQ;
     838:	57 98       	cbi	0x0a, 7	; 10
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
     83a:	8a e6       	ldi	r24, 0x6A	; 106
     83c:	8a 95       	dec	r24
     83e:	f1 f7       	brne	.-4      	; 0x83c <citaj_hodn+0x28>
  _delay_us(40);
  r = (DDR & DQ) ? 0 : 1;
     840:	8a b1       	in	r24, 0x0a	; 10
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     842:	80 ee       	ldi	r24, 0xE0	; 224
     844:	91 e0       	ldi	r25, 0x01	; 1
     846:	01 97       	sbiw	r24, 0x01	; 1
     848:	f1 f7       	brne	.-4      	; 0x846 <citaj_hodn+0x32>
  _delay_us(240);
  asm("sei");
     84a:	78 94       	sei
    one_reset();
    send_convert();
     84c:	0e 94 a0 00 	call	0x140	; 0x140 <send_convert>
     850:	c0 e0       	ldi	r28, 0x00	; 0
     852:	d0 e0       	ldi	r29, 0x00	; 0
    for (unsigned char i = 0; i < 7; i++)		//nacitam vsetky udaje do struktury - v priebehu cakania
      p_udaje[i] = read_ds1307(i);
     854:	00 91 6d 02 	lds	r16, 0x026D
     858:	10 91 6e 02 	lds	r17, 0x026E
     85c:	0c 0f       	add	r16, r28
     85e:	1d 1f       	adc	r17, r29
     860:	8c 2f       	mov	r24, r28
     862:	0e 94 45 01 	call	0x28a	; 0x28a <read_ds1307>
     866:	f8 01       	movw	r30, r16
     868:	80 83       	st	Z, r24
     86a:	21 96       	adiw	r28, 0x01	; 1
void citaj_hodn(void)
{
  if ((stav & 1) != 1) {
    one_reset();
    send_convert();
    for (unsigned char i = 0; i < 7; i++)		//nacitam vsetky udaje do struktury - v priebehu cakania
     86c:	c7 30       	cpi	r28, 0x07	; 7
     86e:	d1 05       	cpc	r29, r1
     870:	89 f7       	brne	.-30     	; 0x854 <citaj_hodn+0x40>
      p_udaje[i] = read_ds1307(i);
    zisti_den();								//zistim den v tyzdni - v priebehu cakania (konvertovanie)
     872:	0e 94 c2 02 	call	0x584	; 0x584 <zisti_den>
	stav |= 1;						// nastavim stav na 1 pre dokoncenie 1. casti
     876:	80 91 f8 03 	lds	r24, 0x03F8
     87a:	81 60       	ori	r24, 0x01	; 1
     87c:	80 93 f8 03 	sts	0x03F8, r24
  }
  if (((stav & 1) == 1) && ((timer_ref % 50) == 0)) {
     880:	80 91 f8 03 	lds	r24, 0x03F8
     884:	80 ff       	sbrs	r24, 0
     886:	46 c0       	rjmp	.+140    	; 0x914 <citaj_hodn+0x100>
     888:	80 91 f5 03 	lds	r24, 0x03F5
     88c:	62 e3       	ldi	r22, 0x32	; 50
     88e:	0e 94 99 13 	call	0x2732	; 0x2732 <__udivmodqi4>
     892:	99 23       	and	r25, r25
     894:	09 f0       	breq	.+2      	; 0x898 <citaj_hodn+0x84>
     896:	3e c0       	rjmp	.+124    	; 0x914 <citaj_hodn+0x100>
#include <util/delay.h>

char one_reset(void)
{
  char r;
  asm("cli");
     898:	f8 94       	cli
  DDR |= DQ;
     89a:	57 9a       	sbi	0x0a, 7	; 10
  PORT &= ~DQ;
     89c:	5f 98       	cbi	0x0b, 7	; 11
     89e:	78 ee       	ldi	r23, 0xE8	; 232
     8a0:	e7 2e       	mov	r14, r23
     8a2:	73 e0       	ldi	r23, 0x03	; 3
     8a4:	f7 2e       	mov	r15, r23
     8a6:	c7 01       	movw	r24, r14
     8a8:	01 97       	sbiw	r24, 0x01	; 1
     8aa:	f1 f7       	brne	.-4      	; 0x8a8 <citaj_hodn+0x94>
  _delay_us(500);
  DDR &= ~DQ;
     8ac:	57 98       	cbi	0x0a, 7	; 10
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
     8ae:	6a e6       	ldi	r22, 0x6A	; 106
     8b0:	d6 2e       	mov	r13, r22
     8b2:	8d 2d       	mov	r24, r13
     8b4:	8a 95       	dec	r24
     8b6:	f1 f7       	brne	.-4      	; 0x8b4 <citaj_hodn+0xa0>
  _delay_us(40);
  r = (DDR & DQ) ? 0 : 1;
     8b8:	8a b1       	in	r24, 0x0a	; 10
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     8ba:	00 ee       	ldi	r16, 0xE0	; 224
     8bc:	11 e0       	ldi	r17, 0x01	; 1
     8be:	c8 01       	movw	r24, r16
     8c0:	01 97       	sbiw	r24, 0x01	; 1
     8c2:	f1 f7       	brne	.-4      	; 0x8c0 <citaj_hodn+0xac>
  _delay_us(240);
  asm("sei");
     8c4:	78 94       	sei
    one_reset();
    send_getTemp();
     8c6:	0e 94 a7 00 	call	0x14e	; 0x14e <send_getTemp>
    udaje.teplota = one_read_byte();
     8ca:	0e 94 69 00 	call	0xd2	; 0xd2 <one_read_byte>
     8ce:	80 93 33 04 	sts	0x0433, r24
	err1 = 1;
     8d2:	81 e0       	ldi	r24, 0x01	; 1
     8d4:	80 93 fb 03 	sts	0x03FB, r24
    udaje.temp_flag = one_read_byte();			/// DOKONCIT NASTAV5, Fcia PRE DNI ALARMU
     8d8:	0e 94 69 00 	call	0xd2	; 0xd2 <one_read_byte>
     8dc:	80 93 3b 04 	sts	0x043B, r24
#include <util/delay.h>

char one_reset(void)
{
  char r;
  asm("cli");
     8e0:	f8 94       	cli
  DDR |= DQ;
     8e2:	57 9a       	sbi	0x0a, 7	; 10
  PORT &= ~DQ;
     8e4:	5f 98       	cbi	0x0b, 7	; 11
     8e6:	c7 01       	movw	r24, r14
     8e8:	01 97       	sbiw	r24, 0x01	; 1
     8ea:	f1 f7       	brne	.-4      	; 0x8e8 <citaj_hodn+0xd4>
  _delay_us(500);
  DDR &= ~DQ;
     8ec:	57 98       	cbi	0x0a, 7	; 10
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
     8ee:	da 94       	dec	r13
     8f0:	f1 f7       	brne	.-4      	; 0x8ee <citaj_hodn+0xda>
  _delay_us(40);
  r = (DDR & DQ) ? 0 : 1;
     8f2:	8a b1       	in	r24, 0x0a	; 10
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     8f4:	c8 01       	movw	r24, r16
     8f6:	01 97       	sbiw	r24, 0x01	; 1
     8f8:	f1 f7       	brne	.-4      	; 0x8f6 <citaj_hodn+0xe2>
  _delay_us(240);
  asm("sei");
     8fa:	78 94       	sei
    one_reset();
    //if ((udaje.temp_flag = 0))
    udaje.teplota >>= 1;
     8fc:	80 91 33 04 	lds	r24, 0x0433
     900:	86 95       	lsr	r24
     902:	80 93 33 04 	sts	0x0433, r24
	err1 = 0;
     906:	10 92 fb 03 	sts	0x03FB, r1
    //else 
      //udaje.teplota = -(((~udaje.teplota)/2)+1);
    stav &= ~1;
     90a:	80 91 f8 03 	lds	r24, 0x03F8
     90e:	8e 7f       	andi	r24, 0xFE	; 254
     910:	80 93 f8 03 	sts	0x03F8, r24
  }
}
     914:	df 91       	pop	r29
     916:	cf 91       	pop	r28
     918:	1f 91       	pop	r17
     91a:	0f 91       	pop	r16
     91c:	ff 90       	pop	r15
     91e:	ef 90       	pop	r14
     920:	df 90       	pop	r13
     922:	08 95       	ret

00000924 <__vector_16>:
char *tst_com(void);
//void vykonaj(void);

//----------------------------------------------------------------------
ISR(TIMER0_OVF_vect) 		// Prerusenie kazdych 8,16ms
{
     924:	1f 92       	push	r1
     926:	0f 92       	push	r0
     928:	0f b6       	in	r0, 0x3f	; 63
     92a:	0f 92       	push	r0
     92c:	11 24       	eor	r1, r1
     92e:	2f 93       	push	r18
     930:	3f 93       	push	r19
     932:	4f 93       	push	r20
     934:	5f 93       	push	r21
     936:	6f 93       	push	r22
     938:	7f 93       	push	r23
     93a:	8f 93       	push	r24
     93c:	9f 93       	push	r25
     93e:	af 93       	push	r26
     940:	bf 93       	push	r27
     942:	ef 93       	push	r30
     944:	ff 93       	push	r31
  TIMSK0 = 0;
     946:	10 92 6e 00 	sts	0x006E, r1

  timer_ref++;
     94a:	80 91 f5 03 	lds	r24, 0x03F5
     94e:	8f 5f       	subi	r24, 0xFF	; 255
     950:	80 93 f5 03 	sts	0x03F5, r24
  if ((udaje.mon_temp) == 1 && ((stav & 2) != 2))  // skenuj monitorovanu teplotu
     954:	80 91 3c 04 	lds	r24, 0x043C
     958:	81 30       	cpi	r24, 0x01	; 1
     95a:	31 f4       	brne	.+12     	; 0x968 <__vector_16+0x44>
     95c:	80 91 f8 03 	lds	r24, 0x03F8
     960:	81 fd       	sbrc	r24, 1
     962:	02 c0       	rjmp	.+4      	; 0x968 <__vector_16+0x44>
    skenuj_tep(); 
     964:	0e 94 34 03 	call	0x668	; 0x668 <skenuj_tep>
  if ((alarm.al_flag == 1) && ((stav & 2) != 2)) {	// skenuj alarm - nesnimaj pocas nastavovania
     968:	80 91 26 04 	lds	r24, 0x0426
     96c:	81 30       	cpi	r24, 0x01	; 1
     96e:	31 f4       	brne	.+12     	; 0x97c <__vector_16+0x58>
     970:	80 91 f8 03 	lds	r24, 0x03F8
     974:	81 fd       	sbrc	r24, 1
     976:	02 c0       	rjmp	.+4      	; 0x97c <__vector_16+0x58>
    skenuj_alarm();
     978:	0e 94 97 03 	call	0x72e	; 0x72e <skenuj_alarm>
  }	
  citaj_hodn();
     97c:	0e 94 0a 04 	call	0x814	; 0x814 <citaj_hodn>
  if ((timer_ref % 32) == 0) {
     980:	80 91 f5 03 	lds	r24, 0x03F5
     984:	90 e0       	ldi	r25, 0x00	; 0
     986:	8f 71       	andi	r24, 0x1F	; 31
     988:	90 70       	andi	r25, 0x00	; 0
     98a:	89 2b       	or	r24, r25
     98c:	31 f5       	brne	.+76     	; 0x9da <__vector_16+0xb6>
    if (cursor == 0)
     98e:	80 91 29 04 	lds	r24, 0x0429
     992:	88 23       	and	r24, r24
     994:	11 f4       	brne	.+4      	; 0x99a <__vector_16+0x76>
	  LCDcursorOFF();
     996:	0e 94 5f 02 	call	0x4be	; 0x4be <LCDcursorOFF>
	if (al_res.pipa == 1) {
     99a:	80 91 2a 04 	lds	r24, 0x042A
     99e:	80 ff       	sbrs	r24, 0
     9a0:	19 c0       	rjmp	.+50     	; 0x9d4 <__vector_16+0xb0>
	  if (bit_is_set(PINC, 5)) {
     9a2:	35 9b       	sbis	0x06, 5	; 6
     9a4:	04 c0       	rjmp	.+8      	; 0x9ae <__vector_16+0x8a>
	    PORTC &= ~8;
     9a6:	43 98       	cbi	0x08, 3	; 8
		al_res.pipa = 0;
     9a8:	8e 7f       	andi	r24, 0xFE	; 254
     9aa:	80 93 2a 04 	sts	0x042A, r24
	  }
	  if (++al_res.ref == 32) {
     9ae:	80 91 2a 04 	lds	r24, 0x042A
     9b2:	98 2f       	mov	r25, r24
     9b4:	96 95       	lsr	r25
     9b6:	96 95       	lsr	r25
     9b8:	9f 5f       	subi	r25, 0xFF	; 255
     9ba:	9f 73       	andi	r25, 0x3F	; 63
     9bc:	29 2f       	mov	r18, r25
     9be:	22 0f       	add	r18, r18
     9c0:	22 0f       	add	r18, r18
     9c2:	83 70       	andi	r24, 0x03	; 3
     9c4:	82 2b       	or	r24, r18
     9c6:	80 93 2a 04 	sts	0x042A, r24
     9ca:	90 32       	cpi	r25, 0x20	; 32
     9cc:	31 f4       	brne	.+12     	; 0x9da <__vector_16+0xb6>
	    PORTC &= ~8;
     9ce:	43 98       	cbi	0x08, 3	; 8
		al_res.pipa = 0;
     9d0:	8e 7f       	andi	r24, 0xFE	; 254
     9d2:	01 c0       	rjmp	.+2      	; 0x9d6 <__vector_16+0xb2>
	  }
	} else al_res.ref = 0;
     9d4:	83 70       	andi	r24, 0x03	; 3
     9d6:	80 93 2a 04 	sts	0x042A, r24
  }
  /* --- SAS PRACOVNHO REMU, frekvencia vstupu --- */
  if (prac_stav == 1) {
     9da:	80 91 f4 03 	lds	r24, 0x03F4
     9de:	81 30       	cpi	r24, 0x01	; 1
     9e0:	b9 f4       	brne	.+46     	; 0xa10 <__vector_16+0xec>
  /* SPECIFICK KRITRIA PRE DAN LOHU */
    alarm.al_flag = 0;
     9e2:	10 92 26 04 	sts	0x0426, r1
	alarm.clock = 0;
     9e6:	10 92 25 04 	sts	0x0425, r1
	alarm.temp = 0;
     9ea:	10 92 24 04 	sts	0x0424, r1

  /*------- KONIEC --------*/
  }
  if ((prac_stav == 1) && (freq_nastavena != 0)) {
     9ee:	80 91 f3 03 	lds	r24, 0x03F3
     9f2:	88 23       	and	r24, r24
     9f4:	69 f0       	breq	.+26     	; 0xa10 <__vector_16+0xec>
    if (freq == 1)
     9f6:	80 91 f2 03 	lds	r24, 0x03F2
     9fa:	81 30       	cpi	r24, 0x01	; 1
     9fc:	11 f4       	brne	.+4      	; 0xa02 <__vector_16+0xde>
	  PORTC |= 8;
     9fe:	43 9a       	sbi	0x08, 3	; 8
     a00:	08 c0       	rjmp	.+16     	; 0xa12 <__vector_16+0xee>
	if (freq == 2)
     a02:	82 30       	cpi	r24, 0x02	; 2
     a04:	31 f4       	brne	.+12     	; 0xa12 <__vector_16+0xee>
	  PORTC ^= 8;
     a06:	88 b1       	in	r24, 0x08	; 8
     a08:	98 e0       	ldi	r25, 0x08	; 8
     a0a:	89 27       	eor	r24, r25
     a0c:	88 b9       	out	0x08, r24	; 8
     a0e:	01 c0       	rjmp	.+2      	; 0xa12 <__vector_16+0xee>
  } else PORTC &= ~8;
     a10:	43 98       	cbi	0x08, 3	; 8
  /*------- KONIEC --------*/
  TIMSK0 = 1;
     a12:	81 e0       	ldi	r24, 0x01	; 1
     a14:	80 93 6e 00 	sts	0x006E, r24
}
     a18:	ff 91       	pop	r31
     a1a:	ef 91       	pop	r30
     a1c:	bf 91       	pop	r27
     a1e:	af 91       	pop	r26
     a20:	9f 91       	pop	r25
     a22:	8f 91       	pop	r24
     a24:	7f 91       	pop	r23
     a26:	6f 91       	pop	r22
     a28:	5f 91       	pop	r21
     a2a:	4f 91       	pop	r20
     a2c:	3f 91       	pop	r19
     a2e:	2f 91       	pop	r18
     a30:	0f 90       	pop	r0
     a32:	0f be       	out	0x3f, r0	; 63
     a34:	0f 90       	pop	r0
     a36:	1f 90       	pop	r1
     a38:	18 95       	reti

00000a3a <delete_eeprom>:
    stav &= ~1;
  }
}
//----------------------------------------------------------------------
void delete_eeprom(void)
{
     a3a:	80 e0       	ldi	r24, 0x00	; 0
     a3c:	90 e0       	ldi	r25, 0x00	; 0
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
     a3e:	24 e0       	ldi	r18, 0x04	; 4
     a40:	30 e0       	ldi	r19, 0x00	; 0
#endif
    EEDR = __value;
     a42:	4f ef       	ldi	r20, 0xFF	; 255
  int e;

  for (e = 0; e < 8; e++) {
    if (e != 4) {
     a44:	84 30       	cpi	r24, 0x04	; 4
     a46:	91 05       	cpc	r25, r1
     a48:	49 f0       	breq	.+18     	; 0xa5c <delete_eeprom+0x22>
	  EEPROM_CAKAJ;
     a4a:	f9 99       	sbic	0x1f, 1	; 31
     a4c:	fe cf       	rjmp	.-4      	; 0xa4a <delete_eeprom+0x10>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
     a4e:	f9 99       	sbic	0x1f, 1	; 31
     a50:	fe cf       	rjmp	.-4      	; 0xa4e <delete_eeprom+0x14>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
     a52:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
     a54:	92 bd       	out	0x22, r25	; 34
     a56:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
     a58:	40 bd       	out	0x20, r20	; 32
     a5a:	08 c0       	rjmp	.+16     	; 0xa6c <delete_eeprom+0x32>
	  eeprom_write_byte(e,255);
	}
	else {
	  EEPROM_CAKAJ;
     a5c:	f9 99       	sbic	0x1f, 1	; 31
     a5e:	fe cf       	rjmp	.-4      	; 0xa5c <delete_eeprom+0x22>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
     a60:	f9 99       	sbic	0x1f, 1	; 31
     a62:	fe cf       	rjmp	.-4      	; 0xa60 <delete_eeprom+0x26>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
     a64:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
     a66:	32 bd       	out	0x22, r19	; 34
     a68:	21 bd       	out	0x21, r18	; 33
#endif
    EEDR = __value;
     a6a:	10 bc       	out	0x20, r1	; 32

    __asm__ __volatile__ (
     a6c:	0f b6       	in	r0, 0x3f	; 63
     a6e:	f8 94       	cli
     a70:	fa 9a       	sbi	0x1f, 2	; 31
     a72:	f9 9a       	sbi	0x1f, 1	; 31
     a74:	0f be       	out	0x3f, r0	; 63
//----------------------------------------------------------------------
void delete_eeprom(void)
{
  int e;

  for (e = 0; e < 8; e++) {
     a76:	01 96       	adiw	r24, 0x01	; 1
     a78:	88 30       	cpi	r24, 0x08	; 8
     a7a:	91 05       	cpc	r25, r1
     a7c:	19 f7       	brne	.-58     	; 0xa44 <delete_eeprom+0xa>
	  EEPROM_CAKAJ;
	  eeprom_write_byte(4,0);
	}
  }

}
     a7e:	08 95       	ret

00000a80 <__vector_18>:
  
  TIMSK2 = 1;
}
//----------------------------------------------------------------------
ISR(USART_RX_vect)
{
     a80:	1f 92       	push	r1
     a82:	0f 92       	push	r0
     a84:	0f b6       	in	r0, 0x3f	; 63
     a86:	0f 92       	push	r0
     a88:	11 24       	eor	r1, r1
     a8a:	2f 93       	push	r18
     a8c:	3f 93       	push	r19
     a8e:	4f 93       	push	r20
     a90:	5f 93       	push	r21
     a92:	6f 93       	push	r22
     a94:	7f 93       	push	r23
     a96:	8f 93       	push	r24
     a98:	9f 93       	push	r25
     a9a:	af 93       	push	r26
     a9c:	bf 93       	push	r27
     a9e:	ef 93       	push	r30
     aa0:	ff 93       	push	r31
  char byte, i, j, check;
  
  UCSR0B &= ~0x80;
     aa2:	80 91 c1 00 	lds	r24, 0x00C1
     aa6:	8f 77       	andi	r24, 0x7F	; 127
     aa8:	80 93 c1 00 	sts	0x00C1, r24
  TIMSK0 = 0;
     aac:	10 92 6e 00 	sts	0x006E, r1
  byte = UDR0; 
     ab0:	90 91 c6 00 	lds	r25, 0x00C6


//		OBSLUHA PRE PROGRAM
  if (byte == 104)			//otazka 104
     ab4:	98 36       	cpi	r25, 0x68	; 104
     ab6:	41 f4       	brne	.+16     	; 0xac8 <__vector_18+0x48>
  }
}
//----------------------------------------------------------------------
void USART_Transmit(char ch)
{
   while (!(UCSR0A & (1<<UDRE0)));
     ab8:	80 91 c0 00 	lds	r24, 0x00C0
     abc:	85 ff       	sbrs	r24, 5
     abe:	fc cf       	rjmp	.-8      	; 0xab8 <__vector_18+0x38>
   UDR0=ch;
     ac0:	84 e6       	ldi	r24, 0x64	; 100
     ac2:	80 93 c6 00 	sts	0x00C6, r24
     ac6:	e2 c0       	rjmp	.+452    	; 0xc8c <__vector_18+0x20c>
    USART_Transmit(100);	//odpoved 100
  if (byte == 90)			//poziadavka cas 115
     ac8:	9a 35       	cpi	r25, 0x5A	; 90
     aca:	21 f4       	brne	.+8      	; 0xad4 <__vector_18+0x54>
    com.PC = 1;
     acc:	80 91 1f 04 	lds	r24, 0x041F
     ad0:	81 60       	ori	r24, 0x01	; 1
     ad2:	05 c0       	rjmp	.+10     	; 0xade <__vector_18+0x5e>
  if (byte == 106)
     ad4:	9a 36       	cpi	r25, 0x6A	; 106
     ad6:	31 f4       	brne	.+12     	; 0xae4 <__vector_18+0x64>
    com.PC = 0;
     ad8:	80 91 1f 04 	lds	r24, 0x041F
     adc:	8e 7f       	andi	r24, 0xFE	; 254
     ade:	80 93 1f 04 	sts	0x041F, r24
     ae2:	87 c1       	rjmp	.+782    	; 0xdf2 <__vector_18+0x372>
  if (byte == 115) {
     ae4:	93 37       	cpi	r25, 0x73	; 115
     ae6:	09 f0       	breq	.+2      	; 0xaea <__vector_18+0x6a>
     ae8:	d1 c0       	rjmp	.+418    	; 0xc8c <__vector_18+0x20c>
    for (i = 0; i < 9; i++) {
	  USART_Transmit(p_udaje[i]);
     aea:	40 91 6d 02 	lds	r20, 0x026D
     aee:	50 91 6e 02 	lds	r21, 0x026E
     af2:	20 e0       	ldi	r18, 0x00	; 0
     af4:	30 e0       	ldi	r19, 0x00	; 0
     af6:	fa 01       	movw	r30, r20
     af8:	e2 0f       	add	r30, r18
     afa:	f3 1f       	adc	r31, r19
     afc:	e0 81       	ld	r30, Z
  }
}
//----------------------------------------------------------------------
void USART_Transmit(char ch)
{
   while (!(UCSR0A & (1<<UDRE0)));
     afe:	80 91 c0 00 	lds	r24, 0x00C0
     b02:	85 ff       	sbrs	r24, 5
     b04:	fc cf       	rjmp	.-8      	; 0xafe <__vector_18+0x7e>
   UDR0=ch;
     b06:	e0 93 c6 00 	sts	0x00C6, r30
     b0a:	2f 5f       	subi	r18, 0xFF	; 255
     b0c:	3f 4f       	sbci	r19, 0xFF	; 255
  if (byte == 90)			//poziadavka cas 115
    com.PC = 1;
  if (byte == 106)
    com.PC = 0;
  if (byte == 115) {
    for (i = 0; i < 9; i++) {
     b0e:	29 30       	cpi	r18, 0x09	; 9
     b10:	31 05       	cpc	r19, r1
     b12:	89 f7       	brne	.-30     	; 0xaf6 <__vector_18+0x76>
	  USART_Transmit(p_udaje[i]);
	}
    for (i = 0; i < 8; i++) {
	  USART_Transmit(p_mon[i]);
     b14:	40 91 69 02 	lds	r20, 0x0269
     b18:	50 91 6a 02 	lds	r21, 0x026A
     b1c:	20 e0       	ldi	r18, 0x00	; 0
     b1e:	30 e0       	ldi	r19, 0x00	; 0
     b20:	fa 01       	movw	r30, r20
     b22:	e2 0f       	add	r30, r18
     b24:	f3 1f       	adc	r31, r19
     b26:	e0 81       	ld	r30, Z
  }
}
//----------------------------------------------------------------------
void USART_Transmit(char ch)
{
   while (!(UCSR0A & (1<<UDRE0)));
     b28:	80 91 c0 00 	lds	r24, 0x00C0
     b2c:	85 ff       	sbrs	r24, 5
     b2e:	fc cf       	rjmp	.-8      	; 0xb28 <__vector_18+0xa8>
   UDR0=ch;
     b30:	e0 93 c6 00 	sts	0x00C6, r30
     b34:	2f 5f       	subi	r18, 0xFF	; 255
     b36:	3f 4f       	sbci	r19, 0xFF	; 255
    com.PC = 0;
  if (byte == 115) {
    for (i = 0; i < 9; i++) {
	  USART_Transmit(p_udaje[i]);
	}
    for (i = 0; i < 8; i++) {
     b38:	28 30       	cpi	r18, 0x08	; 8
     b3a:	31 05       	cpc	r19, r1
     b3c:	89 f7       	brne	.-30     	; 0xb20 <__vector_18+0xa0>
	  USART_Transmit(p_mon[i]);
	}
    for (i = 0; i < 8; i++) {
	  USART_Transmit(p_alarm[i]);
     b3e:	40 91 6b 02 	lds	r20, 0x026B
     b42:	50 91 6c 02 	lds	r21, 0x026C
     b46:	20 e0       	ldi	r18, 0x00	; 0
     b48:	30 e0       	ldi	r19, 0x00	; 0
     b4a:	fa 01       	movw	r30, r20
     b4c:	e2 0f       	add	r30, r18
     b4e:	f3 1f       	adc	r31, r19
     b50:	e0 81       	ld	r30, Z
  }
}
//----------------------------------------------------------------------
void USART_Transmit(char ch)
{
   while (!(UCSR0A & (1<<UDRE0)));
     b52:	80 91 c0 00 	lds	r24, 0x00C0
     b56:	85 ff       	sbrs	r24, 5
     b58:	fc cf       	rjmp	.-8      	; 0xb52 <__vector_18+0xd2>
   UDR0=ch;
     b5a:	e0 93 c6 00 	sts	0x00C6, r30
     b5e:	2f 5f       	subi	r18, 0xFF	; 255
     b60:	3f 4f       	sbci	r19, 0xFF	; 255
	  USART_Transmit(p_udaje[i]);
	}
    for (i = 0; i < 8; i++) {
	  USART_Transmit(p_mon[i]);
	}
    for (i = 0; i < 8; i++) {
     b62:	28 30       	cpi	r18, 0x08	; 8
     b64:	31 05       	cpc	r19, r1
     b66:	89 f7       	brne	.-30     	; 0xb4a <__vector_18+0xca>
	  USART_Transmit(p_alarm[i]);
	}
	USART_Transmit((al_res.pipa | al_res.pipalo | al_res.ref));
     b68:	80 91 2a 04 	lds	r24, 0x042A
     b6c:	38 2f       	mov	r19, r24
     b6e:	31 70       	andi	r19, 0x01	; 1
     b70:	98 2f       	mov	r25, r24
     b72:	96 95       	lsr	r25
     b74:	91 70       	andi	r25, 0x01	; 1
     b76:	28 2f       	mov	r18, r24
     b78:	26 95       	lsr	r18
     b7a:	26 95       	lsr	r18
  }
}
//----------------------------------------------------------------------
void USART_Transmit(char ch)
{
   while (!(UCSR0A & (1<<UDRE0)));
     b7c:	80 91 c0 00 	lds	r24, 0x00C0
     b80:	85 ff       	sbrs	r24, 5
     b82:	fc cf       	rjmp	.-8      	; 0xb7c <__vector_18+0xfc>
     b84:	93 2b       	or	r25, r19
     b86:	92 2b       	or	r25, r18
   UDR0=ch;
     b88:	90 93 c6 00 	sts	0x00C6, r25
	USART_Transmit(timer_ref);
     b8c:	90 91 f5 03 	lds	r25, 0x03F5
  }
}
//----------------------------------------------------------------------
void USART_Transmit(char ch)
{
   while (!(UCSR0A & (1<<UDRE0)));
     b90:	80 91 c0 00 	lds	r24, 0x00C0
     b94:	85 ff       	sbrs	r24, 5
     b96:	fc cf       	rjmp	.-8      	; 0xb90 <__vector_18+0x110>
   UDR0=ch;
     b98:	90 93 c6 00 	sts	0x00C6, r25
	USART_Transmit(stav);
     b9c:	90 91 f8 03 	lds	r25, 0x03F8
  }
}
//----------------------------------------------------------------------
void USART_Transmit(char ch)
{
   while (!(UCSR0A & (1<<UDRE0)));
     ba0:	80 91 c0 00 	lds	r24, 0x00C0
     ba4:	85 ff       	sbrs	r24, 5
     ba6:	fc cf       	rjmp	.-8      	; 0xba0 <__vector_18+0x120>
   UDR0=ch;
     ba8:	90 93 c6 00 	sts	0x00C6, r25
	USART_Transmit(cursor);
     bac:	90 91 29 04 	lds	r25, 0x0429
  }
}
//----------------------------------------------------------------------
void USART_Transmit(char ch)
{
   while (!(UCSR0A & (1<<UDRE0)));
     bb0:	80 91 c0 00 	lds	r24, 0x00C0
     bb4:	85 ff       	sbrs	r24, 5
     bb6:	fc cf       	rjmp	.-8      	; 0xbb0 <__vector_18+0x130>
   UDR0=ch;
     bb8:	90 93 c6 00 	sts	0x00C6, r25
     bbc:	4c e0       	ldi	r20, 0x0C	; 12
     bbe:	54 e0       	ldi	r21, 0x04	; 4
     bc0:	20 e0       	ldi	r18, 0x00	; 0
     bc2:	30 e0       	ldi	r19, 0x00	; 0
     bc4:	13 c0       	rjmp	.+38     	; 0xbec <__vector_18+0x16c>
	for (i = 0; i < 2; i++) {
	  for (j = 0; j < 16; j++) {
	    USART_Transmit(lcd_dis[i][j]);
     bc6:	90 81       	ld	r25, Z
  }
}
//----------------------------------------------------------------------
void USART_Transmit(char ch)
{
   while (!(UCSR0A & (1<<UDRE0)));
     bc8:	80 91 c0 00 	lds	r24, 0x00C0
     bcc:	85 ff       	sbrs	r24, 5
     bce:	fc cf       	rjmp	.-8      	; 0xbc8 <__vector_18+0x148>
   UDR0=ch;
     bd0:	90 93 c6 00 	sts	0x00C6, r25
     bd4:	31 96       	adiw	r30, 0x01	; 1
	USART_Transmit((al_res.pipa | al_res.pipalo | al_res.ref));
	USART_Transmit(timer_ref);
	USART_Transmit(stav);
	USART_Transmit(cursor);
	for (i = 0; i < 2; i++) {
	  for (j = 0; j < 16; j++) {
     bd6:	e4 17       	cp	r30, r20
     bd8:	f5 07       	cpc	r31, r21
     bda:	a9 f7       	brne	.-22     	; 0xbc6 <__vector_18+0x146>
     bdc:	2f 5f       	subi	r18, 0xFF	; 255
     bde:	3f 4f       	sbci	r19, 0xFF	; 255
     be0:	af 01       	movw	r20, r30
     be2:	4f 5e       	subi	r20, 0xEF	; 239
     be4:	5f 4f       	sbci	r21, 0xFF	; 255
	}
	USART_Transmit((al_res.pipa | al_res.pipalo | al_res.ref));
	USART_Transmit(timer_ref);
	USART_Transmit(stav);
	USART_Transmit(cursor);
	for (i = 0; i < 2; i++) {
     be6:	22 30       	cpi	r18, 0x02	; 2
     be8:	31 05       	cpc	r19, r1
     bea:	59 f0       	breq	.+22     	; 0xc02 <__vector_18+0x182>
     bec:	f9 01       	movw	r30, r18
     bee:	a4 e0       	ldi	r26, 0x04	; 4
     bf0:	ee 0f       	add	r30, r30
     bf2:	ff 1f       	adc	r31, r31
     bf4:	aa 95       	dec	r26
     bf6:	e1 f7       	brne	.-8      	; 0xbf0 <__vector_18+0x170>
     bf8:	e2 0f       	add	r30, r18
     bfa:	f3 1f       	adc	r31, r19
     bfc:	e4 50       	subi	r30, 0x04	; 4
     bfe:	fc 4f       	sbci	r31, 0xFC	; 252
     c00:	e2 cf       	rjmp	.-60     	; 0xbc6 <__vector_18+0x146>
	  for (j = 0; j < 16; j++) {
	    USART_Transmit(lcd_dis[i][j]);
	  }
	} 
	USART_Transmit(udaje.teplota);
     c02:	90 91 33 04 	lds	r25, 0x0433
  }
}
//----------------------------------------------------------------------
void USART_Transmit(char ch)
{
   while (!(UCSR0A & (1<<UDRE0)));
     c06:	80 91 c0 00 	lds	r24, 0x00C0
     c0a:	85 ff       	sbrs	r24, 5
     c0c:	fc cf       	rjmp	.-8      	; 0xc06 <__vector_18+0x186>
   UDR0=ch;
     c0e:	90 93 c6 00 	sts	0x00C6, r25
	USART_Transmit(timer2_ref);
     c12:	90 91 f6 03 	lds	r25, 0x03F6
  }
}
//----------------------------------------------------------------------
void USART_Transmit(char ch)
{
   while (!(UCSR0A & (1<<UDRE0)));
     c16:	80 91 c0 00 	lds	r24, 0x00C0
     c1a:	85 ff       	sbrs	r24, 5
     c1c:	fc cf       	rjmp	.-8      	; 0xc16 <__vector_18+0x196>
   UDR0=ch;
     c1e:	90 93 c6 00 	sts	0x00C6, r25
	USART_Transmit(PORTD);
     c22:	9b b1       	in	r25, 0x0b	; 11
  }
}
//----------------------------------------------------------------------
void USART_Transmit(char ch)
{
   while (!(UCSR0A & (1<<UDRE0)));
     c24:	80 91 c0 00 	lds	r24, 0x00C0
     c28:	85 ff       	sbrs	r24, 5
     c2a:	fc cf       	rjmp	.-8      	; 0xc24 <__vector_18+0x1a4>
   UDR0=ch;
     c2c:	90 93 c6 00 	sts	0x00C6, r25
     c30:	20 e0       	ldi	r18, 0x00	; 0
     c32:	30 e0       	ldi	r19, 0x00	; 0
	for (i = 0; i < 8; i++) {
      EEPROM_CAKAJ;
     c34:	f9 99       	sbic	0x1f, 1	; 31
     c36:	fe cf       	rjmp	.-4      	; 0xc34 <__vector_18+0x1b4>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
     c38:	f9 99       	sbic	0x1f, 1	; 31
     c3a:	fe cf       	rjmp	.-4      	; 0xc38 <__vector_18+0x1b8>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
     c3c:	32 bd       	out	0x22, r19	; 34
     c3e:	21 bd       	out	0x21, r18	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
     c40:	f8 9a       	sbi	0x1f, 0	; 31
     c42:	90 b5       	in	r25, 0x20	; 32
  }
}
//----------------------------------------------------------------------
void USART_Transmit(char ch)
{
   while (!(UCSR0A & (1<<UDRE0)));
     c44:	80 91 c0 00 	lds	r24, 0x00C0
     c48:	85 ff       	sbrs	r24, 5
     c4a:	fc cf       	rjmp	.-8      	; 0xc44 <__vector_18+0x1c4>
   UDR0=ch;
     c4c:	90 93 c6 00 	sts	0x00C6, r25
     c50:	2f 5f       	subi	r18, 0xFF	; 255
     c52:	3f 4f       	sbci	r19, 0xFF	; 255
	  }
	} 
	USART_Transmit(udaje.teplota);
	USART_Transmit(timer2_ref);
	USART_Transmit(PORTD);
	for (i = 0; i < 8; i++) {
     c54:	28 30       	cpi	r18, 0x08	; 8
     c56:	31 05       	cpc	r19, r1
     c58:	69 f7       	brne	.-38     	; 0xc34 <__vector_18+0x1b4>
      EEPROM_CAKAJ;
      USART_Transmit(eeprom_read_byte(i));
    }
	USART_Transmit(prac_stav);
     c5a:	90 91 f4 03 	lds	r25, 0x03F4
  }
}
//----------------------------------------------------------------------
void USART_Transmit(char ch)
{
   while (!(UCSR0A & (1<<UDRE0)));
     c5e:	80 91 c0 00 	lds	r24, 0x00C0
     c62:	85 ff       	sbrs	r24, 5
     c64:	fc cf       	rjmp	.-8      	; 0xc5e <__vector_18+0x1de>
   UDR0=ch;
     c66:	90 93 c6 00 	sts	0x00C6, r25
	USART_Transmit(freq);
     c6a:	90 91 f2 03 	lds	r25, 0x03F2
  }
}
//----------------------------------------------------------------------
void USART_Transmit(char ch)
{
   while (!(UCSR0A & (1<<UDRE0)));
     c6e:	80 91 c0 00 	lds	r24, 0x00C0
     c72:	85 ff       	sbrs	r24, 5
     c74:	fc cf       	rjmp	.-8      	; 0xc6e <__vector_18+0x1ee>
   UDR0=ch;
     c76:	90 93 c6 00 	sts	0x00C6, r25
	USART_Transmit(freq_nastavena);
     c7a:	90 91 f3 03 	lds	r25, 0x03F3
  }
}
//----------------------------------------------------------------------
void USART_Transmit(char ch)
{
   while (!(UCSR0A & (1<<UDRE0)));
     c7e:	80 91 c0 00 	lds	r24, 0x00C0
     c82:	85 ff       	sbrs	r24, 5
     c84:	fc cf       	rjmp	.-8      	; 0xc7e <__vector_18+0x1fe>
   UDR0=ch;
     c86:	90 93 c6 00 	sts	0x00C6, r25
     c8a:	b3 c0       	rjmp	.+358    	; 0xdf2 <__vector_18+0x372>
  }
  if (byte == 116) {
     c8c:	94 37       	cpi	r25, 0x74	; 116
     c8e:	69 f5       	brne	.+90     	; 0xcea <__vector_18+0x26a>
     c90:	80 ed       	ldi	r24, 0xD0	; 208
     c92:	97 e0       	ldi	r25, 0x07	; 7
     c94:	01 97       	sbiw	r24, 0x01	; 1
     c96:	f1 f7       	brne	.-4      	; 0xc94 <__vector_18+0x214>
//----------------------------------------------------------------------
char USART_Receive(void)
{
   unsigned char ch;

   while (!(UCSR0A & (1<<RXC0)));
     c98:	80 91 c0 00 	lds	r24, 0x00C0
     c9c:	87 ff       	sbrs	r24, 7
     c9e:	fc cf       	rjmp	.-8      	; 0xc98 <__vector_18+0x218>
   ch=UDR0;  
     ca0:	60 91 c6 00 	lds	r22, 0x00C6
    _delay_ms(1);
    if ((check = USART_Receive()) <= 0x59)
     ca4:	6a 35       	cpi	r22, 0x5A	; 90
     ca6:	18 f4       	brcc	.+6      	; 0xcae <__vector_18+0x22e>
      write_ds1307(0, check);
     ca8:	80 e0       	ldi	r24, 0x00	; 0
     caa:	0e 94 31 01 	call	0x262	; 0x262 <write_ds1307>
     cae:	80 ed       	ldi	r24, 0xD0	; 208
     cb0:	97 e0       	ldi	r25, 0x07	; 7
     cb2:	01 97       	sbiw	r24, 0x01	; 1
     cb4:	f1 f7       	brne	.-4      	; 0xcb2 <__vector_18+0x232>
//----------------------------------------------------------------------
char USART_Receive(void)
{
   unsigned char ch;

   while (!(UCSR0A & (1<<RXC0)));
     cb6:	80 91 c0 00 	lds	r24, 0x00C0
     cba:	87 ff       	sbrs	r24, 7
     cbc:	fc cf       	rjmp	.-8      	; 0xcb6 <__vector_18+0x236>
   ch=UDR0;  
     cbe:	60 91 c6 00 	lds	r22, 0x00C6
	_delay_ms(1);
	if ((check = USART_Receive()) <= 0x59)  
     cc2:	6a 35       	cpi	r22, 0x5A	; 90
     cc4:	18 f4       	brcc	.+6      	; 0xccc <__vector_18+0x24c>
	  write_ds1307(1, check);
     cc6:	81 e0       	ldi	r24, 0x01	; 1
     cc8:	0e 94 31 01 	call	0x262	; 0x262 <write_ds1307>
     ccc:	80 ed       	ldi	r24, 0xD0	; 208
     cce:	97 e0       	ldi	r25, 0x07	; 7
     cd0:	01 97       	sbiw	r24, 0x01	; 1
     cd2:	f1 f7       	brne	.-4      	; 0xcd0 <__vector_18+0x250>
//----------------------------------------------------------------------
char USART_Receive(void)
{
   unsigned char ch;

   while (!(UCSR0A & (1<<RXC0)));
     cd4:	80 91 c0 00 	lds	r24, 0x00C0
     cd8:	87 ff       	sbrs	r24, 7
     cda:	fc cf       	rjmp	.-8      	; 0xcd4 <__vector_18+0x254>
   ch=UDR0;  
     cdc:	60 91 c6 00 	lds	r22, 0x00C6
	_delay_ms(1);
	if ((check = USART_Receive()) <= 0x23)
     ce0:	64 32       	cpi	r22, 0x24	; 36
     ce2:	08 f0       	brcs	.+2      	; 0xce6 <__vector_18+0x266>
     ce4:	61 c0       	rjmp	.+194    	; 0xda8 <__vector_18+0x328>
	  write_ds1307(2, check);
     ce6:	82 e0       	ldi	r24, 0x02	; 2
     ce8:	2d c0       	rjmp	.+90     	; 0xd44 <__vector_18+0x2c4>
	_delay_ms(1);
  }
  if (byte == 117) {
     cea:	95 37       	cpi	r25, 0x75	; 117
     cec:	71 f5       	brne	.+92     	; 0xd4a <__vector_18+0x2ca>
     cee:	80 ed       	ldi	r24, 0xD0	; 208
     cf0:	97 e0       	ldi	r25, 0x07	; 7
     cf2:	01 97       	sbiw	r24, 0x01	; 1
     cf4:	f1 f7       	brne	.-4      	; 0xcf2 <__vector_18+0x272>
//----------------------------------------------------------------------
char USART_Receive(void)
{
   unsigned char ch;

   while (!(UCSR0A & (1<<RXC0)));
     cf6:	80 91 c0 00 	lds	r24, 0x00C0
     cfa:	87 ff       	sbrs	r24, 7
     cfc:	fc cf       	rjmp	.-8      	; 0xcf6 <__vector_18+0x276>
   ch=UDR0;  
     cfe:	60 91 c6 00 	lds	r22, 0x00C6
    _delay_ms(1);
    if ((check = USART_Receive()) <= 0x99)
     d02:	6a 39       	cpi	r22, 0x9A	; 154
     d04:	18 f4       	brcc	.+6      	; 0xd0c <__vector_18+0x28c>
      write_ds1307(4, check);
     d06:	84 e0       	ldi	r24, 0x04	; 4
     d08:	0e 94 31 01 	call	0x262	; 0x262 <write_ds1307>
     d0c:	80 ed       	ldi	r24, 0xD0	; 208
     d0e:	97 e0       	ldi	r25, 0x07	; 7
     d10:	01 97       	sbiw	r24, 0x01	; 1
     d12:	f1 f7       	brne	.-4      	; 0xd10 <__vector_18+0x290>
//----------------------------------------------------------------------
char USART_Receive(void)
{
   unsigned char ch;

   while (!(UCSR0A & (1<<RXC0)));
     d14:	80 91 c0 00 	lds	r24, 0x00C0
     d18:	87 ff       	sbrs	r24, 7
     d1a:	fc cf       	rjmp	.-8      	; 0xd14 <__vector_18+0x294>
   ch=UDR0;  
     d1c:	60 91 c6 00 	lds	r22, 0x00C6
	_delay_ms(1);
	if ((check = USART_Receive()) <= 0x12)
     d20:	63 31       	cpi	r22, 0x13	; 19
     d22:	18 f4       	brcc	.+6      	; 0xd2a <__vector_18+0x2aa>
	  write_ds1307(5, check);
     d24:	85 e0       	ldi	r24, 0x05	; 5
     d26:	0e 94 31 01 	call	0x262	; 0x262 <write_ds1307>
     d2a:	80 ed       	ldi	r24, 0xD0	; 208
     d2c:	97 e0       	ldi	r25, 0x07	; 7
     d2e:	01 97       	sbiw	r24, 0x01	; 1
     d30:	f1 f7       	brne	.-4      	; 0xd2e <__vector_18+0x2ae>
//----------------------------------------------------------------------
char USART_Receive(void)
{
   unsigned char ch;

   while (!(UCSR0A & (1<<RXC0)));
     d32:	80 91 c0 00 	lds	r24, 0x00C0
     d36:	87 ff       	sbrs	r24, 7
     d38:	fc cf       	rjmp	.-8      	; 0xd32 <__vector_18+0x2b2>
   ch=UDR0;  
     d3a:	60 91 c6 00 	lds	r22, 0x00C6
	_delay_ms(1);
	if ((check = USART_Receive()) <= 0x31)
     d3e:	62 33       	cpi	r22, 0x32	; 50
     d40:	98 f5       	brcc	.+102    	; 0xda8 <__vector_18+0x328>
	  write_ds1307(6, check);
     d42:	86 e0       	ldi	r24, 0x06	; 6
     d44:	0e 94 31 01 	call	0x262	; 0x262 <write_ds1307>
     d48:	2f c0       	rjmp	.+94     	; 0xda8 <__vector_18+0x328>
	_delay_ms(1);
  }
  if (byte == 118) {
     d4a:	96 37       	cpi	r25, 0x76	; 118
     d4c:	91 f5       	brne	.+100    	; 0xdb2 <__vector_18+0x332>
     d4e:	20 e0       	ldi	r18, 0x00	; 0
     d50:	30 e0       	ldi	r19, 0x00	; 0
     d52:	40 ed       	ldi	r20, 0xD0	; 208
     d54:	57 e0       	ldi	r21, 0x07	; 7
     d56:	ca 01       	movw	r24, r20
     d58:	01 97       	sbiw	r24, 0x01	; 1
     d5a:	f1 f7       	brne	.-4      	; 0xd58 <__vector_18+0x2d8>
    for (i = 0; i < 7; i++) {
	  _delay_ms(1);
	  p_alarm[i] = USART_Receive();
     d5c:	e0 91 6b 02 	lds	r30, 0x026B
     d60:	f0 91 6c 02 	lds	r31, 0x026C
//----------------------------------------------------------------------
char USART_Receive(void)
{
   unsigned char ch;

   while (!(UCSR0A & (1<<RXC0)));
     d64:	80 91 c0 00 	lds	r24, 0x00C0
     d68:	87 ff       	sbrs	r24, 7
     d6a:	fc cf       	rjmp	.-8      	; 0xd64 <__vector_18+0x2e4>
   ch=UDR0;  
     d6c:	80 91 c6 00 	lds	r24, 0x00C6
     d70:	e2 0f       	add	r30, r18
     d72:	f3 1f       	adc	r31, r19
     d74:	80 83       	st	Z, r24
     d76:	2f 5f       	subi	r18, 0xFF	; 255
     d78:	3f 4f       	sbci	r19, 0xFF	; 255
	if ((check = USART_Receive()) <= 0x31)
	  write_ds1307(6, check);
	_delay_ms(1);
  }
  if (byte == 118) {
    for (i = 0; i < 7; i++) {
     d7a:	27 30       	cpi	r18, 0x07	; 7
     d7c:	31 05       	cpc	r19, r1
     d7e:	59 f7       	brne	.-42     	; 0xd56 <__vector_18+0x2d6>
//----------------------------------------------------------------------
char USART_Receive(void)
{
   unsigned char ch;

   while (!(UCSR0A & (1<<RXC0)));
     d80:	80 91 c0 00 	lds	r24, 0x00C0
     d84:	87 ff       	sbrs	r24, 7
     d86:	fc cf       	rjmp	.-8      	; 0xd80 <__vector_18+0x300>
   ch=UDR0;  
     d88:	80 91 c6 00 	lds	r24, 0x00C6
	  _delay_ms(1);
	  p_alarm[i] = USART_Receive();
	}
	udaje.mon_temp = USART_Receive();
     d8c:	80 93 3c 04 	sts	0x043C, r24
     d90:	80 ed       	ldi	r24, 0xD0	; 208
     d92:	97 e0       	ldi	r25, 0x07	; 7
     d94:	01 97       	sbiw	r24, 0x01	; 1
     d96:	f1 f7       	brne	.-4      	; 0xd94 <__vector_18+0x314>
//----------------------------------------------------------------------
char USART_Receive(void)
{
   unsigned char ch;

   while (!(UCSR0A & (1<<RXC0)));
     d98:	80 91 c0 00 	lds	r24, 0x00C0
     d9c:	87 ff       	sbrs	r24, 7
     d9e:	fc cf       	rjmp	.-8      	; 0xd98 <__vector_18+0x318>
   ch=UDR0;  
     da0:	80 91 c6 00 	lds	r24, 0x00C6
	_delay_ms(1);
	alarm.al_den = USART_Receive();
     da4:	80 93 27 04 	sts	0x0427, r24
     da8:	80 ed       	ldi	r24, 0xD0	; 208
     daa:	97 e0       	ldi	r25, 0x07	; 7
     dac:	01 97       	sbiw	r24, 0x01	; 1
     dae:	f1 f7       	brne	.-4      	; 0xdac <__vector_18+0x32c>
     db0:	20 c0       	rjmp	.+64     	; 0xdf2 <__vector_18+0x372>
	_delay_ms(1);
  }	
  if (byte == 120) {
     db2:	98 37       	cpi	r25, 0x78	; 120
     db4:	19 f4       	brne	.+6      	; 0xdbc <__vector_18+0x33c>
    delete_eeprom();
     db6:	0e 94 1d 05 	call	0xa3a	; 0xa3a <delete_eeprom>
     dba:	1b c0       	rjmp	.+54     	; 0xdf2 <__vector_18+0x372>
  }
  // --- PRACOVN AS ---
  if (byte == 121) {	/* POIADAVKA PRE PRACOVN STAV */
     dbc:	99 37       	cpi	r25, 0x79	; 121
     dbe:	39 f4       	brne	.+14     	; 0xdce <__vector_18+0x34e>
    prac_stav ^= 1;
     dc0:	80 91 f4 03 	lds	r24, 0x03F4
     dc4:	91 e0       	ldi	r25, 0x01	; 1
     dc6:	89 27       	eor	r24, r25
     dc8:	80 93 f4 03 	sts	0x03F4, r24
     dcc:	12 c0       	rjmp	.+36     	; 0xdf2 <__vector_18+0x372>
  }
  if (byte == 95) {
     dce:	9f 35       	cpi	r25, 0x5F	; 95
     dd0:	81 f4       	brne	.+32     	; 0xdf2 <__vector_18+0x372>
//----------------------------------------------------------------------
char USART_Receive(void)
{
   unsigned char ch;

   while (!(UCSR0A & (1<<RXC0)));
     dd2:	80 91 c0 00 	lds	r24, 0x00C0
     dd6:	87 ff       	sbrs	r24, 7
     dd8:	fc cf       	rjmp	.-8      	; 0xdd2 <__vector_18+0x352>
   ch=UDR0;  
     dda:	80 91 c6 00 	lds	r24, 0x00C6
  /* PRJEM POTREBNCH DAJOV PRE DAN PRCU */  
    freq = USART_Receive();
     dde:	80 93 f2 03 	sts	0x03F2, r24
//----------------------------------------------------------------------
char USART_Receive(void)
{
   unsigned char ch;

   while (!(UCSR0A & (1<<RXC0)));
     de2:	80 91 c0 00 	lds	r24, 0x00C0
     de6:	87 ff       	sbrs	r24, 7
     de8:	fc cf       	rjmp	.-8      	; 0xde2 <__vector_18+0x362>
   ch=UDR0;  
     dea:	80 91 c6 00 	lds	r24, 0x00C6
	freq_nastavena = USART_Receive();
     dee:	80 93 f3 03 	sts	0x03F3, r24
  }
  // --- KONIEC ---
  UCSR0B |= 0x80; 
     df2:	80 91 c1 00 	lds	r24, 0x00C1
     df6:	80 68       	ori	r24, 0x80	; 128
     df8:	80 93 c1 00 	sts	0x00C1, r24
  TIMSK0 = 1;
     dfc:	81 e0       	ldi	r24, 0x01	; 1
     dfe:	80 93 6e 00 	sts	0x006E, r24
}
     e02:	ff 91       	pop	r31
     e04:	ef 91       	pop	r30
     e06:	bf 91       	pop	r27
     e08:	af 91       	pop	r26
     e0a:	9f 91       	pop	r25
     e0c:	8f 91       	pop	r24
     e0e:	7f 91       	pop	r23
     e10:	6f 91       	pop	r22
     e12:	5f 91       	pop	r21
     e14:	4f 91       	pop	r20
     e16:	3f 91       	pop	r19
     e18:	2f 91       	pop	r18
     e1a:	0f 90       	pop	r0
     e1c:	0f be       	out	0x3f, r0	; 63
     e1e:	0f 90       	pop	r0
     e20:	1f 90       	pop	r1
     e22:	18 95       	reti

00000e24 <tst_monudaje>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
     e24:	f9 99       	sbic	0x1f, 1	; 31
     e26:	fe cf       	rjmp	.-4      	; 0xe24 <tst_monudaje>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
     e28:	84 e0       	ldi	r24, 0x04	; 4
     e2a:	90 e0       	ldi	r25, 0x00	; 0
     e2c:	92 bd       	out	0x22, r25	; 34
     e2e:	81 bd       	out	0x21, r24	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
     e30:	f8 9a       	sbi	0x1f, 0	; 31
     e32:	80 b5       	in	r24, 0x20	; 32

}
//----------------------------------------------------------------------
char *tst_monudaje(void)
{
  if (eeprom_read_byte(4) > 0x70) {
     e34:	81 37       	cpi	r24, 0x71	; 113
     e36:	18 f4       	brcc	.+6      	; 0xe3e <tst_monudaje+0x1a>
     e38:	20 e0       	ldi	r18, 0x00	; 0
     e3a:	30 e0       	ldi	r19, 0x00	; 0
     e3c:	13 c0       	rjmp	.+38     	; 0xe64 <tst_monudaje+0x40>
    EEPROM_CAKAJ;
     e3e:	f9 99       	sbic	0x1f, 1	; 31
     e40:	fe cf       	rjmp	.-4      	; 0xe3e <tst_monudaje+0x1a>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
     e42:	f9 99       	sbic	0x1f, 1	; 31
     e44:	fe cf       	rjmp	.-4      	; 0xe42 <tst_monudaje+0x1e>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
     e46:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
     e48:	84 e0       	ldi	r24, 0x04	; 4
     e4a:	90 e0       	ldi	r25, 0x00	; 0
     e4c:	92 bd       	out	0x22, r25	; 34
     e4e:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
     e50:	10 bc       	out	0x20, r1	; 32

    __asm__ __volatile__ (
     e52:	0f b6       	in	r0, 0x3f	; 63
     e54:	f8 94       	cli
     e56:	fa 9a       	sbi	0x1f, 2	; 31
     e58:	f9 9a       	sbi	0x1f, 1	; 31
     e5a:	0f be       	out	0x3f, r0	; 63
	eeprom_write_byte(4,0);
	mon_udaje.max_temp = 0;
     e5c:	10 92 2f 04 	sts	0x042F, r1
     e60:	20 e0       	ldi	r18, 0x00	; 0
     e62:	31 e0       	ldi	r19, 0x01	; 1
	return var(mon_udaje.max_temp);
  }
  return 0;
}
     e64:	c9 01       	movw	r24, r18
     e66:	08 95       	ret

00000e68 <tst_alarm>:
//----------------------------------------------------------------------
char *tst_alarm(void)
{
  if (alarm.temp > 1) {
     e68:	80 91 24 04 	lds	r24, 0x0424
     e6c:	82 30       	cpi	r24, 0x02	; 2
     e6e:	10 f0       	brcs	.+4      	; 0xe74 <tst_alarm+0xc>
    alarm.temp = 0;
     e70:	10 92 24 04 	sts	0x0424, r1
  }
  if (alarm.clock > 1) {
     e74:	80 91 25 04 	lds	r24, 0x0425
     e78:	82 30       	cpi	r24, 0x02	; 2
     e7a:	10 f0       	brcs	.+4      	; 0xe80 <tst_alarm+0x18>
    alarm.clock = 0;
     e7c:	10 92 25 04 	sts	0x0425, r1
  }
  if (alarm.al_flag > 1) {
     e80:	80 91 26 04 	lds	r24, 0x0426
     e84:	82 30       	cpi	r24, 0x02	; 2
     e86:	10 f0       	brcs	.+4      	; 0xe8c <tst_alarm+0x24>
    alarm.al_flag = 0;
     e88:	10 92 26 04 	sts	0x0426, r1
  }
  if (alarm.al_den > 10) {
     e8c:	80 91 27 04 	lds	r24, 0x0427
     e90:	8b 30       	cpi	r24, 0x0B	; 11
     e92:	18 f0       	brcs	.+6      	; 0xe9a <tst_alarm+0x32>
    alarm.al_den = 1;
     e94:	81 e0       	ldi	r24, 0x01	; 1
     e96:	80 93 27 04 	sts	0x0427, r24
  }
  return 0;
}
     e9a:	80 e0       	ldi	r24, 0x00	; 0
     e9c:	90 e0       	ldi	r25, 0x00	; 0
     e9e:	08 95       	ret

00000ea0 <tst_alres>:
{
  if (al_res.pipa > 1) {
    al_res.pipa = 0;
  }
  return 0;
}
     ea0:	80 e0       	ldi	r24, 0x00	; 0
     ea2:	90 e0       	ldi	r25, 0x00	; 0
     ea4:	08 95       	ret

00000ea6 <tst_com>:
//----------------------------------------------------------------------
char *tst_com(void)
{
  return 0;
}
     ea6:	80 e0       	ldi	r24, 0x00	; 0
     ea8:	90 e0       	ldi	r25, 0x00	; 0
     eaa:	08 95       	ret

00000eac <__vector_9>:
  /*------- KONIEC --------*/
  TIMSK0 = 1;
}
//----------------------------------------------------------------------
ISR(TIMER2_OVF_vect) 		// Prerusenie kazdych 32,64 ms
{
     eac:	1f 92       	push	r1
     eae:	0f 92       	push	r0
     eb0:	0f b6       	in	r0, 0x3f	; 63
     eb2:	0f 92       	push	r0
     eb4:	11 24       	eor	r1, r1
     eb6:	2f 93       	push	r18
     eb8:	3f 93       	push	r19
     eba:	4f 93       	push	r20
     ebc:	5f 93       	push	r21
     ebe:	6f 93       	push	r22
     ec0:	7f 93       	push	r23
     ec2:	8f 93       	push	r24
     ec4:	9f 93       	push	r25
     ec6:	af 93       	push	r26
     ec8:	bf 93       	push	r27
     eca:	cf 93       	push	r28
     ecc:	df 93       	push	r29
     ece:	ef 93       	push	r30
     ed0:	ff 93       	push	r31
  //unsigned char vypis[40];
  unsigned char *check1;
  TIMSK2 = 0;
     ed2:	10 92 70 00 	sts	0x0070, r1
  timer2_ref++;
     ed6:	40 91 f6 03 	lds	r20, 0x03F6
     eda:	4f 5f       	subi	r20, 0xFF	; 255
     edc:	40 93 f6 03 	sts	0x03F6, r20

  if ((zmena == 1) && ((cak+10) == timer2_ref))
     ee0:	80 91 f7 03 	lds	r24, 0x03F7
     ee4:	81 30       	cpi	r24, 0x01	; 1
     ee6:	59 f4       	brne	.+22     	; 0xefe <__vector_9+0x52>
     ee8:	80 91 fa 03 	lds	r24, 0x03FA
     eec:	90 e0       	ldi	r25, 0x00	; 0
     eee:	0a 96       	adiw	r24, 0x0a	; 10
     ef0:	24 2f       	mov	r18, r20
     ef2:	30 e0       	ldi	r19, 0x00	; 0
     ef4:	82 17       	cp	r24, r18
     ef6:	93 07       	cpc	r25, r19
     ef8:	11 f4       	brne	.+4      	; 0xefe <__vector_9+0x52>
    zmena = 0;
     efa:	10 92 f7 03 	sts	0x03F7, r1

  if (bit_is_set(PIND, 4) && (zmena == 0)) {
     efe:	4c 9b       	sbis	0x09, 4	; 9
     f00:	17 c0       	rjmp	.+46     	; 0xf30 <__vector_9+0x84>
     f02:	80 91 f7 03 	lds	r24, 0x03F7
     f06:	88 23       	and	r24, r24
     f08:	99 f4       	brne	.+38     	; 0xf30 <__vector_9+0x84>
    podsv_dis ^= 1;
     f0a:	80 91 f9 03 	lds	r24, 0x03F9
     f0e:	21 e0       	ldi	r18, 0x01	; 1
     f10:	82 27       	eor	r24, r18
     f12:	80 93 f9 03 	sts	0x03F9, r24
    PORTD ^= 4;
     f16:	8b b1       	in	r24, 0x0b	; 11
     f18:	94 e0       	ldi	r25, 0x04	; 4
     f1a:	89 27       	eor	r24, r25
     f1c:	8b b9       	out	0x0b, r24	; 11
	zmena = 1;
     f1e:	20 93 f7 03 	sts	0x03F7, r18
	cak = (timer2_ref <= 245) ? timer2_ref : 0;
     f22:	46 3f       	cpi	r20, 0xF6	; 246
     f24:	10 f0       	brcs	.+4      	; 0xf2a <__vector_9+0x7e>
     f26:	80 e0       	ldi	r24, 0x00	; 0
     f28:	01 c0       	rjmp	.+2      	; 0xf2c <__vector_9+0x80>
     f2a:	84 2f       	mov	r24, r20
     f2c:	80 93 fa 03 	sts	0x03FA, r24
  }
  if ((timer2_ref % 250) == 0) {
     f30:	84 2f       	mov	r24, r20
     f32:	6a ef       	ldi	r22, 0xFA	; 250
     f34:	0e 94 99 13 	call	0x2732	; 0x2732 <__udivmodqi4>
     f38:	99 23       	and	r25, r25
     f3a:	09 f0       	breq	.+2      	; 0xf3e <__vector_9+0x92>
     f3c:	4f c0       	rjmp	.+158    	; 0xfdc <__vector_9+0x130>
    check1 = tst_monudaje();
     f3e:	0e 94 12 07 	call	0xe24	; 0xe24 <tst_monudaje>
     f42:	ec 01       	movw	r28, r24
    if (check1 != 0) {
     f44:	00 97       	sbiw	r24, 0x00	; 0
     f46:	89 f1       	breq	.+98     	; 0xfaa <__vector_9+0xfe>
      LCDclr();
     f48:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <LCDclr>
	  strcpy(lcd_dis[0], "Opravena chyba v");
     f4c:	8c ef       	ldi	r24, 0xFC	; 252
     f4e:	93 e0       	ldi	r25, 0x03	; 3
     f50:	63 e1       	ldi	r22, 0x13	; 19
     f52:	71 e0       	ldi	r23, 0x01	; 1
     f54:	0e 94 dc 10 	call	0x21b8	; 0x21b8 <strcpy>
	  strcpy(lcd_dis[1], "                ");
     f58:	8d e0       	ldi	r24, 0x0D	; 13
     f5a:	94 e0       	ldi	r25, 0x04	; 4
     f5c:	64 e2       	ldi	r22, 0x24	; 36
     f5e:	71 e0       	ldi	r23, 0x01	; 1
     f60:	0e 94 dc 10 	call	0x21b8	; 0x21b8 <strcpy>
	  strcpy(lcd_dis[1], check1);
     f64:	8d e0       	ldi	r24, 0x0D	; 13
     f66:	94 e0       	ldi	r25, 0x04	; 4
     f68:	be 01       	movw	r22, r28
     f6a:	0e 94 dc 10 	call	0x21b8	; 0x21b8 <strcpy>
	  LCDstringXY(0, 0, lcd_dis[0], 16);
     f6e:	80 e0       	ldi	r24, 0x00	; 0
     f70:	60 e0       	ldi	r22, 0x00	; 0
     f72:	4c ef       	ldi	r20, 0xFC	; 252
     f74:	53 e0       	ldi	r21, 0x03	; 3
     f76:	20 e1       	ldi	r18, 0x10	; 16
     f78:	0e 94 25 03 	call	0x64a	; 0x64a <LCDstringXY>
      LCDstringXY(0, 1, lcd_dis[1], 16);
     f7c:	80 e0       	ldi	r24, 0x00	; 0
     f7e:	61 e0       	ldi	r22, 0x01	; 1
     f80:	4d e0       	ldi	r20, 0x0D	; 13
     f82:	54 e0       	ldi	r21, 0x04	; 4
     f84:	20 e1       	ldi	r18, 0x10	; 16
     f86:	0e 94 25 03 	call	0x64a	; 0x64a <LCDstringXY>
     f8a:	80 e1       	ldi	r24, 0x10	; 16
     f8c:	97 e2       	ldi	r25, 0x27	; 39
     f8e:	28 ec       	ldi	r18, 0xC8	; 200
     f90:	30 e0       	ldi	r19, 0x00	; 0
     f92:	f9 01       	movw	r30, r18
     f94:	31 97       	sbiw	r30, 0x01	; 1
     f96:	f1 f7       	brne	.-4      	; 0xf94 <__vector_9+0xe8>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     f98:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     f9a:	d9 f7       	brne	.-10     	; 0xf92 <__vector_9+0xe6>
     f9c:	35 c0       	rjmp	.+106    	; 0x1008 <__vector_9+0x15c>
     f9e:	ca 01       	movw	r24, r20
     fa0:	01 97       	sbiw	r24, 0x01	; 1
     fa2:	f1 f7       	brne	.-4      	; 0xfa0 <__vector_9+0xf4>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     fa4:	21 50       	subi	r18, 0x01	; 1
     fa6:	30 40       	sbci	r19, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     fa8:	d1 f7       	brne	.-12     	; 0xf9e <__vector_9+0xf2>
  return 0;
}
//----------------------------------------------------------------------
char *tst_alarm(void)
{
  if (alarm.temp > 1) {
     faa:	80 91 24 04 	lds	r24, 0x0424
     fae:	82 30       	cpi	r24, 0x02	; 2
     fb0:	10 f0       	brcs	.+4      	; 0xfb6 <__vector_9+0x10a>
    alarm.temp = 0;
     fb2:	10 92 24 04 	sts	0x0424, r1
  }
  if (alarm.clock > 1) {
     fb6:	80 91 25 04 	lds	r24, 0x0425
     fba:	82 30       	cpi	r24, 0x02	; 2
     fbc:	10 f0       	brcs	.+4      	; 0xfc2 <__vector_9+0x116>
    alarm.clock = 0;
     fbe:	10 92 25 04 	sts	0x0425, r1
  }
  if (alarm.al_flag > 1) {
     fc2:	80 91 26 04 	lds	r24, 0x0426
     fc6:	82 30       	cpi	r24, 0x02	; 2
     fc8:	10 f0       	brcs	.+4      	; 0xfce <__vector_9+0x122>
    alarm.al_flag = 0;
     fca:	10 92 26 04 	sts	0x0426, r1
  }
  if (alarm.al_den > 10) {
     fce:	80 91 27 04 	lds	r24, 0x0427
     fd2:	8b 30       	cpi	r24, 0x0B	; 11
     fd4:	18 f0       	brcs	.+6      	; 0xfdc <__vector_9+0x130>
    alarm.al_den = 1;
     fd6:	81 e0       	ldi	r24, 0x01	; 1
     fd8:	80 93 27 04 	sts	0x0427, r24
    tst_alarm();
    tst_alres();
    //tst_com();
  }
  
  TIMSK2 = 1;
     fdc:	81 e0       	ldi	r24, 0x01	; 1
     fde:	80 93 70 00 	sts	0x0070, r24
}
     fe2:	ff 91       	pop	r31
     fe4:	ef 91       	pop	r30
     fe6:	df 91       	pop	r29
     fe8:	cf 91       	pop	r28
     fea:	bf 91       	pop	r27
     fec:	af 91       	pop	r26
     fee:	9f 91       	pop	r25
     ff0:	8f 91       	pop	r24
     ff2:	7f 91       	pop	r23
     ff4:	6f 91       	pop	r22
     ff6:	5f 91       	pop	r21
     ff8:	4f 91       	pop	r20
     ffa:	3f 91       	pop	r19
     ffc:	2f 91       	pop	r18
     ffe:	0f 90       	pop	r0
    1000:	0f be       	out	0x3f, r0	; 63
    1002:	0f 90       	pop	r0
    1004:	1f 90       	pop	r1
    1006:	18 95       	reti
      LCDstringXY(0, 1, lcd_dis[1], 16);
	  _delay_ms(1000);
    }
    //check1 = tst_udaje();
    if (check1 != 0) {
      LCDclr();
    1008:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <LCDclr>
	  strcpy(lcd_dis[0], "Najdena chyba v ");
    100c:	8c ef       	ldi	r24, 0xFC	; 252
    100e:	93 e0       	ldi	r25, 0x03	; 3
    1010:	65 e3       	ldi	r22, 0x35	; 53
    1012:	71 e0       	ldi	r23, 0x01	; 1
    1014:	0e 94 dc 10 	call	0x21b8	; 0x21b8 <strcpy>
	  strcpy(lcd_dis[1], "                ");
    1018:	8d e0       	ldi	r24, 0x0D	; 13
    101a:	94 e0       	ldi	r25, 0x04	; 4
    101c:	64 e2       	ldi	r22, 0x24	; 36
    101e:	71 e0       	ldi	r23, 0x01	; 1
    1020:	0e 94 dc 10 	call	0x21b8	; 0x21b8 <strcpy>
	  strcpy(lcd_dis[1], check1);
    1024:	8d e0       	ldi	r24, 0x0D	; 13
    1026:	94 e0       	ldi	r25, 0x04	; 4
    1028:	be 01       	movw	r22, r28
    102a:	0e 94 dc 10 	call	0x21b8	; 0x21b8 <strcpy>
	  LCDstringXY(0, 0, lcd_dis[0], 16);
    102e:	80 e0       	ldi	r24, 0x00	; 0
    1030:	60 e0       	ldi	r22, 0x00	; 0
    1032:	4c ef       	ldi	r20, 0xFC	; 252
    1034:	53 e0       	ldi	r21, 0x03	; 3
    1036:	20 e1       	ldi	r18, 0x10	; 16
    1038:	0e 94 25 03 	call	0x64a	; 0x64a <LCDstringXY>
      LCDstringXY(0, 1, lcd_dis[1], 16);
    103c:	80 e0       	ldi	r24, 0x00	; 0
    103e:	61 e0       	ldi	r22, 0x01	; 1
    1040:	4d e0       	ldi	r20, 0x0D	; 13
    1042:	54 e0       	ldi	r21, 0x04	; 4
    1044:	20 e1       	ldi	r18, 0x10	; 16
    1046:	0e 94 25 03 	call	0x64a	; 0x64a <LCDstringXY>
    104a:	20 e1       	ldi	r18, 0x10	; 16
    104c:	37 e2       	ldi	r19, 0x27	; 39
    104e:	48 ec       	ldi	r20, 0xC8	; 200
    1050:	50 e0       	ldi	r21, 0x00	; 0
    1052:	a5 cf       	rjmp	.-182    	; 0xf9e <__vector_9+0xf2>

00001054 <nastav5>:
  }
  alarm.temp = _temp;
}
//----------------------------------------------------------------------
void nastav5(void)	
{
    1054:	ef 92       	push	r14
    1056:	ff 92       	push	r15
    1058:	0f 93       	push	r16
    105a:	df 93       	push	r29
    105c:	cf 93       	push	r28
    105e:	cd b7       	in	r28, 0x3d	; 61
    1060:	de b7       	in	r29, 0x3e	; 62
    1062:	64 97       	sbiw	r28, 0x14	; 20
    1064:	0f b6       	in	r0, 0x3f	; 63
    1066:	f8 94       	cli
    1068:	de bf       	out	0x3e, r29	; 62
    106a:	0f be       	out	0x3f, r0	; 63
    106c:	cd bf       	out	0x3d, r28	; 61
  char _aden, j;
  char *al_dni[] = {"Pondelok", "Utorok  ", "Streda  ", "Stvrtok ", "Piatok  ", "Sobota  ", "Nedela  ", "Po - Pia", "So - Ne ", "Po - Ne "};
    106e:	de 01       	movw	r26, r28
    1070:	11 96       	adiw	r26, 0x01	; 1
    1072:	ed ed       	ldi	r30, 0xDD	; 221
    1074:	f3 e0       	ldi	r31, 0x03	; 3
    1076:	84 e1       	ldi	r24, 0x14	; 20
    1078:	01 90       	ld	r0, Z+
    107a:	0d 92       	st	X+, r0
    107c:	81 50       	subi	r24, 0x01	; 1
    107e:	e1 f7       	brne	.-8      	; 0x1078 <nastav5+0x24>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    1080:	30 99       	sbic	0x06, 0	; 6
    1082:	fe cf       	rjmp	.-4      	; 0x1080 <nastav5+0x2c>
{
  char _aden, j;
  char *al_dni[] = {"Pondelok", "Utorok  ", "Streda  ", "Stvrtok ", "Piatok  ", "Sobota  ", "Nedela  ", "Po - Pia", "So - Ne ", "Po - Ne "};

  cakaj(0);
  _aden = alarm.al_den;					
    1084:	00 91 27 04 	lds	r16, 0x0427
  LCDclr();
    1088:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <LCDclr>
  strcpy(lcd_dis[0], "  Nastavit den");
    108c:	8c ef       	ldi	r24, 0xFC	; 252
    108e:	93 e0       	ldi	r25, 0x03	; 3
    1090:	66 e4       	ldi	r22, 0x46	; 70
    1092:	71 e0       	ldi	r23, 0x01	; 1
    1094:	0e 94 dc 10 	call	0x21b8	; 0x21b8 <strcpy>
  strcpy(lcd_dis[1], al_dni[_aden-1]);
    1098:	e0 2f       	mov	r30, r16
    109a:	f0 e0       	ldi	r31, 0x00	; 0
    109c:	31 97       	sbiw	r30, 0x01	; 1
    109e:	ee 0f       	add	r30, r30
    10a0:	ff 1f       	adc	r31, r31
    10a2:	7e 01       	movw	r14, r28
    10a4:	08 94       	sec
    10a6:	e1 1c       	adc	r14, r1
    10a8:	f1 1c       	adc	r15, r1
    10aa:	ee 0d       	add	r30, r14
    10ac:	ff 1d       	adc	r31, r15
    10ae:	60 81       	ld	r22, Z
    10b0:	71 81       	ldd	r23, Z+1	; 0x01
    10b2:	8d e0       	ldi	r24, 0x0D	; 13
    10b4:	94 e0       	ldi	r25, 0x04	; 4
    10b6:	0e 94 dc 10 	call	0x21b8	; 0x21b8 <strcpy>
  LCDstringXY(0, 0, lcd_dis[0], 14);
    10ba:	80 e0       	ldi	r24, 0x00	; 0
    10bc:	60 e0       	ldi	r22, 0x00	; 0
    10be:	4c ef       	ldi	r20, 0xFC	; 252
    10c0:	53 e0       	ldi	r21, 0x03	; 3
    10c2:	2e e0       	ldi	r18, 0x0E	; 14
    10c4:	0e 94 25 03 	call	0x64a	; 0x64a <LCDstringXY>
  LCDstringXY(0, 1, lcd_dis[1], 8);
    10c8:	80 e0       	ldi	r24, 0x00	; 0
    10ca:	61 e0       	ldi	r22, 0x01	; 1
    10cc:	4d e0       	ldi	r20, 0x0D	; 13
    10ce:	54 e0       	ldi	r21, 0x04	; 4
    10d0:	28 e0       	ldi	r18, 0x08	; 8
    10d2:	0e 94 25 03 	call	0x64a	; 0x64a <LCDstringXY>
  for (;;) {
    strcpy(lcd_dis[1], al_dni[_aden-1]);
    10d6:	e0 2f       	mov	r30, r16
    10d8:	f0 e0       	ldi	r31, 0x00	; 0
    10da:	31 97       	sbiw	r30, 0x01	; 1
    10dc:	ee 0f       	add	r30, r30
    10de:	ff 1f       	adc	r31, r31
    10e0:	ee 0d       	add	r30, r14
    10e2:	ff 1d       	adc	r31, r15
    10e4:	60 81       	ld	r22, Z
    10e6:	71 81       	ldd	r23, Z+1	; 0x01
    10e8:	8d e0       	ldi	r24, 0x0D	; 13
    10ea:	94 e0       	ldi	r25, 0x04	; 4
    10ec:	0e 94 dc 10 	call	0x21b8	; 0x21b8 <strcpy>
    LCDstringXY(0, 1, lcd_dis[1], 8);	
    10f0:	80 e0       	ldi	r24, 0x00	; 0
    10f2:	61 e0       	ldi	r22, 0x01	; 1
    10f4:	4d e0       	ldi	r20, 0x0D	; 13
    10f6:	54 e0       	ldi	r21, 0x04	; 4
    10f8:	28 e0       	ldi	r18, 0x08	; 8
    10fa:	0e 94 25 03 	call	0x64a	; 0x64a <LCDstringXY>
    if (bit_is_set(PINC, 1)) {
    10fe:	31 9b       	sbis	0x06, 1	; 6
    1100:	0c c0       	rjmp	.+24     	; 0x111a <nastav5+0xc6>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    1102:	31 99       	sbic	0x06, 1	; 6
    1104:	fe cf       	rjmp	.-4      	; 0x1102 <nastav5+0xae>
  for (;;) {
    strcpy(lcd_dis[1], al_dni[_aden-1]);
    LCDstringXY(0, 1, lcd_dis[1], 8);	
    if (bit_is_set(PINC, 1)) {
	  cakaj(1);
	  if (_aden < 10)
    1106:	0a 30       	cpi	r16, 0x0A	; 10
    1108:	10 f0       	brcs	.+4      	; 0x110e <nastav5+0xba>
    110a:	01 e0       	ldi	r16, 0x01	; 1
    110c:	01 c0       	rjmp	.+2      	; 0x1110 <nastav5+0xbc>
	    _aden++;
    110e:	0f 5f       	subi	r16, 0xFF	; 255
	  else _aden = 1;
	  LCDcistiXY(0, 1, 8);
    1110:	80 e0       	ldi	r24, 0x00	; 0
    1112:	61 e0       	ldi	r22, 0x01	; 1
    1114:	48 e0       	ldi	r20, 0x08	; 8
    1116:	0e 94 15 03 	call	0x62a	; 0x62a <LCDcistiXY>
	}
	if (bit_is_set(PINC, 2)) {
    111a:	32 9b       	sbis	0x06, 2	; 6
    111c:	0c c0       	rjmp	.+24     	; 0x1136 <nastav5+0xe2>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    111e:	32 99       	sbic	0x06, 2	; 6
    1120:	fe cf       	rjmp	.-4      	; 0x111e <nastav5+0xca>
	  else _aden = 1;
	  LCDcistiXY(0, 1, 8);
	}
	if (bit_is_set(PINC, 2)) {
	  cakaj(2);
	  if (_aden > 1)
    1122:	02 30       	cpi	r16, 0x02	; 2
    1124:	10 f4       	brcc	.+4      	; 0x112a <nastav5+0xd6>
    1126:	0a e0       	ldi	r16, 0x0A	; 10
    1128:	01 c0       	rjmp	.+2      	; 0x112c <nastav5+0xd8>
	    _aden--;
    112a:	01 50       	subi	r16, 0x01	; 1
	  else _aden = 10;
	  LCDcistiXY(0, 1, 8);
    112c:	80 e0       	ldi	r24, 0x00	; 0
    112e:	61 e0       	ldi	r22, 0x01	; 1
    1130:	48 e0       	ldi	r20, 0x08	; 8
    1132:	0e 94 15 03 	call	0x62a	; 0x62a <LCDcistiXY>
	}
	if (bit_is_set(PINC, 0)) {
    1136:	30 9b       	sbis	0x06, 0	; 6
    1138:	05 c0       	rjmp	.+10     	; 0x1144 <nastav5+0xf0>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    113a:	30 99       	sbic	0x06, 0	; 6
    113c:	fe cf       	rjmp	.-4      	; 0x113a <nastav5+0xe6>
	  else _aden = 10;
	  LCDcistiXY(0, 1, 8);
	}
	if (bit_is_set(PINC, 0)) {
	  cakaj(0);
	  alarm.al_den = _aden;
    113e:	00 93 27 04 	sts	0x0427, r16
    1142:	04 c0       	rjmp	.+8      	; 0x114c <nastav5+0xf8>
	  break;
	}
	if (bit_is_set(PINC, 4)) {
    1144:	34 9b       	sbis	0x06, 4	; 6
    1146:	c7 cf       	rjmp	.-114    	; 0x10d6 <nastav5+0x82>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    1148:	34 99       	sbic	0x06, 4	; 6
    114a:	fe cf       	rjmp	.-4      	; 0x1148 <nastav5+0xf4>
	if (bit_is_set(PINC, 4)) {
	  cakaj(4);
	  return;
	}
  }
}
    114c:	64 96       	adiw	r28, 0x14	; 20
    114e:	0f b6       	in	r0, 0x3f	; 63
    1150:	f8 94       	cli
    1152:	de bf       	out	0x3e, r29	; 62
    1154:	0f be       	out	0x3f, r0	; 63
    1156:	cd bf       	out	0x3d, r28	; 61
    1158:	cf 91       	pop	r28
    115a:	df 91       	pop	r29
    115c:	0f 91       	pop	r16
    115e:	ff 90       	pop	r15
    1160:	ef 90       	pop	r14
    1162:	08 95       	ret

00001164 <nastav2>:
	}
  }
}
//----------------------------------------------------------------------
void nastav2(void)		// nastavenie ALARMU (ako celku)
{
    1164:	1f 93       	push	r17
    1166:	cf 93       	push	r28
    1168:	df 93       	push	r29
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    116a:	30 99       	sbic	0x06, 0	; 6
    116c:	fe cf       	rjmp	.-4      	; 0x116a <nastav2+0x6>
void nastav2(void)		// nastavenie ALARMU (ako celku)
{
  char al_flag;

  cakaj(0);
  al_flag = alarm.al_flag;
    116e:	10 91 26 04 	lds	r17, 0x0426
  LCDclr();
    1172:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <LCDclr>
  LCDhome();
    1176:	0e 94 d6 01 	call	0x3ac	; 0x3ac <LCDhome>
  strcpy(lcd_dis[0], "Nastavit Alarm  ");	//doplnene
    117a:	8c ef       	ldi	r24, 0xFC	; 252
    117c:	93 e0       	ldi	r25, 0x03	; 3
    117e:	65 e5       	ldi	r22, 0x55	; 85
    1180:	71 e0       	ldi	r23, 0x01	; 1
    1182:	0e 94 dc 10 	call	0x21b8	; 0x21b8 <strcpy>
  LCDstring(lcd_dis[0], 16);				// funkcia nastav2() je spustena funkciou nastav1()
    1186:	8c ef       	ldi	r24, 0xFC	; 252
    1188:	93 e0       	ldi	r25, 0x03	; 3
    118a:	60 e1       	ldi	r22, 0x10	; 16
    118c:	0e 94 da 01 	call	0x3b4	; 0x3b4 <LCDstring>
    1190:	c8 ec       	ldi	r28, 0xC8	; 200
    1192:	d0 e0       	ldi	r29, 0x00	; 0
  while (1) {								// v tejto funkcii nastavujem ON/OFF alarm
    LCDGotoXY(0,1);							// po nastaveni ON funkcia automaticky skoci na nastav3()
    1194:	80 e0       	ldi	r24, 0x00	; 0
    1196:	61 e0       	ldi	r22, 0x01	; 1
    1198:	0e 94 ef 01 	call	0x3de	; 0x3de <LCDGotoXY>
	if (al_flag == 0) {					// inak neskoci nikam a vrati sa do nastav1() ktora nasledne skonci
    119c:	11 23       	and	r17, r17
    119e:	29 f4       	brne	.+10     	; 0x11aa <nastav2+0x46>
	  strcpy(lcd_dis[1], "Vypnute");	//doplnene
    11a0:	8d e0       	ldi	r24, 0x0D	; 13
    11a2:	94 e0       	ldi	r25, 0x04	; 4
    11a4:	66 e6       	ldi	r22, 0x66	; 102
    11a6:	71 e0       	ldi	r23, 0x01	; 1
    11a8:	04 c0       	rjmp	.+8      	; 0x11b2 <nastav2+0x4e>
	  LCDstring(lcd_dis[1], 7);
	}
	else {
	  strcpy(lcd_dis[1], "Zapnute");	//doplnene
    11aa:	8d e0       	ldi	r24, 0x0D	; 13
    11ac:	94 e0       	ldi	r25, 0x04	; 4
    11ae:	6e e6       	ldi	r22, 0x6E	; 110
    11b0:	71 e0       	ldi	r23, 0x01	; 1
    11b2:	0e 94 dc 10 	call	0x21b8	; 0x21b8 <strcpy>
	  LCDstring(lcd_dis[1], 7);
    11b6:	8d e0       	ldi	r24, 0x0D	; 13
    11b8:	94 e0       	ldi	r25, 0x04	; 4
    11ba:	67 e0       	ldi	r22, 0x07	; 7
    11bc:	0e 94 da 01 	call	0x3b4	; 0x3b4 <LCDstring>
	}
	if (bit_is_set(PINC, 1)) {
    11c0:	31 9b       	sbis	0x06, 1	; 6
    11c2:	10 c0       	rjmp	.+32     	; 0x11e4 <nastav2+0x80>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    11c4:	31 99       	sbic	0x06, 1	; 6
    11c6:	fe cf       	rjmp	.-4      	; 0x11c4 <nastav2+0x60>
	  LCDstring(lcd_dis[1], 7);
	}
	if (bit_is_set(PINC, 1)) {
	  cakaj(1);
	  al_flag ^= 1;
	  LCDcistiXY(0, 1, 7);
    11c8:	80 e0       	ldi	r24, 0x00	; 0
    11ca:	61 e0       	ldi	r22, 0x01	; 1
    11cc:	47 e0       	ldi	r20, 0x07	; 7
    11ce:	0e 94 15 03 	call	0x62a	; 0x62a <LCDcistiXY>
    11d2:	80 e2       	ldi	r24, 0x20	; 32
    11d4:	93 e0       	ldi	r25, 0x03	; 3
    11d6:	fe 01       	movw	r30, r28
    11d8:	31 97       	sbiw	r30, 0x01	; 1
    11da:	f1 f7       	brne	.-4      	; 0x11d8 <nastav2+0x74>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    11dc:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    11de:	d9 f7       	brne	.-10     	; 0x11d6 <nastav2+0x72>
	  strcpy(lcd_dis[1], "Zapnute");	//doplnene
	  LCDstring(lcd_dis[1], 7);
	}
	if (bit_is_set(PINC, 1)) {
	  cakaj(1);
	  al_flag ^= 1;
    11e0:	81 e0       	ldi	r24, 0x01	; 1
    11e2:	18 27       	eor	r17, r24
	  LCDcistiXY(0, 1, 7);
	  _delay_ms(80);
	}
	if (bit_is_set(PINC, 2)) {
    11e4:	32 9b       	sbis	0x06, 2	; 6
    11e6:	10 c0       	rjmp	.+32     	; 0x1208 <nastav2+0xa4>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    11e8:	32 99       	sbic	0x06, 2	; 6
    11ea:	fe cf       	rjmp	.-4      	; 0x11e8 <nastav2+0x84>
	  _delay_ms(80);
	}
	if (bit_is_set(PINC, 2)) {
	  cakaj(2);
	  al_flag ^= 1;
	  LCDcistiXY(0, 1, 7);
    11ec:	80 e0       	ldi	r24, 0x00	; 0
    11ee:	61 e0       	ldi	r22, 0x01	; 1
    11f0:	47 e0       	ldi	r20, 0x07	; 7
    11f2:	0e 94 15 03 	call	0x62a	; 0x62a <LCDcistiXY>
    11f6:	80 e2       	ldi	r24, 0x20	; 32
    11f8:	93 e0       	ldi	r25, 0x03	; 3
    11fa:	fe 01       	movw	r30, r28
    11fc:	31 97       	sbiw	r30, 0x01	; 1
    11fe:	f1 f7       	brne	.-4      	; 0x11fc <nastav2+0x98>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1200:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1202:	d9 f7       	brne	.-10     	; 0x11fa <nastav2+0x96>
	  LCDcistiXY(0, 1, 7);
	  _delay_ms(80);
	}
	if (bit_is_set(PINC, 2)) {
	  cakaj(2);
	  al_flag ^= 1;
    1204:	81 e0       	ldi	r24, 0x01	; 1
    1206:	18 27       	eor	r17, r24
	  LCDcistiXY(0, 1, 7);
	  _delay_ms(80);
	}
	if (bit_is_set(PINC, 0)) {
    1208:	30 9b       	sbis	0x06, 0	; 6
    120a:	03 c0       	rjmp	.+6      	; 0x1212 <nastav2+0xae>
	  alarm.al_flag = al_flag;
    120c:	10 93 26 04 	sts	0x0426, r17
    1210:	04 c0       	rjmp	.+8      	; 0x121a <nastav2+0xb6>
	  break;
	}
	if (bit_is_set(PINC, 4)) {
    1212:	34 9b       	sbis	0x06, 4	; 6
    1214:	bf cf       	rjmp	.-130    	; 0x1194 <nastav2+0x30>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    1216:	34 99       	sbic	0x06, 4	; 6
    1218:	fe cf       	rjmp	.-4      	; 0x1216 <nastav2+0xb2>
	if (bit_is_set(PINC, 4)) {
	  cakaj(4);
	  return;
	}
  }
}
    121a:	df 91       	pop	r29
    121c:	cf 91       	pop	r28
    121e:	1f 91       	pop	r17
    1220:	08 95       	ret

00001222 <nastav1>:
	}
  }
}
//----------------------------------------------------------------------
void nastav1(void)			
{
    1222:	1f 93       	push	r17
    1224:	cf 93       	push	r28
    1226:	df 93       	push	r29
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    1228:	30 99       	sbic	0x06, 0	; 6
    122a:	fe cf       	rjmp	.-4      	; 0x1228 <nastav1+0x6>
void nastav1(void)			
{
  char mon_temp;
  
  cakaj(0);
  mon_temp = udaje.mon_temp;
    122c:	10 91 3c 04 	lds	r17, 0x043C
  LCDclr();
    1230:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <LCDclr>
  LCDhome();
    1234:	0e 94 d6 01 	call	0x3ac	; 0x3ac <LCDhome>
  strcpy(lcd_dis[0], "Snimat teplotu >");	//doplnene
    1238:	8c ef       	ldi	r24, 0xFC	; 252
    123a:	93 e0       	ldi	r25, 0x03	; 3
    123c:	66 e7       	ldi	r22, 0x76	; 118
    123e:	71 e0       	ldi	r23, 0x01	; 1
    1240:	0e 94 dc 10 	call	0x21b8	; 0x21b8 <strcpy>
  LCDstring(lcd_dis[0], 16);				// zacinam nastavenim sniania teploty
    1244:	8c ef       	ldi	r24, 0xFC	; 252
    1246:	93 e0       	ldi	r25, 0x03	; 3
    1248:	60 e1       	ldi	r22, 0x10	; 16
    124a:	0e 94 da 01 	call	0x3b4	; 0x3b4 <LCDstring>
    124e:	c8 ec       	ldi	r28, 0xC8	; 200
    1250:	d0 e0       	ldi	r29, 0x00	; 0
  while (1) {									// co je funkcia nastav1
    LCDGotoXY(0,1);								// tato funkcia je spustena funkciou nastav_extra()
    1252:	80 e0       	ldi	r24, 0x00	; 0
    1254:	61 e0       	ldi	r22, 0x01	; 1
    1256:	0e 94 ef 01 	call	0x3de	; 0x3de <LCDGotoXY>
    if (mon_temp == 0) {					// a ta je spustena ukazatelom podla prislusnej volby
    125a:	11 23       	and	r17, r17
    125c:	29 f4       	brne	.+10     	; 0x1268 <nastav1+0x46>
	  strcpy(lcd_dis[1], "Vypnute");		//doplnene
    125e:	8d e0       	ldi	r24, 0x0D	; 13
    1260:	94 e0       	ldi	r25, 0x04	; 4
    1262:	66 e6       	ldi	r22, 0x66	; 102
    1264:	71 e0       	ldi	r23, 0x01	; 1
    1266:	04 c0       	rjmp	.+8      	; 0x1270 <nastav1+0x4e>
      LCDstring(lcd_dis[1], 7);
	}
    else {
	  strcpy(lcd_dis[1],"Zapnute"); 		//doplnene
    1268:	8d e0       	ldi	r24, 0x0D	; 13
    126a:	94 e0       	ldi	r25, 0x04	; 4
    126c:	6e e6       	ldi	r22, 0x6E	; 110
    126e:	71 e0       	ldi	r23, 0x01	; 1
    1270:	0e 94 dc 10 	call	0x21b8	; 0x21b8 <strcpy>
	  LCDstring(lcd_dis[1], 7);
    1274:	8d e0       	ldi	r24, 0x0D	; 13
    1276:	94 e0       	ldi	r25, 0x04	; 4
    1278:	67 e0       	ldi	r22, 0x07	; 7
    127a:	0e 94 da 01 	call	0x3b4	; 0x3b4 <LCDstring>
	}
	if (bit_is_set(PINC, 1)) {	
    127e:	31 9b       	sbis	0x06, 1	; 6
    1280:	10 c0       	rjmp	.+32     	; 0x12a2 <nastav1+0x80>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    1282:	31 99       	sbic	0x06, 1	; 6
    1284:	fe cf       	rjmp	.-4      	; 0x1282 <nastav1+0x60>
	  LCDstring(lcd_dis[1], 7);
	}
	if (bit_is_set(PINC, 1)) {	
	  cakaj(1);
	  mon_temp ^= 1;
	  LCDcistiXY(0, 1, 7);
    1286:	80 e0       	ldi	r24, 0x00	; 0
    1288:	61 e0       	ldi	r22, 0x01	; 1
    128a:	47 e0       	ldi	r20, 0x07	; 7
    128c:	0e 94 15 03 	call	0x62a	; 0x62a <LCDcistiXY>
    1290:	88 ee       	ldi	r24, 0xE8	; 232
    1292:	93 e0       	ldi	r25, 0x03	; 3
    1294:	fe 01       	movw	r30, r28
    1296:	31 97       	sbiw	r30, 0x01	; 1
    1298:	f1 f7       	brne	.-4      	; 0x1296 <nastav1+0x74>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    129a:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    129c:	d9 f7       	brne	.-10     	; 0x1294 <nastav1+0x72>
	  strcpy(lcd_dis[1],"Zapnute"); 		//doplnene
	  LCDstring(lcd_dis[1], 7);
	}
	if (bit_is_set(PINC, 1)) {	
	  cakaj(1);
	  mon_temp ^= 1;
    129e:	81 e0       	ldi	r24, 0x01	; 1
    12a0:	18 27       	eor	r17, r24
	  LCDcistiXY(0, 1, 7);
	  _delay_ms(100);
	}
	if (bit_is_set(PINC, 2)) {
    12a2:	32 9b       	sbis	0x06, 2	; 6
    12a4:	10 c0       	rjmp	.+32     	; 0x12c6 <nastav1+0xa4>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    12a6:	32 99       	sbic	0x06, 2	; 6
    12a8:	fe cf       	rjmp	.-4      	; 0x12a6 <nastav1+0x84>
	  _delay_ms(100);
	}
	if (bit_is_set(PINC, 2)) {
	  cakaj(2);
	  mon_temp ^= 1;
	  LCDcistiXY(0, 1, 7);
    12aa:	80 e0       	ldi	r24, 0x00	; 0
    12ac:	61 e0       	ldi	r22, 0x01	; 1
    12ae:	47 e0       	ldi	r20, 0x07	; 7
    12b0:	0e 94 15 03 	call	0x62a	; 0x62a <LCDcistiXY>
    12b4:	88 ee       	ldi	r24, 0xE8	; 232
    12b6:	93 e0       	ldi	r25, 0x03	; 3
    12b8:	fe 01       	movw	r30, r28
    12ba:	31 97       	sbiw	r30, 0x01	; 1
    12bc:	f1 f7       	brne	.-4      	; 0x12ba <nastav1+0x98>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    12be:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    12c0:	d9 f7       	brne	.-10     	; 0x12b8 <nastav1+0x96>
	  LCDcistiXY(0, 1, 7);
	  _delay_ms(100);
	}
	if (bit_is_set(PINC, 2)) {
	  cakaj(2);
	  mon_temp ^= 1;
    12c2:	81 e0       	ldi	r24, 0x01	; 1
    12c4:	18 27       	eor	r17, r24
	  LCDcistiXY(0, 1, 7);
	  _delay_ms(100);
	}
	if (bit_is_set(PINC, 0)) {
    12c6:	30 9b       	sbis	0x06, 0	; 6
    12c8:	05 c0       	rjmp	.+10     	; 0x12d4 <nastav1+0xb2>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    12ca:	30 99       	sbic	0x06, 0	; 6
    12cc:	fe cf       	rjmp	.-4      	; 0x12ca <nastav1+0xa8>
	  LCDcistiXY(0, 1, 7);
	  _delay_ms(100);
	}
	if (bit_is_set(PINC, 0)) {
	  cakaj(0);
	  udaje.mon_temp = mon_temp;
    12ce:	10 93 3c 04 	sts	0x043C, r17
    12d2:	04 c0       	rjmp	.+8      	; 0x12dc <nastav1+0xba>
	  break;
	}
	if (bit_is_set(PINC, 4)) {
    12d4:	34 9b       	sbis	0x06, 4	; 6
    12d6:	bd cf       	rjmp	.-134    	; 0x1252 <nastav1+0x30>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    12d8:	34 99       	sbic	0x06, 4	; 6
    12da:	fe cf       	rjmp	.-4      	; 0x12d8 <nastav1+0xb6>
	if (bit_is_set(PINC, 4)) {
	  cakaj(4);
	  return;
	}
  }
}
    12dc:	df 91       	pop	r29
    12de:	cf 91       	pop	r28
    12e0:	1f 91       	pop	r17
    12e2:	08 95       	ret

000012e4 <konfig_hodiny>:
  }
  udaje.mDen = sum;
}
//----------------------------------------------------------------------
void konfig_hodiny(void)
{ 
    12e4:	cf 92       	push	r12
    12e6:	df 92       	push	r13
    12e8:	ff 92       	push	r15
    12ea:	0f 93       	push	r16
    12ec:	1f 93       	push	r17
    12ee:	cf 93       	push	r28
    12f0:	df 93       	push	r29
  char i;

  LCDclr();
    12f2:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <LCDclr>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    12f6:	30 99       	sbic	0x06, 0	; 6
    12f8:	fe cf       	rjmp	.-4      	; 0x12f6 <konfig_hodiny+0x12>
{ 
  char i;

  LCDclr();
  cakaj(0);
  LCDhome();
    12fa:	0e 94 d6 01 	call	0x3ac	; 0x3ac <LCDhome>
  strcpy(lcd_dis[0], "  Hlavne menu   ");	//doplnene
    12fe:	8c ef       	ldi	r24, 0xFC	; 252
    1300:	93 e0       	ldi	r25, 0x03	; 3
    1302:	67 e8       	ldi	r22, 0x87	; 135
    1304:	71 e0       	ldi	r23, 0x01	; 1
    1306:	0e 94 dc 10 	call	0x21b8	; 0x21b8 <strcpy>
  LCDstring(lcd_dis[0], 16);				// prvy riadok vypis Hlavne menu
    130a:	8c ef       	ldi	r24, 0xFC	; 252
    130c:	93 e0       	ldi	r25, 0x03	; 3
    130e:	60 e1       	ldi	r22, 0x10	; 16
    1310:	0e 94 da 01 	call	0x3b4	; 0x3b4 <LCDstring>
  strcpy(lcd_dis[1], menu[0]);			//doplnene
    1314:	60 91 7b 03 	lds	r22, 0x037B
    1318:	70 91 7c 03 	lds	r23, 0x037C
    131c:	8d e0       	ldi	r24, 0x0D	; 13
    131e:	94 e0       	ldi	r25, 0x04	; 4
    1320:	0e 94 dc 10 	call	0x21b8	; 0x21b8 <strcpy>
  LCDstringXY(0, 1, lcd_dis[1], 16);					// na druhy riadok vypis prvu polozku
    1324:	80 e0       	ldi	r24, 0x00	; 0
    1326:	61 e0       	ldi	r22, 0x01	; 1
    1328:	4d e0       	ldi	r20, 0x0D	; 13
    132a:	54 e0       	ldi	r21, 0x04	; 4
    132c:	20 e1       	ldi	r18, 0x10	; 16
    132e:	0e 94 25 03 	call	0x64a	; 0x64a <LCDstringXY>
    1332:	ff 24       	eor	r15, r15
    1334:	68 ec       	ldi	r22, 0xC8	; 200
    1336:	c6 2e       	mov	r12, r22
    1338:	d1 2c       	mov	r13, r1
  for (i = 0; i < 4;) {
	if (bit_is_set(PINC, 1)) {						//tlacitko 1 zvys i (i = aktualna polozka)
    133a:	31 9b       	sbis	0x06, 1	; 6
    133c:	2a c0       	rjmp	.+84     	; 0x1392 <konfig_hodiny+0xae>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    133e:	31 99       	sbic	0x06, 1	; 6
    1340:	fe cf       	rjmp	.-4      	; 0x133e <konfig_hodiny+0x5a>
  strcpy(lcd_dis[1], menu[0]);			//doplnene
  LCDstringXY(0, 1, lcd_dis[1], 16);					// na druhy riadok vypis prvu polozku
  for (i = 0; i < 4;) {
	if (bit_is_set(PINC, 1)) {						//tlacitko 1 zvys i (i = aktualna polozka)
	  cakaj(1);
	  if (++i > 3)
    1342:	f3 94       	inc	r15
    1344:	84 e0       	ldi	r24, 0x04	; 4
    1346:	f8 16       	cp	r15, r24
    1348:	09 f4       	brne	.+2      	; 0x134c <konfig_hodiny+0x68>
    134a:	ff 24       	eor	r15, r15
	    i = 0;
	  LCDcistiXY(1, 1, 16);
    134c:	81 e0       	ldi	r24, 0x01	; 1
    134e:	61 e0       	ldi	r22, 0x01	; 1
    1350:	40 e1       	ldi	r20, 0x10	; 16
    1352:	0e 94 15 03 	call	0x62a	; 0x62a <LCDcistiXY>
    1356:	84 ef       	ldi	r24, 0xF4	; 244
    1358:	91 e0       	ldi	r25, 0x01	; 1
    135a:	f6 01       	movw	r30, r12
    135c:	31 97       	sbiw	r30, 0x01	; 1
    135e:	f1 f7       	brne	.-4      	; 0x135c <konfig_hodiny+0x78>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1360:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1362:	d9 f7       	brne	.-10     	; 0x135a <konfig_hodiny+0x76>
	  _delay_ms(50);
	  strcpy(lcd_dis[1], menu[i]);			//doplnene
    1364:	0f 2d       	mov	r16, r15
    1366:	10 e0       	ldi	r17, 0x00	; 0
    1368:	00 0f       	add	r16, r16
    136a:	11 1f       	adc	r17, r17
    136c:	05 58       	subi	r16, 0x85	; 133
    136e:	1c 4f       	sbci	r17, 0xFC	; 252
    1370:	f8 01       	movw	r30, r16
    1372:	60 81       	ld	r22, Z
    1374:	71 81       	ldd	r23, Z+1	; 0x01
    1376:	8d e0       	ldi	r24, 0x0D	; 13
    1378:	94 e0       	ldi	r25, 0x04	; 4
    137a:	0e 94 dc 10 	call	0x21b8	; 0x21b8 <strcpy>
  	  LCDstringXY(1, 1, &menu[i][1], 16);
    137e:	f8 01       	movw	r30, r16
    1380:	40 81       	ld	r20, Z
    1382:	51 81       	ldd	r21, Z+1	; 0x01
    1384:	4f 5f       	subi	r20, 0xFF	; 255
    1386:	5f 4f       	sbci	r21, 0xFF	; 255
    1388:	81 e0       	ldi	r24, 0x01	; 1
    138a:	61 e0       	ldi	r22, 0x01	; 1
    138c:	20 e1       	ldi	r18, 0x10	; 16
    138e:	0e 94 25 03 	call	0x64a	; 0x64a <LCDstringXY>
	}
	if (bit_is_set(PINC, 2)) {
    1392:	32 9b       	sbis	0x06, 2	; 6
    1394:	27 c0       	rjmp	.+78     	; 0x13e4 <konfig_hodiny+0x100>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    1396:	32 99       	sbic	0x06, 2	; 6
    1398:	fe cf       	rjmp	.-4      	; 0x1396 <konfig_hodiny+0xb2>
	  strcpy(lcd_dis[1], menu[i]);			//doplnene
  	  LCDstringXY(1, 1, &menu[i][1], 16);
	}
	if (bit_is_set(PINC, 2)) {
	  cakaj(2);
	  if (--i > 3)
    139a:	fa 94       	dec	r15
    139c:	f3 e0       	ldi	r31, 0x03	; 3
    139e:	ff 15       	cp	r31, r15
    13a0:	10 f4       	brcc	.+4      	; 0x13a6 <konfig_hodiny+0xc2>
    13a2:	43 e0       	ldi	r20, 0x03	; 3
    13a4:	f4 2e       	mov	r15, r20
	    i = 3;
	  LCDcistiXY(0, 1, 15);
    13a6:	80 e0       	ldi	r24, 0x00	; 0
    13a8:	61 e0       	ldi	r22, 0x01	; 1
    13aa:	4f e0       	ldi	r20, 0x0F	; 15
    13ac:	0e 94 15 03 	call	0x62a	; 0x62a <LCDcistiXY>
    13b0:	84 ef       	ldi	r24, 0xF4	; 244
    13b2:	91 e0       	ldi	r25, 0x01	; 1
    13b4:	f6 01       	movw	r30, r12
    13b6:	31 97       	sbiw	r30, 0x01	; 1
    13b8:	f1 f7       	brne	.-4      	; 0x13b6 <konfig_hodiny+0xd2>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    13ba:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    13bc:	d9 f7       	brne	.-10     	; 0x13b4 <konfig_hodiny+0xd0>
	  _delay_ms(50);
	  strcpy(lcd_dis[1], menu[i]);			//doplnene
    13be:	ef 2d       	mov	r30, r15
    13c0:	f0 e0       	ldi	r31, 0x00	; 0
    13c2:	ee 0f       	add	r30, r30
    13c4:	ff 1f       	adc	r31, r31
    13c6:	e5 58       	subi	r30, 0x85	; 133
    13c8:	fc 4f       	sbci	r31, 0xFC	; 252
    13ca:	60 81       	ld	r22, Z
    13cc:	71 81       	ldd	r23, Z+1	; 0x01
    13ce:	8d e0       	ldi	r24, 0x0D	; 13
    13d0:	94 e0       	ldi	r25, 0x04	; 4
    13d2:	0e 94 dc 10 	call	0x21b8	; 0x21b8 <strcpy>
  	  LCDstringXY(0, 1, lcd_dis[1], 15);
    13d6:	80 e0       	ldi	r24, 0x00	; 0
    13d8:	61 e0       	ldi	r22, 0x01	; 1
    13da:	4d e0       	ldi	r20, 0x0D	; 13
    13dc:	54 e0       	ldi	r21, 0x04	; 4
    13de:	2f e0       	ldi	r18, 0x0F	; 15
    13e0:	0e 94 25 03 	call	0x64a	; 0x64a <LCDstringXY>
	}
	if (bit_is_set(PINC, 0)) {
    13e4:	30 9b       	sbis	0x06, 0	; 6
    13e6:	47 c0       	rjmp	.+142    	; 0x1476 <konfig_hodiny+0x192>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    13e8:	30 99       	sbic	0x06, 0	; 6
    13ea:	fe cf       	rjmp	.-4      	; 0x13e8 <konfig_hodiny+0x104>
	  strcpy(lcd_dis[1], menu[i]);			//doplnene
  	  LCDstringXY(0, 1, lcd_dis[1], 15);
	}
	if (bit_is_set(PINC, 0)) {
	  cakaj(0);
	  LCDclr();
    13ec:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <LCDclr>
	  if (i < 2) { 
    13f0:	81 e0       	ldi	r24, 0x01	; 1
    13f2:	8f 15       	cp	r24, r15
    13f4:	b8 f0       	brcs	.+46     	; 0x1424 <konfig_hodiny+0x140>
	    strcpy(lcd_dis[0], menu[i]);				//doplnene
    13f6:	0f 2d       	mov	r16, r15
    13f8:	10 e0       	ldi	r17, 0x00	; 0
    13fa:	00 0f       	add	r16, r16
    13fc:	11 1f       	adc	r17, r17
    13fe:	05 58       	subi	r16, 0x85	; 133
    1400:	1c 4f       	sbci	r17, 0xFC	; 252
    1402:	f8 01       	movw	r30, r16
    1404:	60 81       	ld	r22, Z
    1406:	71 81       	ldd	r23, Z+1	; 0x01
    1408:	8c ef       	ldi	r24, 0xFC	; 252
    140a:	93 e0       	ldi	r25, 0x03	; 3
    140c:	0e 94 dc 10 	call	0x21b8	; 0x21b8 <strcpy>
	    LCDstringXY(0, 0, &menu[i][1], 14); 
    1410:	f8 01       	movw	r30, r16
    1412:	40 81       	ld	r20, Z
    1414:	51 81       	ldd	r21, Z+1	; 0x01
    1416:	4f 5f       	subi	r20, 0xFF	; 255
    1418:	5f 4f       	sbci	r21, 0xFF	; 255
    141a:	80 e0       	ldi	r24, 0x00	; 0
    141c:	60 e0       	ldi	r22, 0x00	; 0
    141e:	2e e0       	ldi	r18, 0x0E	; 14
    1420:	0e 94 25 03 	call	0x64a	; 0x64a <LCDstringXY>
	  }
	  if (p[i]() != 0) break;
    1424:	cf 2d       	mov	r28, r15
    1426:	d0 e0       	ldi	r29, 0x00	; 0
    1428:	cc 0f       	add	r28, r28
    142a:	dd 1f       	adc	r29, r29
    142c:	fe 01       	movw	r30, r28
    142e:	e1 5d       	subi	r30, 0xD1	; 209
    1430:	fc 4f       	sbci	r31, 0xFC	; 252
    1432:	01 90       	ld	r0, Z+
    1434:	f0 81       	ld	r31, Z
    1436:	e0 2d       	mov	r30, r0
    1438:	09 95       	icall
    143a:	88 23       	and	r24, r24
    143c:	29 f5       	brne	.+74     	; 0x1488 <konfig_hodiny+0x1a4>
	  strcpy(lcd_dis[0], "  Hlavne menu   ");		//doplnene
    143e:	8c ef       	ldi	r24, 0xFC	; 252
    1440:	93 e0       	ldi	r25, 0x03	; 3
    1442:	67 e8       	ldi	r22, 0x87	; 135
    1444:	71 e0       	ldi	r23, 0x01	; 1
    1446:	0e 94 dc 10 	call	0x21b8	; 0x21b8 <strcpy>
  	  LCDstringXY(0, 0, lcd_dis[0], 16);
    144a:	80 e0       	ldi	r24, 0x00	; 0
    144c:	60 e0       	ldi	r22, 0x00	; 0
    144e:	4c ef       	ldi	r20, 0xFC	; 252
    1450:	53 e0       	ldi	r21, 0x03	; 3
    1452:	20 e1       	ldi	r18, 0x10	; 16
    1454:	0e 94 25 03 	call	0x64a	; 0x64a <LCDstringXY>
	  strcpy(lcd_dis[1], menu[i]);
    1458:	c5 58       	subi	r28, 0x85	; 133
    145a:	dc 4f       	sbci	r29, 0xFC	; 252
    145c:	68 81       	ld	r22, Y
    145e:	79 81       	ldd	r23, Y+1	; 0x01
    1460:	8d e0       	ldi	r24, 0x0D	; 13
    1462:	94 e0       	ldi	r25, 0x04	; 4
    1464:	0e 94 dc 10 	call	0x21b8	; 0x21b8 <strcpy>
	  LCDstringXY(0, 1, lcd_dis[1], 16);
    1468:	80 e0       	ldi	r24, 0x00	; 0
    146a:	61 e0       	ldi	r22, 0x01	; 1
    146c:	4d e0       	ldi	r20, 0x0D	; 13
    146e:	54 e0       	ldi	r21, 0x04	; 4
    1470:	20 e1       	ldi	r18, 0x10	; 16
    1472:	0e 94 25 03 	call	0x64a	; 0x64a <LCDstringXY>
	}
	if (bit_is_set(PINC, 4)) {
    1476:	34 9b       	sbis	0x06, 4	; 6
    1478:	03 c0       	rjmp	.+6      	; 0x1480 <konfig_hodiny+0x19c>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    147a:	34 99       	sbic	0x06, 4	; 6
    147c:	fe cf       	rjmp	.-4      	; 0x147a <konfig_hodiny+0x196>
    147e:	04 c0       	rjmp	.+8      	; 0x1488 <konfig_hodiny+0x1a4>
  LCDhome();
  strcpy(lcd_dis[0], "  Hlavne menu   ");	//doplnene
  LCDstring(lcd_dis[0], 16);				// prvy riadok vypis Hlavne menu
  strcpy(lcd_dis[1], menu[0]);			//doplnene
  LCDstringXY(0, 1, lcd_dis[1], 16);					// na druhy riadok vypis prvu polozku
  for (i = 0; i < 4;) {
    1480:	f3 e0       	ldi	r31, 0x03	; 3
    1482:	ff 15       	cp	r31, r15
    1484:	08 f0       	brcs	.+2      	; 0x1488 <konfig_hodiny+0x1a4>
    1486:	59 cf       	rjmp	.-334    	; 0x133a <konfig_hodiny+0x56>
	if (bit_is_set(PINC, 4)) {
	  cakaj(4);
	  return;
	}
  }
}
    1488:	df 91       	pop	r29
    148a:	cf 91       	pop	r28
    148c:	1f 91       	pop	r17
    148e:	0f 91       	pop	r16
    1490:	ff 90       	pop	r15
    1492:	df 90       	pop	r13
    1494:	cf 90       	pop	r12
    1496:	08 95       	ret

00001498 <ansi_cl>:
}
//----------------------------------------------------------------------
void ansi_cl(void)
{
  // ANSI clear screen: cl=\E[H\E[J
  putchar(27);
    1498:	60 91 4f 04 	lds	r22, 0x044F
    149c:	70 91 50 04 	lds	r23, 0x0450
    14a0:	8b e1       	ldi	r24, 0x1B	; 27
    14a2:	90 e0       	ldi	r25, 0x00	; 0
    14a4:	0e 94 e3 10 	call	0x21c6	; 0x21c6 <fputc>
  putchar('[');
    14a8:	60 91 4f 04 	lds	r22, 0x044F
    14ac:	70 91 50 04 	lds	r23, 0x0450
    14b0:	8b e5       	ldi	r24, 0x5B	; 91
    14b2:	90 e0       	ldi	r25, 0x00	; 0
    14b4:	0e 94 e3 10 	call	0x21c6	; 0x21c6 <fputc>
  putchar('H');
    14b8:	60 91 4f 04 	lds	r22, 0x044F
    14bc:	70 91 50 04 	lds	r23, 0x0450
    14c0:	88 e4       	ldi	r24, 0x48	; 72
    14c2:	90 e0       	ldi	r25, 0x00	; 0
    14c4:	0e 94 e3 10 	call	0x21c6	; 0x21c6 <fputc>
  putchar(27);
    14c8:	60 91 4f 04 	lds	r22, 0x044F
    14cc:	70 91 50 04 	lds	r23, 0x0450
    14d0:	8b e1       	ldi	r24, 0x1B	; 27
    14d2:	90 e0       	ldi	r25, 0x00	; 0
    14d4:	0e 94 e3 10 	call	0x21c6	; 0x21c6 <fputc>
  putchar('[');
    14d8:	60 91 4f 04 	lds	r22, 0x044F
    14dc:	70 91 50 04 	lds	r23, 0x0450
    14e0:	8b e5       	ldi	r24, 0x5B	; 91
    14e2:	90 e0       	ldi	r25, 0x00	; 0
    14e4:	0e 94 e3 10 	call	0x21c6	; 0x21c6 <fputc>
  putchar('J');
    14e8:	60 91 4f 04 	lds	r22, 0x044F
    14ec:	70 91 50 04 	lds	r23, 0x0450
    14f0:	8a e4       	ldi	r24, 0x4A	; 74
    14f2:	90 e0       	ldi	r25, 0x00	; 0
    14f4:	0e 94 e3 10 	call	0x21c6	; 0x21c6 <fputc>
}
    14f8:	08 95       	ret

000014fa <ansi_cm>:
//----------------------------------------------------------------------

void ansi_cm(unsigned char row,unsigned char col)
{
    14fa:	ef 92       	push	r14
    14fc:	ff 92       	push	r15
    14fe:	0f 93       	push	r16
    1500:	1f 93       	push	r17
    1502:	f8 2e       	mov	r15, r24
    1504:	e6 2e       	mov	r14, r22
  // ANSI cursor movement: cl=\E%row;%colH
  putchar(27);
    1506:	60 91 4f 04 	lds	r22, 0x044F
    150a:	70 91 50 04 	lds	r23, 0x0450
    150e:	8b e1       	ldi	r24, 0x1B	; 27
    1510:	90 e0       	ldi	r25, 0x00	; 0
    1512:	0e 94 e3 10 	call	0x21c6	; 0x21c6 <fputc>
  putchar('[');
    1516:	60 91 4f 04 	lds	r22, 0x044F
    151a:	70 91 50 04 	lds	r23, 0x0450
    151e:	8b e5       	ldi	r24, 0x5B	; 91
    1520:	90 e0       	ldi	r25, 0x00	; 0
    1522:	0e 94 e3 10 	call	0x21c6	; 0x21c6 <fputc>
  printf("%d",row);
    1526:	00 d0       	rcall	.+0      	; 0x1528 <ansi_cm+0x2e>
    1528:	00 d0       	rcall	.+0      	; 0x152a <ansi_cm+0x30>
    152a:	ed b7       	in	r30, 0x3d	; 61
    152c:	fe b7       	in	r31, 0x3e	; 62
    152e:	31 96       	adiw	r30, 0x01	; 1
    1530:	08 e9       	ldi	r16, 0x98	; 152
    1532:	11 e0       	ldi	r17, 0x01	; 1
    1534:	ad b7       	in	r26, 0x3d	; 61
    1536:	be b7       	in	r27, 0x3e	; 62
    1538:	12 96       	adiw	r26, 0x02	; 2
    153a:	1c 93       	st	X, r17
    153c:	0e 93       	st	-X, r16
    153e:	11 97       	sbiw	r26, 0x01	; 1
    1540:	f2 82       	std	Z+2, r15	; 0x02
    1542:	13 82       	std	Z+3, r1	; 0x03
    1544:	0e 94 0f 11 	call	0x221e	; 0x221e <printf>
  putchar(';');
    1548:	0f 90       	pop	r0
    154a:	0f 90       	pop	r0
    154c:	0f 90       	pop	r0
    154e:	0f 90       	pop	r0
    1550:	60 91 4f 04 	lds	r22, 0x044F
    1554:	70 91 50 04 	lds	r23, 0x0450
    1558:	8b e3       	ldi	r24, 0x3B	; 59
    155a:	90 e0       	ldi	r25, 0x00	; 0
    155c:	0e 94 e3 10 	call	0x21c6	; 0x21c6 <fputc>
  printf("%d",col);
    1560:	00 d0       	rcall	.+0      	; 0x1562 <ansi_cm+0x68>
    1562:	00 d0       	rcall	.+0      	; 0x1564 <ansi_cm+0x6a>
    1564:	ed b7       	in	r30, 0x3d	; 61
    1566:	fe b7       	in	r31, 0x3e	; 62
    1568:	31 96       	adiw	r30, 0x01	; 1
    156a:	ad b7       	in	r26, 0x3d	; 61
    156c:	be b7       	in	r27, 0x3e	; 62
    156e:	12 96       	adiw	r26, 0x02	; 2
    1570:	1c 93       	st	X, r17
    1572:	0e 93       	st	-X, r16
    1574:	11 97       	sbiw	r26, 0x01	; 1
    1576:	e2 82       	std	Z+2, r14	; 0x02
    1578:	13 82       	std	Z+3, r1	; 0x03
    157a:	0e 94 0f 11 	call	0x221e	; 0x221e <printf>
  putchar('H');
    157e:	0f 90       	pop	r0
    1580:	0f 90       	pop	r0
    1582:	0f 90       	pop	r0
    1584:	0f 90       	pop	r0
    1586:	60 91 4f 04 	lds	r22, 0x044F
    158a:	70 91 50 04 	lds	r23, 0x0450
    158e:	88 e4       	ldi	r24, 0x48	; 72
    1590:	90 e0       	ldi	r25, 0x00	; 0
    1592:	0e 94 e3 10 	call	0x21c6	; 0x21c6 <fputc>
}
    1596:	1f 91       	pop	r17
    1598:	0f 91       	pop	r16
    159a:	ff 90       	pop	r15
    159c:	ef 90       	pop	r14
    159e:	08 95       	ret

000015a0 <nastav4>:
  alarm.clock = _clock;
  LCDcursorOFF();cursor = 0;
}
//----------------------------------------------------------------------
void nastav4(void)
{
    15a0:	af 92       	push	r10
    15a2:	bf 92       	push	r11
    15a4:	cf 92       	push	r12
    15a6:	df 92       	push	r13
    15a8:	ef 92       	push	r14
    15aa:	ff 92       	push	r15
    15ac:	0f 93       	push	r16
    15ae:	1f 93       	push	r17
    15b0:	df 93       	push	r29
    15b2:	cf 93       	push	r28
    15b4:	00 d0       	rcall	.+0      	; 0x15b6 <nastav4+0x16>
    15b6:	cd b7       	in	r28, 0x3d	; 61
    15b8:	de b7       	in	r29, 0x3e	; 62
  char _temp, _altemp;

  _temp = alarm.temp;
    15ba:	d0 90 24 04 	lds	r13, 0x0424
  LCDclr();
    15be:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <LCDclr>
  strcpy(lcd_dis[0], "Teplota: ");			//doplnene
    15c2:	8c ef       	ldi	r24, 0xFC	; 252
    15c4:	93 e0       	ldi	r25, 0x03	; 3
    15c6:	6b e9       	ldi	r22, 0x9B	; 155
    15c8:	71 e0       	ldi	r23, 0x01	; 1
    15ca:	0e 94 dc 10 	call	0x21b8	; 0x21b8 <strcpy>
  strcpy(lcd_dis[1], "                ");
    15ce:	1d e0       	ldi	r17, 0x0D	; 13
    15d0:	e1 2e       	mov	r14, r17
    15d2:	14 e0       	ldi	r17, 0x04	; 4
    15d4:	f1 2e       	mov	r15, r17
    15d6:	c7 01       	movw	r24, r14
    15d8:	64 e2       	ldi	r22, 0x24	; 36
    15da:	71 e0       	ldi	r23, 0x01	; 1
    15dc:	0e 94 dc 10 	call	0x21b8	; 0x21b8 <strcpy>
  LCDstringXY(0, 0, lcd_dis[0], 9);
    15e0:	80 e0       	ldi	r24, 0x00	; 0
    15e2:	60 e0       	ldi	r22, 0x00	; 0
    15e4:	a7 01       	movw	r20, r14
    15e6:	41 51       	subi	r20, 0x11	; 17
    15e8:	50 40       	sbci	r21, 0x00	; 0
    15ea:	29 e0       	ldi	r18, 0x09	; 9
    15ec:	0e 94 25 03 	call	0x64a	; 0x64a <LCDstringXY>
    15f0:	b8 ec       	ldi	r27, 0xC8	; 200
    15f2:	ab 2e       	mov	r10, r27
    15f4:	b1 2c       	mov	r11, r1
	  strcpy(lcd_dis[0], "Teplota: Zapnute");	//doplnene
	  LCDstringXY(0, 0, lcd_dis[0], 16); 
	}
    if (bit_is_set(PINC, 1)) {
      cakaj(1);
	  _temp ^= 1;				// zakazat/povolit alram pre teplotu
    15f6:	11 e0       	ldi	r17, 0x01	; 1
  LCDclr();
  strcpy(lcd_dis[0], "Teplota: ");			//doplnene
  strcpy(lcd_dis[1], "                ");
  LCDstringXY(0, 0, lcd_dis[0], 9);
  while (1) {
    if (_temp == 0) {
    15f8:	dd 20       	and	r13, r13
    15fa:	29 f4       	brne	.+10     	; 0x1606 <nastav4+0x66>
	  strcpy(lcd_dis[0], "Teplota: Vypnute");	//doplnene
    15fc:	8c ef       	ldi	r24, 0xFC	; 252
    15fe:	93 e0       	ldi	r25, 0x03	; 3
    1600:	65 ea       	ldi	r22, 0xA5	; 165
    1602:	71 e0       	ldi	r23, 0x01	; 1
    1604:	04 c0       	rjmp	.+8      	; 0x160e <nastav4+0x6e>
	  LCDstringXY(0, 0, lcd_dis[0], 16);
	}
    else {
	  strcpy(lcd_dis[0], "Teplota: Zapnute");	//doplnene
    1606:	8c ef       	ldi	r24, 0xFC	; 252
    1608:	93 e0       	ldi	r25, 0x03	; 3
    160a:	66 eb       	ldi	r22, 0xB6	; 182
    160c:	71 e0       	ldi	r23, 0x01	; 1
    160e:	0e 94 dc 10 	call	0x21b8	; 0x21b8 <strcpy>
	  LCDstringXY(0, 0, lcd_dis[0], 16); 
    1612:	80 e0       	ldi	r24, 0x00	; 0
    1614:	60 e0       	ldi	r22, 0x00	; 0
    1616:	4c ef       	ldi	r20, 0xFC	; 252
    1618:	53 e0       	ldi	r21, 0x03	; 3
    161a:	20 e1       	ldi	r18, 0x10	; 16
    161c:	0e 94 25 03 	call	0x64a	; 0x64a <LCDstringXY>
	}
    if (bit_is_set(PINC, 1)) {
    1620:	31 9b       	sbis	0x06, 1	; 6
    1622:	0f c0       	rjmp	.+30     	; 0x1642 <nastav4+0xa2>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    1624:	31 99       	sbic	0x06, 1	; 6
    1626:	fe cf       	rjmp	.-4      	; 0x1624 <nastav4+0x84>
	  LCDstringXY(0, 0, lcd_dis[0], 16); 
	}
    if (bit_is_set(PINC, 1)) {
      cakaj(1);
	  _temp ^= 1;				// zakazat/povolit alram pre teplotu
	  LCDcistiXY(9, 0, 7);
    1628:	89 e0       	ldi	r24, 0x09	; 9
    162a:	60 e0       	ldi	r22, 0x00	; 0
    162c:	47 e0       	ldi	r20, 0x07	; 7
    162e:	0e 94 15 03 	call	0x62a	; 0x62a <LCDcistiXY>
    1632:	80 e2       	ldi	r24, 0x20	; 32
    1634:	93 e0       	ldi	r25, 0x03	; 3
    1636:	f5 01       	movw	r30, r10
    1638:	31 97       	sbiw	r30, 0x01	; 1
    163a:	f1 f7       	brne	.-4      	; 0x1638 <nastav4+0x98>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    163c:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    163e:	d9 f7       	brne	.-10     	; 0x1636 <nastav4+0x96>
	  strcpy(lcd_dis[0], "Teplota: Zapnute");	//doplnene
	  LCDstringXY(0, 0, lcd_dis[0], 16); 
	}
    if (bit_is_set(PINC, 1)) {
      cakaj(1);
	  _temp ^= 1;				// zakazat/povolit alram pre teplotu
    1640:	d1 26       	eor	r13, r17
	  LCDcistiXY(9, 0, 7);
	  _delay_ms(80);
    }
	if (bit_is_set(PINC, 2)) {
    1642:	32 9b       	sbis	0x06, 2	; 6
    1644:	0f c0       	rjmp	.+30     	; 0x1664 <nastav4+0xc4>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    1646:	32 99       	sbic	0x06, 2	; 6
    1648:	fe cf       	rjmp	.-4      	; 0x1646 <nastav4+0xa6>
	  _delay_ms(80);
    }
	if (bit_is_set(PINC, 2)) {
      cakaj(2);
	  _temp ^= 1;				// zakazat/povolit alram pre teplotu
	  LCDcistiXY(9, 0, 7);
    164a:	89 e0       	ldi	r24, 0x09	; 9
    164c:	60 e0       	ldi	r22, 0x00	; 0
    164e:	47 e0       	ldi	r20, 0x07	; 7
    1650:	0e 94 15 03 	call	0x62a	; 0x62a <LCDcistiXY>
    1654:	80 e2       	ldi	r24, 0x20	; 32
    1656:	93 e0       	ldi	r25, 0x03	; 3
    1658:	f5 01       	movw	r30, r10
    165a:	31 97       	sbiw	r30, 0x01	; 1
    165c:	f1 f7       	brne	.-4      	; 0x165a <nastav4+0xba>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    165e:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1660:	d9 f7       	brne	.-10     	; 0x1658 <nastav4+0xb8>
	  LCDcistiXY(9, 0, 7);
	  _delay_ms(80);
    }
	if (bit_is_set(PINC, 2)) {
      cakaj(2);
	  _temp ^= 1;				// zakazat/povolit alram pre teplotu
    1662:	d1 26       	eor	r13, r17
	  LCDcistiXY(9, 0, 7);
	  _delay_ms(80);
    }
    if (bit_is_set(PINC, 0)) {
    1664:	30 9b       	sbis	0x06, 0	; 6
    1666:	06 c0       	rjmp	.+12     	; 0x1674 <nastav4+0xd4>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    1668:	30 99       	sbic	0x06, 0	; 6
    166a:	fe cf       	rjmp	.-4      	; 0x1668 <nastav4+0xc8>
	if (bit_is_set(PINC, 4)) {
	  cakaj(4);
	  return;
	}
  }
  if (_temp != 0) {
    166c:	dd 20       	and	r13, r13
    166e:	09 f4       	brne	.+2      	; 0x1672 <nastav4+0xd2>
    1670:	aa c0       	rjmp	.+340    	; 0x17c6 <nastav4+0x226>
    1672:	05 c0       	rjmp	.+10     	; 0x167e <nastav4+0xde>
    }
    if (bit_is_set(PINC, 0)) {
      cakaj(0);
	  break;
    }
	if (bit_is_set(PINC, 4)) {
    1674:	34 9b       	sbis	0x06, 4	; 6
    1676:	c0 cf       	rjmp	.-128    	; 0x15f8 <nastav4+0x58>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    1678:	34 99       	sbic	0x06, 4	; 6
    167a:	fe cf       	rjmp	.-4      	; 0x1678 <nastav4+0xd8>
    167c:	a6 c0       	rjmp	.+332    	; 0x17ca <nastav4+0x22a>
	  cakaj(4);
	  return;
	}
  }
  if (_temp != 0) {
    _altemp = p_alarm[3];
    167e:	e0 91 6b 02 	lds	r30, 0x026B
    1682:	f0 91 6c 02 	lds	r31, 0x026C
    1686:	03 81       	ldd	r16, Z+3	; 0x03
    sprintf(lcd_dis[1], "%02d\xdf", _altemp);			//doplnene
    1688:	00 d0       	rcall	.+0      	; 0x168a <nastav4+0xea>
    168a:	00 d0       	rcall	.+0      	; 0x168c <nastav4+0xec>
    168c:	00 d0       	rcall	.+0      	; 0x168e <nastav4+0xee>
    168e:	ed b7       	in	r30, 0x3d	; 61
    1690:	fe b7       	in	r31, 0x3e	; 62
    1692:	31 96       	adiw	r30, 0x01	; 1
    1694:	ad b7       	in	r26, 0x3d	; 61
    1696:	be b7       	in	r27, 0x3e	; 62
    1698:	12 96       	adiw	r26, 0x02	; 2
    169a:	fc 92       	st	X, r15
    169c:	ee 92       	st	-X, r14
    169e:	11 97       	sbiw	r26, 0x01	; 1
    16a0:	a7 ec       	ldi	r26, 0xC7	; 199
    16a2:	aa 2e       	mov	r10, r26
    16a4:	a1 e0       	ldi	r26, 0x01	; 1
    16a6:	ba 2e       	mov	r11, r26
    16a8:	b3 82       	std	Z+3, r11	; 0x03
    16aa:	a2 82       	std	Z+2, r10	; 0x02
    16ac:	04 83       	std	Z+4, r16	; 0x04
    16ae:	15 82       	std	Z+5, r1	; 0x05
    16b0:	0e 94 24 11 	call	0x2248	; 0x2248 <sprintf>
    LCDstringXY(0, 1, lcd_dis[1], 3); LCDsendChar('C');
    16b4:	ed b7       	in	r30, 0x3d	; 61
    16b6:	fe b7       	in	r31, 0x3e	; 62
    16b8:	36 96       	adiw	r30, 0x06	; 6
    16ba:	0f b6       	in	r0, 0x3f	; 63
    16bc:	f8 94       	cli
    16be:	fe bf       	out	0x3e, r31	; 62
    16c0:	0f be       	out	0x3f, r0	; 63
    16c2:	ed bf       	out	0x3d, r30	; 61
    16c4:	80 e0       	ldi	r24, 0x00	; 0
    16c6:	61 e0       	ldi	r22, 0x01	; 1
    16c8:	a7 01       	movw	r20, r14
    16ca:	23 e0       	ldi	r18, 0x03	; 3
    16cc:	0e 94 25 03 	call	0x64a	; 0x64a <LCDstringXY>
    16d0:	83 e4       	ldi	r24, 0x43	; 67
    16d2:	0e 94 5c 01 	call	0x2b8	; 0x2b8 <LCDsendChar>
    while (1) {
	  if (bit_is_set(PINC, 1)) {
	    if (_altemp < 70)
	      _altemp++;
	    else _altemp = 0;
	    sprintf(lcd_dis[1], "%02d\xdf", _altemp);		//doplnene
    16d6:	ba 82       	std	Y+2, r11	; 0x02
    16d8:	a9 82       	std	Y+1, r10	; 0x01
    16da:	c9 80       	ldd	r12, Y+1	; 0x01
    16dc:	1a 81       	ldd	r17, Y+2	; 0x02
    16de:	78 ec       	ldi	r23, 0xC8	; 200
    16e0:	a7 2e       	mov	r10, r23
    16e2:	b1 2c       	mov	r11, r1
  if (_temp != 0) {
    _altemp = p_alarm[3];
    sprintf(lcd_dis[1], "%02d\xdf", _altemp);			//doplnene
    LCDstringXY(0, 1, lcd_dis[1], 3); LCDsendChar('C');
    while (1) {
	  if (bit_is_set(PINC, 1)) {
    16e4:	31 9b       	sbis	0x06, 1	; 6
    16e6:	2f c0       	rjmp	.+94     	; 0x1746 <nastav4+0x1a6>
	    if (_altemp < 70)
    16e8:	06 34       	cpi	r16, 0x46	; 70
    16ea:	10 f0       	brcs	.+4      	; 0x16f0 <nastav4+0x150>
    16ec:	00 e0       	ldi	r16, 0x00	; 0
    16ee:	01 c0       	rjmp	.+2      	; 0x16f2 <nastav4+0x152>
	      _altemp++;
    16f0:	0f 5f       	subi	r16, 0xFF	; 255
	    else _altemp = 0;
	    sprintf(lcd_dis[1], "%02d\xdf", _altemp);		//doplnene
    16f2:	00 d0       	rcall	.+0      	; 0x16f4 <nastav4+0x154>
    16f4:	00 d0       	rcall	.+0      	; 0x16f6 <nastav4+0x156>
    16f6:	00 d0       	rcall	.+0      	; 0x16f8 <nastav4+0x158>
    16f8:	ed b7       	in	r30, 0x3d	; 61
    16fa:	fe b7       	in	r31, 0x3e	; 62
    16fc:	31 96       	adiw	r30, 0x01	; 1
    16fe:	ad b7       	in	r26, 0x3d	; 61
    1700:	be b7       	in	r27, 0x3e	; 62
    1702:	12 96       	adiw	r26, 0x02	; 2
    1704:	fc 92       	st	X, r15
    1706:	ee 92       	st	-X, r14
    1708:	11 97       	sbiw	r26, 0x01	; 1
    170a:	c2 82       	std	Z+2, r12	; 0x02
    170c:	13 83       	std	Z+3, r17	; 0x03
    170e:	04 83       	std	Z+4, r16	; 0x04
    1710:	15 82       	std	Z+5, r1	; 0x05
    1712:	0e 94 24 11 	call	0x2248	; 0x2248 <sprintf>
  	    LCDstringXY(0, 1, lcd_dis[1], 3); LCDsendChar('C');
    1716:	ed b7       	in	r30, 0x3d	; 61
    1718:	fe b7       	in	r31, 0x3e	; 62
    171a:	36 96       	adiw	r30, 0x06	; 6
    171c:	0f b6       	in	r0, 0x3f	; 63
    171e:	f8 94       	cli
    1720:	fe bf       	out	0x3e, r31	; 62
    1722:	0f be       	out	0x3f, r0	; 63
    1724:	ed bf       	out	0x3d, r30	; 61
    1726:	80 e0       	ldi	r24, 0x00	; 0
    1728:	61 e0       	ldi	r22, 0x01	; 1
    172a:	a7 01       	movw	r20, r14
    172c:	23 e0       	ldi	r18, 0x03	; 3
    172e:	0e 94 25 03 	call	0x64a	; 0x64a <LCDstringXY>
    1732:	83 e4       	ldi	r24, 0x43	; 67
    1734:	0e 94 5c 01 	call	0x2b8	; 0x2b8 <LCDsendChar>
    1738:	88 ee       	ldi	r24, 0xE8	; 232
    173a:	93 e0       	ldi	r25, 0x03	; 3
    173c:	f5 01       	movw	r30, r10
    173e:	31 97       	sbiw	r30, 0x01	; 1
    1740:	f1 f7       	brne	.-4      	; 0x173e <nastav4+0x19e>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1742:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1744:	d9 f7       	brne	.-10     	; 0x173c <nastav4+0x19c>
	    _delay_ms(100);
	  }
	  if (bit_is_set(PINC, 2)) {
    1746:	32 9b       	sbis	0x06, 2	; 6
    1748:	2f c0       	rjmp	.+94     	; 0x17a8 <nastav4+0x208>
	    if (_altemp > 0)
    174a:	00 23       	and	r16, r16
    174c:	11 f4       	brne	.+4      	; 0x1752 <nastav4+0x1b2>
    174e:	06 e4       	ldi	r16, 0x46	; 70
    1750:	01 c0       	rjmp	.+2      	; 0x1754 <nastav4+0x1b4>
	      _altemp--;
    1752:	01 50       	subi	r16, 0x01	; 1
	    else _altemp = 70;
	    sprintf(lcd_dis[1], "%02d\xdf", _altemp);		//doplnene
    1754:	00 d0       	rcall	.+0      	; 0x1756 <nastav4+0x1b6>
    1756:	00 d0       	rcall	.+0      	; 0x1758 <nastav4+0x1b8>
    1758:	00 d0       	rcall	.+0      	; 0x175a <nastav4+0x1ba>
    175a:	ed b7       	in	r30, 0x3d	; 61
    175c:	fe b7       	in	r31, 0x3e	; 62
    175e:	31 96       	adiw	r30, 0x01	; 1
    1760:	ad b7       	in	r26, 0x3d	; 61
    1762:	be b7       	in	r27, 0x3e	; 62
    1764:	12 96       	adiw	r26, 0x02	; 2
    1766:	fc 92       	st	X, r15
    1768:	ee 92       	st	-X, r14
    176a:	11 97       	sbiw	r26, 0x01	; 1
    176c:	c2 82       	std	Z+2, r12	; 0x02
    176e:	13 83       	std	Z+3, r17	; 0x03
    1770:	04 83       	std	Z+4, r16	; 0x04
    1772:	15 82       	std	Z+5, r1	; 0x05
    1774:	0e 94 24 11 	call	0x2248	; 0x2248 <sprintf>
  	    LCDstringXY(0, 1, lcd_dis[1], 3); LCDsendChar('C');
    1778:	ed b7       	in	r30, 0x3d	; 61
    177a:	fe b7       	in	r31, 0x3e	; 62
    177c:	36 96       	adiw	r30, 0x06	; 6
    177e:	0f b6       	in	r0, 0x3f	; 63
    1780:	f8 94       	cli
    1782:	fe bf       	out	0x3e, r31	; 62
    1784:	0f be       	out	0x3f, r0	; 63
    1786:	ed bf       	out	0x3d, r30	; 61
    1788:	80 e0       	ldi	r24, 0x00	; 0
    178a:	61 e0       	ldi	r22, 0x01	; 1
    178c:	a7 01       	movw	r20, r14
    178e:	23 e0       	ldi	r18, 0x03	; 3
    1790:	0e 94 25 03 	call	0x64a	; 0x64a <LCDstringXY>
    1794:	83 e4       	ldi	r24, 0x43	; 67
    1796:	0e 94 5c 01 	call	0x2b8	; 0x2b8 <LCDsendChar>
    179a:	88 ee       	ldi	r24, 0xE8	; 232
    179c:	93 e0       	ldi	r25, 0x03	; 3
    179e:	f5 01       	movw	r30, r10
    17a0:	31 97       	sbiw	r30, 0x01	; 1
    17a2:	f1 f7       	brne	.-4      	; 0x17a0 <nastav4+0x200>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    17a4:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    17a6:	d9 f7       	brne	.-10     	; 0x179e <nastav4+0x1fe>
	    _delay_ms(100);
	  }
	  if (bit_is_set(PINC, 0)) {
    17a8:	30 9b       	sbis	0x06, 0	; 6
    17aa:	08 c0       	rjmp	.+16     	; 0x17bc <nastav4+0x21c>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    17ac:	30 99       	sbic	0x06, 0	; 6
    17ae:	fe cf       	rjmp	.-4      	; 0x17ac <nastav4+0x20c>
	  if (bit_is_set(PINC, 4)) {
	    cakaj(4);
		return;
	  }
    }
	p_alarm[3] = _altemp;
    17b0:	e0 91 6b 02 	lds	r30, 0x026B
    17b4:	f0 91 6c 02 	lds	r31, 0x026C
    17b8:	03 83       	std	Z+3, r16	; 0x03
    17ba:	05 c0       	rjmp	.+10     	; 0x17c6 <nastav4+0x226>
	  }
	  if (bit_is_set(PINC, 0)) {
	    cakaj(0);
	    break;
	  }
	  if (bit_is_set(PINC, 4)) {
    17bc:	34 9b       	sbis	0x06, 4	; 6
    17be:	92 cf       	rjmp	.-220    	; 0x16e4 <nastav4+0x144>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    17c0:	34 99       	sbic	0x06, 4	; 6
    17c2:	fe cf       	rjmp	.-4      	; 0x17c0 <nastav4+0x220>
    17c4:	02 c0       	rjmp	.+4      	; 0x17ca <nastav4+0x22a>
		return;
	  }
    }
	p_alarm[3] = _altemp;
  }
  alarm.temp = _temp;
    17c6:	d0 92 24 04 	sts	0x0424, r13
}
    17ca:	0f 90       	pop	r0
    17cc:	0f 90       	pop	r0
    17ce:	cf 91       	pop	r28
    17d0:	df 91       	pop	r29
    17d2:	1f 91       	pop	r17
    17d4:	0f 91       	pop	r16
    17d6:	ff 90       	pop	r15
    17d8:	ef 90       	pop	r14
    17da:	df 90       	pop	r13
    17dc:	cf 90       	pop	r12
    17de:	bf 90       	pop	r11
    17e0:	af 90       	pop	r10
    17e2:	08 95       	ret

000017e4 <nastav3>:
	}
  }
}
//----------------------------------------------------------------------
void nastav3(void)
{
    17e4:	6f 92       	push	r6
    17e6:	7f 92       	push	r7
    17e8:	8f 92       	push	r8
    17ea:	9f 92       	push	r9
    17ec:	af 92       	push	r10
    17ee:	bf 92       	push	r11
    17f0:	cf 92       	push	r12
    17f2:	df 92       	push	r13
    17f4:	ef 92       	push	r14
    17f6:	ff 92       	push	r15
    17f8:	0f 93       	push	r16
    17fa:	1f 93       	push	r17
    17fc:	df 93       	push	r29
    17fe:	cf 93       	push	r28
    1800:	00 d0       	rcall	.+0      	; 0x1802 <nastav3+0x1e>
    1802:	0f 92       	push	r0
    1804:	cd b7       	in	r28, 0x3d	; 61
    1806:	de b7       	in	r29, 0x3e	; 62
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    1808:	30 99       	sbic	0x06, 0	; 6
    180a:	fe cf       	rjmp	.-4      	; 0x1808 <nastav3+0x24>
{
  unsigned char i, _clock;
  char _alarm[3];

  cakaj(0);
  _clock = alarm.clock;
    180c:	e0 90 25 04 	lds	r14, 0x0425
  LCDclr();
    1810:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <LCDclr>
  strcpy(lcd_dis[0], "Cas: ");		//doplnene
    1814:	8c ef       	ldi	r24, 0xFC	; 252
    1816:	93 e0       	ldi	r25, 0x03	; 3
    1818:	6d ec       	ldi	r22, 0xCD	; 205
    181a:	71 e0       	ldi	r23, 0x01	; 1
    181c:	0e 94 dc 10 	call	0x21b8	; 0x21b8 <strcpy>
  strcpy(lcd_dis[1], "               ");
    1820:	2d e0       	ldi	r18, 0x0D	; 13
    1822:	c2 2e       	mov	r12, r18
    1824:	24 e0       	ldi	r18, 0x04	; 4
    1826:	d2 2e       	mov	r13, r18
    1828:	c6 01       	movw	r24, r12
    182a:	63 ed       	ldi	r22, 0xD3	; 211
    182c:	71 e0       	ldi	r23, 0x01	; 1
    182e:	0e 94 dc 10 	call	0x21b8	; 0x21b8 <strcpy>
  LCDstringXY(0,0,lcd_dis[0], 5);		// tato funkcia je volana z funkcie nastav2(), sluzi pre nastavenie alarmu - casu
    1832:	80 e0       	ldi	r24, 0x00	; 0
    1834:	60 e0       	ldi	r22, 0x00	; 0
    1836:	a6 01       	movw	r20, r12
    1838:	41 51       	subi	r20, 0x11	; 17
    183a:	50 40       	sbci	r21, 0x00	; 0
    183c:	25 e0       	ldi	r18, 0x05	; 5
    183e:	0e 94 25 03 	call	0x64a	; 0x64a <LCDstringXY>
    1842:	08 ec       	ldi	r16, 0xC8	; 200
    1844:	10 e0       	ldi	r17, 0x00	; 0
	  strcpy(lcd_dis[0], "Cas: Zapnute");	//doplnene
	  LCDstringXY(0,0,lcd_dis[0], 12); 
	}
	if (bit_is_set(PINC, 1)) {
	  cakaj(1);
	  _clock ^= 1;					// zakazat/povolit alram pre cas
    1846:	ff 24       	eor	r15, r15
    1848:	f3 94       	inc	r15
  LCDclr();
  strcpy(lcd_dis[0], "Cas: ");		//doplnene
  strcpy(lcd_dis[1], "               ");
  LCDstringXY(0,0,lcd_dis[0], 5);		// tato funkcia je volana z funkcie nastav2(), sluzi pre nastavenie alarmu - casu
  while (1) {
    if (_clock == 0) {
    184a:	ee 20       	and	r14, r14
    184c:	29 f4       	brne	.+10     	; 0x1858 <nastav3+0x74>
	  strcpy(lcd_dis[0], "Cas: Vypnute");	//doplnene
    184e:	8c ef       	ldi	r24, 0xFC	; 252
    1850:	93 e0       	ldi	r25, 0x03	; 3
    1852:	63 ee       	ldi	r22, 0xE3	; 227
    1854:	71 e0       	ldi	r23, 0x01	; 1
    1856:	04 c0       	rjmp	.+8      	; 0x1860 <nastav3+0x7c>
      LCDstringXY(0,0,lcd_dis[0], 12);
	}
    else { 
	  strcpy(lcd_dis[0], "Cas: Zapnute");	//doplnene
    1858:	8c ef       	ldi	r24, 0xFC	; 252
    185a:	93 e0       	ldi	r25, 0x03	; 3
    185c:	60 ef       	ldi	r22, 0xF0	; 240
    185e:	71 e0       	ldi	r23, 0x01	; 1
    1860:	0e 94 dc 10 	call	0x21b8	; 0x21b8 <strcpy>
	  LCDstringXY(0,0,lcd_dis[0], 12); 
    1864:	80 e0       	ldi	r24, 0x00	; 0
    1866:	60 e0       	ldi	r22, 0x00	; 0
    1868:	4c ef       	ldi	r20, 0xFC	; 252
    186a:	53 e0       	ldi	r21, 0x03	; 3
    186c:	2c e0       	ldi	r18, 0x0C	; 12
    186e:	0e 94 25 03 	call	0x64a	; 0x64a <LCDstringXY>
	}
	if (bit_is_set(PINC, 1)) {
    1872:	31 9b       	sbis	0x06, 1	; 6
    1874:	0f c0       	rjmp	.+30     	; 0x1894 <nastav3+0xb0>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    1876:	31 99       	sbic	0x06, 1	; 6
    1878:	fe cf       	rjmp	.-4      	; 0x1876 <nastav3+0x92>
	  LCDstringXY(0,0,lcd_dis[0], 12); 
	}
	if (bit_is_set(PINC, 1)) {
	  cakaj(1);
	  _clock ^= 1;					// zakazat/povolit alram pre cas
	  LCDcistiXY(5, 0, 7);
    187a:	85 e0       	ldi	r24, 0x05	; 5
    187c:	60 e0       	ldi	r22, 0x00	; 0
    187e:	47 e0       	ldi	r20, 0x07	; 7
    1880:	0e 94 15 03 	call	0x62a	; 0x62a <LCDcistiXY>
    1884:	80 e2       	ldi	r24, 0x20	; 32
    1886:	93 e0       	ldi	r25, 0x03	; 3
    1888:	f8 01       	movw	r30, r16
    188a:	31 97       	sbiw	r30, 0x01	; 1
    188c:	f1 f7       	brne	.-4      	; 0x188a <nastav3+0xa6>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    188e:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1890:	d9 f7       	brne	.-10     	; 0x1888 <nastav3+0xa4>
	  strcpy(lcd_dis[0], "Cas: Zapnute");	//doplnene
	  LCDstringXY(0,0,lcd_dis[0], 12); 
	}
	if (bit_is_set(PINC, 1)) {
	  cakaj(1);
	  _clock ^= 1;					// zakazat/povolit alram pre cas
    1892:	ef 24       	eor	r14, r15
	  LCDcistiXY(5, 0, 7);
	  _delay_ms(80);
	}
	if (bit_is_set(PINC, 2)) {
    1894:	32 9b       	sbis	0x06, 2	; 6
    1896:	0f c0       	rjmp	.+30     	; 0x18b6 <nastav3+0xd2>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    1898:	32 99       	sbic	0x06, 2	; 6
    189a:	fe cf       	rjmp	.-4      	; 0x1898 <nastav3+0xb4>
	  _delay_ms(80);
	}
	if (bit_is_set(PINC, 2)) {
	  cakaj(2);
	  _clock ^= 1;	
	  LCDcistiXY(5, 0, 7);
    189c:	85 e0       	ldi	r24, 0x05	; 5
    189e:	60 e0       	ldi	r22, 0x00	; 0
    18a0:	47 e0       	ldi	r20, 0x07	; 7
    18a2:	0e 94 15 03 	call	0x62a	; 0x62a <LCDcistiXY>
    18a6:	80 e2       	ldi	r24, 0x20	; 32
    18a8:	93 e0       	ldi	r25, 0x03	; 3
    18aa:	f8 01       	movw	r30, r16
    18ac:	31 97       	sbiw	r30, 0x01	; 1
    18ae:	f1 f7       	brne	.-4      	; 0x18ac <nastav3+0xc8>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    18b0:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    18b2:	d9 f7       	brne	.-10     	; 0x18aa <nastav3+0xc6>
	  LCDcistiXY(5, 0, 7);
	  _delay_ms(80);
	}
	if (bit_is_set(PINC, 2)) {
	  cakaj(2);
	  _clock ^= 1;	
    18b4:	ef 24       	eor	r14, r15
	  LCDcistiXY(5, 0, 7);
	  _delay_ms(80);
	}
	if (bit_is_set(PINC, 0)) {
    18b6:	30 9b       	sbis	0x06, 0	; 6
    18b8:	05 c0       	rjmp	.+10     	; 0x18c4 <nastav3+0xe0>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    18ba:	30 99       	sbic	0x06, 0	; 6
    18bc:	fe cf       	rjmp	.-4      	; 0x18ba <nastav3+0xd6>
	if (bit_is_set(PINC, 4)) {
	  cakaj(4);
	  return;
	}
  }
  if (_clock != 0) {
    18be:	ee 20       	and	r14, r14
    18c0:	31 f4       	brne	.+12     	; 0x18ce <nastav3+0xea>
    18c2:	36 c1       	rjmp	.+620    	; 0x1b30 <nastav3+0x34c>
	}
	if (bit_is_set(PINC, 0)) {
	  cakaj(0);
	  break;
	}
	if (bit_is_set(PINC, 4)) {
    18c4:	34 9b       	sbis	0x06, 4	; 6
    18c6:	c1 cf       	rjmp	.-126    	; 0x184a <nastav3+0x66>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    18c8:	34 99       	sbic	0x06, 4	; 6
    18ca:	fe cf       	rjmp	.-4      	; 0x18c8 <nastav3+0xe4>
    18cc:	37 c1       	rjmp	.+622    	; 0x1b3c <nastav3+0x358>
	  return;
	}
  }
  if (_clock != 0) {
    for (i = 0; i < 3; i++)
	  _alarm[i] = p_alarm[i];
    18ce:	e0 91 6b 02 	lds	r30, 0x026B
    18d2:	f0 91 6c 02 	lds	r31, 0x026C
    18d6:	80 81       	ld	r24, Z
    18d8:	89 83       	std	Y+1, r24	; 0x01
    18da:	91 81       	ldd	r25, Z+1	; 0x01
    18dc:	9a 83       	std	Y+2, r25	; 0x02
    18de:	22 81       	ldd	r18, Z+2	; 0x02
    18e0:	2b 83       	std	Y+3, r18	; 0x03
    sprintf(lcd_dis[1], "%02x:%02x:%02x", _alarm[0], _alarm[1], _alarm[2]);		//doplnene
    18e2:	4d b7       	in	r20, 0x3d	; 61
    18e4:	5e b7       	in	r21, 0x3e	; 62
    18e6:	4a 50       	subi	r20, 0x0A	; 10
    18e8:	50 40       	sbci	r21, 0x00	; 0
    18ea:	0f b6       	in	r0, 0x3f	; 63
    18ec:	f8 94       	cli
    18ee:	5e bf       	out	0x3e, r21	; 62
    18f0:	0f be       	out	0x3f, r0	; 63
    18f2:	4d bf       	out	0x3d, r20	; 61
    18f4:	ed b7       	in	r30, 0x3d	; 61
    18f6:	fe b7       	in	r31, 0x3e	; 62
    18f8:	31 96       	adiw	r30, 0x01	; 1
    18fa:	ad b7       	in	r26, 0x3d	; 61
    18fc:	be b7       	in	r27, 0x3e	; 62
    18fe:	12 96       	adiw	r26, 0x02	; 2
    1900:	dc 92       	st	X, r13
    1902:	ce 92       	st	-X, r12
    1904:	11 97       	sbiw	r26, 0x01	; 1
    1906:	0d ef       	ldi	r16, 0xFD	; 253
    1908:	11 e0       	ldi	r17, 0x01	; 1
    190a:	13 83       	std	Z+3, r17	; 0x03
    190c:	02 83       	std	Z+2, r16	; 0x02
    190e:	84 83       	std	Z+4, r24	; 0x04
    1910:	15 82       	std	Z+5, r1	; 0x05
    1912:	96 83       	std	Z+6, r25	; 0x06
    1914:	17 82       	std	Z+7, r1	; 0x07
    1916:	20 87       	std	Z+8, r18	; 0x08
    1918:	11 86       	std	Z+9, r1	; 0x09
    191a:	0e 94 24 11 	call	0x2248	; 0x2248 <sprintf>
	LCDstringXY(0, 1, lcd_dis[1], 8);
    191e:	4d b7       	in	r20, 0x3d	; 61
    1920:	5e b7       	in	r21, 0x3e	; 62
    1922:	46 5f       	subi	r20, 0xF6	; 246
    1924:	5f 4f       	sbci	r21, 0xFF	; 255
    1926:	0f b6       	in	r0, 0x3f	; 63
    1928:	f8 94       	cli
    192a:	5e bf       	out	0x3e, r21	; 62
    192c:	0f be       	out	0x3f, r0	; 63
    192e:	4d bf       	out	0x3d, r20	; 61
    1930:	80 e0       	ldi	r24, 0x00	; 0
    1932:	61 e0       	ldi	r22, 0x01	; 1
    1934:	a6 01       	movw	r20, r12
    1936:	28 e0       	ldi	r18, 0x08	; 8
    1938:	0e 94 25 03 	call	0x64a	; 0x64a <LCDstringXY>
    193c:	ff 24       	eor	r15, r15
	for (i = 0; i < 3;) {
	  if (bit_is_set(PINC, 1)) {
	    if ((_alarm[i]) < ((i == 0) ? 0x23 : 0x59)) {
    193e:	5e 01       	movw	r10, r28
    1940:	08 94       	sec
    1942:	a1 1c       	adc	r10, r1
    1944:	b1 1c       	adc	r11, r1
		  (_alarm[i])++;
		  if ((bcdToDec(_alarm[i]) % 10) == 0)
		    (_alarm[i]) += 6;
		} else _alarm[i] = 0;
		LCDcursorOFF(); cursor = 0;
		sprintf(lcd_dis[1], "%02x:%02x:%02x", _alarm[0], _alarm[1], _alarm[2]);	//doplnene
    1946:	48 01       	movw	r8, r16
    1948:	08 ec       	ldi	r16, 0xC8	; 200
    194a:	10 e0       	ldi	r17, 0x00	; 0
	LCDstringXY(0, 1, lcd_dis[1], 8);
	for (i = 0; i < 3;) {
	  if (bit_is_set(PINC, 1)) {
	    if ((_alarm[i]) < ((i == 0) ? 0x23 : 0x59)) {
		  (_alarm[i])++;
		  if ((bcdToDec(_alarm[i]) % 10) == 0)
    194c:	9a e0       	ldi	r25, 0x0A	; 10
    194e:	79 2e       	mov	r7, r25
		sprintf(lcd_dis[1], "%02x:%02x:%02x", _alarm[0], _alarm[1], _alarm[2]);	//doplnene
		LCDstringXY(0, 1, lcd_dis[1], 8);
		_delay_ms(100);
	  }
	  LCDcursorOnBlink(); cursor = 1;
	  LCDGotoXY(1+(i*3),1);
    1950:	83 e0       	ldi	r24, 0x03	; 3
    1952:	68 2e       	mov	r6, r24
    for (i = 0; i < 3; i++)
	  _alarm[i] = p_alarm[i];
    sprintf(lcd_dis[1], "%02x:%02x:%02x", _alarm[0], _alarm[1], _alarm[2]);		//doplnene
	LCDstringXY(0, 1, lcd_dis[1], 8);
	for (i = 0; i < 3;) {
	  if (bit_is_set(PINC, 1)) {
    1954:	31 9b       	sbis	0x06, 1	; 6
    1956:	62 c0       	rjmp	.+196    	; 0x1a1c <nastav3+0x238>
	    if ((_alarm[i]) < ((i == 0) ? 0x23 : 0x59)) {
    1958:	af 2d       	mov	r26, r15
    195a:	b0 e0       	ldi	r27, 0x00	; 0
    195c:	f5 01       	movw	r30, r10
    195e:	ea 0f       	add	r30, r26
    1960:	fb 1f       	adc	r31, r27
    1962:	e0 81       	ld	r30, Z
    1964:	ff 20       	and	r15, r15
    1966:	19 f4       	brne	.+6      	; 0x196e <nastav3+0x18a>
    1968:	23 e2       	ldi	r18, 0x23	; 35
    196a:	30 e0       	ldi	r19, 0x00	; 0
    196c:	02 c0       	rjmp	.+4      	; 0x1972 <nastav3+0x18e>
    196e:	29 e5       	ldi	r18, 0x59	; 89
    1970:	30 e0       	ldi	r19, 0x00	; 0
    1972:	8e 2f       	mov	r24, r30
    1974:	90 e0       	ldi	r25, 0x00	; 0
    1976:	82 17       	cp	r24, r18
    1978:	93 07       	cpc	r25, r19
    197a:	ac f4       	brge	.+42     	; 0x19a6 <nastav3+0x1c2>
		  (_alarm[i])++;
    197c:	8e 2f       	mov	r24, r30
    197e:	8f 5f       	subi	r24, 0xFF	; 255
    1980:	aa 0d       	add	r26, r10
    1982:	bb 1d       	adc	r27, r11
    1984:	8c 93       	st	X, r24
		  if ((bcdToDec(_alarm[i]) % 10) == 0)
    1986:	28 2f       	mov	r18, r24
    1988:	22 95       	swap	r18
    198a:	2f 70       	andi	r18, 0x0F	; 15
    198c:	27 9d       	mul	r18, r7
    198e:	90 01       	movw	r18, r0
    1990:	11 24       	eor	r1, r1
    1992:	8f 70       	andi	r24, 0x0F	; 15
    1994:	82 0f       	add	r24, r18
    1996:	6a e0       	ldi	r22, 0x0A	; 10
    1998:	0e 94 99 13 	call	0x2732	; 0x2732 <__udivmodqi4>
    199c:	99 23       	and	r25, r25
    199e:	31 f4       	brne	.+12     	; 0x19ac <nastav3+0x1c8>
		    (_alarm[i]) += 6;
    19a0:	e9 5f       	subi	r30, 0xF9	; 249
    19a2:	ec 93       	st	X, r30
    19a4:	03 c0       	rjmp	.+6      	; 0x19ac <nastav3+0x1c8>
		} else _alarm[i] = 0;
    19a6:	aa 0d       	add	r26, r10
    19a8:	bb 1d       	adc	r27, r11
    19aa:	1c 92       	st	X, r1
		LCDcursorOFF(); cursor = 0;
    19ac:	0e 94 5f 02 	call	0x4be	; 0x4be <LCDcursorOFF>
    19b0:	10 92 29 04 	sts	0x0429, r1
		sprintf(lcd_dis[1], "%02x:%02x:%02x", _alarm[0], _alarm[1], _alarm[2]);	//doplnene
    19b4:	8d b7       	in	r24, 0x3d	; 61
    19b6:	9e b7       	in	r25, 0x3e	; 62
    19b8:	0a 97       	sbiw	r24, 0x0a	; 10
    19ba:	0f b6       	in	r0, 0x3f	; 63
    19bc:	f8 94       	cli
    19be:	9e bf       	out	0x3e, r25	; 62
    19c0:	0f be       	out	0x3f, r0	; 63
    19c2:	8d bf       	out	0x3d, r24	; 61
    19c4:	ed b7       	in	r30, 0x3d	; 61
    19c6:	fe b7       	in	r31, 0x3e	; 62
    19c8:	31 96       	adiw	r30, 0x01	; 1
    19ca:	ad b7       	in	r26, 0x3d	; 61
    19cc:	be b7       	in	r27, 0x3e	; 62
    19ce:	12 96       	adiw	r26, 0x02	; 2
    19d0:	dc 92       	st	X, r13
    19d2:	ce 92       	st	-X, r12
    19d4:	11 97       	sbiw	r26, 0x01	; 1
    19d6:	82 82       	std	Z+2, r8	; 0x02
    19d8:	93 82       	std	Z+3, r9	; 0x03
    19da:	89 81       	ldd	r24, Y+1	; 0x01
    19dc:	84 83       	std	Z+4, r24	; 0x04
    19de:	15 82       	std	Z+5, r1	; 0x05
    19e0:	8a 81       	ldd	r24, Y+2	; 0x02
    19e2:	86 83       	std	Z+6, r24	; 0x06
    19e4:	17 82       	std	Z+7, r1	; 0x07
    19e6:	8b 81       	ldd	r24, Y+3	; 0x03
    19e8:	80 87       	std	Z+8, r24	; 0x08
    19ea:	11 86       	std	Z+9, r1	; 0x09
    19ec:	0e 94 24 11 	call	0x2248	; 0x2248 <sprintf>
		LCDstringXY(0, 1, lcd_dis[1], 8);
    19f0:	4d b7       	in	r20, 0x3d	; 61
    19f2:	5e b7       	in	r21, 0x3e	; 62
    19f4:	46 5f       	subi	r20, 0xF6	; 246
    19f6:	5f 4f       	sbci	r21, 0xFF	; 255
    19f8:	0f b6       	in	r0, 0x3f	; 63
    19fa:	f8 94       	cli
    19fc:	5e bf       	out	0x3e, r21	; 62
    19fe:	0f be       	out	0x3f, r0	; 63
    1a00:	4d bf       	out	0x3d, r20	; 61
    1a02:	80 e0       	ldi	r24, 0x00	; 0
    1a04:	61 e0       	ldi	r22, 0x01	; 1
    1a06:	a6 01       	movw	r20, r12
    1a08:	28 e0       	ldi	r18, 0x08	; 8
    1a0a:	0e 94 25 03 	call	0x64a	; 0x64a <LCDstringXY>
    1a0e:	88 ee       	ldi	r24, 0xE8	; 232
    1a10:	93 e0       	ldi	r25, 0x03	; 3
    1a12:	f8 01       	movw	r30, r16
    1a14:	31 97       	sbiw	r30, 0x01	; 1
    1a16:	f1 f7       	brne	.-4      	; 0x1a14 <nastav3+0x230>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1a18:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1a1a:	d9 f7       	brne	.-10     	; 0x1a12 <nastav3+0x22e>
		_delay_ms(100);
	  }
	  if (bit_is_set(PINC, 2)) {
    1a1c:	32 9b       	sbis	0x06, 2	; 6
    1a1e:	5c c0       	rjmp	.+184    	; 0x1ad8 <nastav3+0x2f4>
	    if (_alarm[i] > 0) {
    1a20:	ef 2d       	mov	r30, r15
    1a22:	f0 e0       	ldi	r31, 0x00	; 0
    1a24:	d5 01       	movw	r26, r10
    1a26:	ae 0f       	add	r26, r30
    1a28:	bf 1f       	adc	r27, r31
    1a2a:	4c 91       	ld	r20, X
    1a2c:	44 23       	and	r20, r20
    1a2e:	a1 f0       	breq	.+40     	; 0x1a58 <nastav3+0x274>
		  if ((bcdToDec(_alarm[i]--) % 10) == 0)
    1a30:	41 50       	subi	r20, 0x01	; 1
    1a32:	4c 93       	st	X, r20
    1a34:	4f 5f       	subi	r20, 0xFF	; 255
    1a36:	24 2f       	mov	r18, r20
    1a38:	22 95       	swap	r18
    1a3a:	2f 70       	andi	r18, 0x0F	; 15
    1a3c:	27 9d       	mul	r18, r7
    1a3e:	90 01       	movw	r18, r0
    1a40:	11 24       	eor	r1, r1
    1a42:	84 2f       	mov	r24, r20
    1a44:	8f 70       	andi	r24, 0x0F	; 15
    1a46:	82 0f       	add	r24, r18
    1a48:	6a e0       	ldi	r22, 0x0A	; 10
    1a4a:	0e 94 99 13 	call	0x2732	; 0x2732 <__udivmodqi4>
    1a4e:	99 23       	and	r25, r25
    1a50:	59 f4       	brne	.+22     	; 0x1a68 <nastav3+0x284>
		    (_alarm[i]) -= 6;
    1a52:	47 50       	subi	r20, 0x07	; 7
    1a54:	4c 93       	st	X, r20
    1a56:	08 c0       	rjmp	.+16     	; 0x1a68 <nastav3+0x284>
		} else { _alarm[i] = (i == 0) ? 0x23 : 0x59;}
    1a58:	ff 20       	and	r15, r15
    1a5a:	11 f0       	breq	.+4      	; 0x1a60 <nastav3+0x27c>
    1a5c:	89 e5       	ldi	r24, 0x59	; 89
    1a5e:	01 c0       	rjmp	.+2      	; 0x1a62 <nastav3+0x27e>
    1a60:	83 e2       	ldi	r24, 0x23	; 35
    1a62:	ea 0d       	add	r30, r10
    1a64:	fb 1d       	adc	r31, r11
    1a66:	80 83       	st	Z, r24
	    LCDcursorOFF(); cursor = 0;
    1a68:	0e 94 5f 02 	call	0x4be	; 0x4be <LCDcursorOFF>
    1a6c:	10 92 29 04 	sts	0x0429, r1
		sprintf(lcd_dis[1], "%02x:%02x:%02x", _alarm[0], _alarm[1], _alarm[2]);	//doplnene
    1a70:	8d b7       	in	r24, 0x3d	; 61
    1a72:	9e b7       	in	r25, 0x3e	; 62
    1a74:	0a 97       	sbiw	r24, 0x0a	; 10
    1a76:	0f b6       	in	r0, 0x3f	; 63
    1a78:	f8 94       	cli
    1a7a:	9e bf       	out	0x3e, r25	; 62
    1a7c:	0f be       	out	0x3f, r0	; 63
    1a7e:	8d bf       	out	0x3d, r24	; 61
    1a80:	ed b7       	in	r30, 0x3d	; 61
    1a82:	fe b7       	in	r31, 0x3e	; 62
    1a84:	31 96       	adiw	r30, 0x01	; 1
    1a86:	ad b7       	in	r26, 0x3d	; 61
    1a88:	be b7       	in	r27, 0x3e	; 62
    1a8a:	12 96       	adiw	r26, 0x02	; 2
    1a8c:	dc 92       	st	X, r13
    1a8e:	ce 92       	st	-X, r12
    1a90:	11 97       	sbiw	r26, 0x01	; 1
    1a92:	82 82       	std	Z+2, r8	; 0x02
    1a94:	93 82       	std	Z+3, r9	; 0x03
    1a96:	89 81       	ldd	r24, Y+1	; 0x01
    1a98:	84 83       	std	Z+4, r24	; 0x04
    1a9a:	15 82       	std	Z+5, r1	; 0x05
    1a9c:	8a 81       	ldd	r24, Y+2	; 0x02
    1a9e:	86 83       	std	Z+6, r24	; 0x06
    1aa0:	17 82       	std	Z+7, r1	; 0x07
    1aa2:	8b 81       	ldd	r24, Y+3	; 0x03
    1aa4:	80 87       	std	Z+8, r24	; 0x08
    1aa6:	11 86       	std	Z+9, r1	; 0x09
    1aa8:	0e 94 24 11 	call	0x2248	; 0x2248 <sprintf>
		LCDstringXY(0, 1, lcd_dis[1], 8);
    1aac:	4d b7       	in	r20, 0x3d	; 61
    1aae:	5e b7       	in	r21, 0x3e	; 62
    1ab0:	46 5f       	subi	r20, 0xF6	; 246
    1ab2:	5f 4f       	sbci	r21, 0xFF	; 255
    1ab4:	0f b6       	in	r0, 0x3f	; 63
    1ab6:	f8 94       	cli
    1ab8:	5e bf       	out	0x3e, r21	; 62
    1aba:	0f be       	out	0x3f, r0	; 63
    1abc:	4d bf       	out	0x3d, r20	; 61
    1abe:	80 e0       	ldi	r24, 0x00	; 0
    1ac0:	61 e0       	ldi	r22, 0x01	; 1
    1ac2:	a6 01       	movw	r20, r12
    1ac4:	28 e0       	ldi	r18, 0x08	; 8
    1ac6:	0e 94 25 03 	call	0x64a	; 0x64a <LCDstringXY>
    1aca:	88 ee       	ldi	r24, 0xE8	; 232
    1acc:	93 e0       	ldi	r25, 0x03	; 3
    1ace:	f8 01       	movw	r30, r16
    1ad0:	31 97       	sbiw	r30, 0x01	; 1
    1ad2:	f1 f7       	brne	.-4      	; 0x1ad0 <nastav3+0x2ec>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1ad4:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1ad6:	d9 f7       	brne	.-10     	; 0x1ace <nastav3+0x2ea>
		_delay_ms(100);
	  }
	  LCDcursorOnBlink(); cursor = 1;
    1ad8:	0e 94 5b 02 	call	0x4b6	; 0x4b6 <LCDcursorOnBlink>
    1adc:	81 e0       	ldi	r24, 0x01	; 1
    1ade:	80 93 29 04 	sts	0x0429, r24
	  LCDGotoXY(1+(i*3),1);
    1ae2:	f6 9c       	mul	r15, r6
    1ae4:	c0 01       	movw	r24, r0
    1ae6:	11 24       	eor	r1, r1
    1ae8:	8f 5f       	subi	r24, 0xFF	; 255
    1aea:	61 e0       	ldi	r22, 0x01	; 1
    1aec:	0e 94 ef 01 	call	0x3de	; 0x3de <LCDGotoXY>

	  if (bit_is_set(PINC, 0)) {
    1af0:	30 9b       	sbis	0x06, 0	; 6
    1af2:	03 c0       	rjmp	.+6      	; 0x1afa <nastav3+0x316>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    1af4:	30 99       	sbic	0x06, 0	; 6
    1af6:	fe cf       	rjmp	.-4      	; 0x1af4 <nastav3+0x310>
	  LCDcursorOnBlink(); cursor = 1;
	  LCDGotoXY(1+(i*3),1);

	  if (bit_is_set(PINC, 0)) {
	    cakaj(0);
		i++;
    1af8:	f3 94       	inc	r15
	  }
	  if (bit_is_set(PINC, 4)) {
    1afa:	34 9b       	sbis	0x06, 4	; 6
    1afc:	03 c0       	rjmp	.+6      	; 0x1b04 <nastav3+0x320>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    1afe:	34 99       	sbic	0x06, 4	; 6
    1b00:	fe cf       	rjmp	.-4      	; 0x1afe <nastav3+0x31a>
    1b02:	18 c0       	rjmp	.+48     	; 0x1b34 <nastav3+0x350>
  if (_clock != 0) {
    for (i = 0; i < 3; i++)
	  _alarm[i] = p_alarm[i];
    sprintf(lcd_dis[1], "%02x:%02x:%02x", _alarm[0], _alarm[1], _alarm[2]);		//doplnene
	LCDstringXY(0, 1, lcd_dis[1], 8);
	for (i = 0; i < 3;) {
    1b04:	52 e0       	ldi	r21, 0x02	; 2
    1b06:	5f 15       	cp	r21, r15
    1b08:	08 f0       	brcs	.+2      	; 0x1b0c <nastav3+0x328>
    1b0a:	24 cf       	rjmp	.-440    	; 0x1954 <nastav3+0x170>
		LCDcursorOFF(); cursor = 0;
		return;
	  }
	}
	for (i = 0; i < 3; i++)
	  p_alarm[i] = _alarm[i];
    1b0c:	e0 91 6b 02 	lds	r30, 0x026B
    1b10:	f0 91 6c 02 	lds	r31, 0x026C
    1b14:	89 81       	ldd	r24, Y+1	; 0x01
    1b16:	80 83       	st	Z, r24
    1b18:	e0 91 6b 02 	lds	r30, 0x026B
    1b1c:	f0 91 6c 02 	lds	r31, 0x026C
    1b20:	8a 81       	ldd	r24, Y+2	; 0x02
    1b22:	81 83       	std	Z+1, r24	; 0x01
    1b24:	e0 91 6b 02 	lds	r30, 0x026B
    1b28:	f0 91 6c 02 	lds	r31, 0x026C
    1b2c:	8b 81       	ldd	r24, Y+3	; 0x03
    1b2e:	82 83       	std	Z+2, r24	; 0x02
  }
  alarm.clock = _clock;
    1b30:	e0 92 25 04 	sts	0x0425, r14
  LCDcursorOFF();cursor = 0;
    1b34:	0e 94 5f 02 	call	0x4be	; 0x4be <LCDcursorOFF>
    1b38:	10 92 29 04 	sts	0x0429, r1
}
    1b3c:	0f 90       	pop	r0
    1b3e:	0f 90       	pop	r0
    1b40:	0f 90       	pop	r0
    1b42:	cf 91       	pop	r28
    1b44:	df 91       	pop	r29
    1b46:	1f 91       	pop	r17
    1b48:	0f 91       	pop	r16
    1b4a:	ff 90       	pop	r15
    1b4c:	ef 90       	pop	r14
    1b4e:	df 90       	pop	r13
    1b50:	cf 90       	pop	r12
    1b52:	bf 90       	pop	r11
    1b54:	af 90       	pop	r10
    1b56:	9f 90       	pop	r9
    1b58:	8f 90       	pop	r8
    1b5a:	7f 90       	pop	r7
    1b5c:	6f 90       	pop	r6
    1b5e:	08 95       	ret

00001b60 <nastav_extra>:
  return 0;
}
//----------------------------------------------------------------------
char nastav_extra(void)
{
  nastav1();
    1b60:	0e 94 11 09 	call	0x1222	; 0x1222 <nastav1>
  stav |= 2;			// nesnimaj pocas nastavovania - alarm
    1b64:	80 91 f8 03 	lds	r24, 0x03F8
    1b68:	82 60       	ori	r24, 0x02	; 2
    1b6a:	80 93 f8 03 	sts	0x03F8, r24
  nastav2();
    1b6e:	0e 94 b2 08 	call	0x1164	; 0x1164 <nastav2>
  if (alarm.al_flag == 1) {
    1b72:	80 91 26 04 	lds	r24, 0x0426
    1b76:	81 30       	cpi	r24, 0x01	; 1
    1b78:	21 f4       	brne	.+8      	; 0x1b82 <nastav_extra+0x22>
    nastav3();
    1b7a:	0e 94 f2 0b 	call	0x17e4	; 0x17e4 <nastav3>
    nastav4();
    1b7e:	0e 94 d0 0a 	call	0x15a0	; 0x15a0 <nastav4>
  }
  if ((alarm.al_flag == 1) && ((alarm.clock == 1) || (alarm.temp == 1)) )
    1b82:	80 91 26 04 	lds	r24, 0x0426
    1b86:	81 30       	cpi	r24, 0x01	; 1
    1b88:	51 f4       	brne	.+20     	; 0x1b9e <nastav_extra+0x3e>
    1b8a:	80 91 25 04 	lds	r24, 0x0425
    1b8e:	81 30       	cpi	r24, 0x01	; 1
    1b90:	21 f0       	breq	.+8      	; 0x1b9a <nastav_extra+0x3a>
    1b92:	80 91 24 04 	lds	r24, 0x0424
    1b96:	81 30       	cpi	r24, 0x01	; 1
    1b98:	11 f4       	brne	.+4      	; 0x1b9e <nastav_extra+0x3e>
    nastav5();
    1b9a:	0e 94 2a 08 	call	0x1054	; 0x1054 <nastav5>
  stav &= ~2;
    1b9e:	80 91 f8 03 	lds	r24, 0x03F8
    1ba2:	8d 7f       	andi	r24, 0xFD	; 253
    1ba4:	80 93 f8 03 	sts	0x03F8, r24
  return 0;
}
    1ba8:	80 e0       	ldi	r24, 0x00	; 0
    1baa:	08 95       	ret

00001bac <nastav>:
  LCDGotoXY(0,1);
  LCDstring(lcd_dis[1], strlen(lcd_dis[1]));
}
//----------------------------------------------------------------------
void nastav(char str_ud[], char val, char addr)		// (hodnota zo struktury, prislusny retazec, max zobrazena hodnota, adresa (na zapis))
{
    1bac:	4f 92       	push	r4
    1bae:	5f 92       	push	r5
    1bb0:	6f 92       	push	r6
    1bb2:	7f 92       	push	r7
    1bb4:	8f 92       	push	r8
    1bb6:	9f 92       	push	r9
    1bb8:	af 92       	push	r10
    1bba:	bf 92       	push	r11
    1bbc:	cf 92       	push	r12
    1bbe:	df 92       	push	r13
    1bc0:	ef 92       	push	r14
    1bc2:	ff 92       	push	r15
    1bc4:	0f 93       	push	r16
    1bc6:	1f 93       	push	r17
    1bc8:	df 93       	push	r29
    1bca:	cf 93       	push	r28
    1bcc:	0f 92       	push	r0
    1bce:	cd b7       	in	r28, 0x3d	; 61
    1bd0:	de b7       	in	r29, 0x3e	; 62
    1bd2:	3c 01       	movw	r6, r24
    1bd4:	f6 2e       	mov	r15, r22
    1bd6:	04 2f       	mov	r16, r20
    1bd8:	e0 91 6d 02 	lds	r30, 0x026D
    1bdc:	f0 91 6e 02 	lds	r31, 0x026E
  char p_udaj;
  p_udaj = (addr != 0) ? p_udaje[addr] : p_udaje[addr]&0x7f;
    1be0:	44 23       	and	r20, r20
    1be2:	31 f0       	breq	.+12     	; 0x1bf0 <nastav+0x44>
    1be4:	e4 0f       	add	r30, r20
    1be6:	f1 1d       	adc	r31, r1
    1be8:	10 81       	ld	r17, Z
  if (addr == 4)													// Ak nastavujem den 
    1bea:	44 30       	cpi	r20, 0x04	; 4
    1bec:	21 f0       	breq	.+8      	; 0x1bf6 <nastav+0x4a>
    1bee:	2a c0       	rjmp	.+84     	; 0x1c44 <nastav+0x98>
}
//----------------------------------------------------------------------
void nastav(char str_ud[], char val, char addr)		// (hodnota zo struktury, prislusny retazec, max zobrazena hodnota, adresa (na zapis))
{
  char p_udaj;
  p_udaj = (addr != 0) ? p_udaje[addr] : p_udaje[addr]&0x7f;
    1bf0:	10 81       	ld	r17, Z
    1bf2:	1f 77       	andi	r17, 0x7F	; 127
    1bf4:	27 c0       	rjmp	.+78     	; 0x1c44 <nastav+0x98>
  if (addr == 4)													// Ak nastavujem den 
    if (p_udaj > pct_dni[bcdToDec(udaje.mes)-1]) {				// zisti ci je pocet dni vacsi ako celkovy pocet v danom mesiaci
    1bf6:	40 91 39 04 	lds	r20, 0x0439
    1bfa:	84 2f       	mov	r24, r20
    1bfc:	82 95       	swap	r24
    1bfe:	8f 70       	andi	r24, 0x0F	; 15
    1c00:	3a e0       	ldi	r19, 0x0A	; 10
    1c02:	83 9f       	mul	r24, r19
    1c04:	c0 01       	movw	r24, r0
    1c06:	11 24       	eor	r1, r1
    1c08:	e4 2f       	mov	r30, r20
    1c0a:	ef 70       	andi	r30, 0x0F	; 15
    1c0c:	e8 0f       	add	r30, r24
    1c0e:	f0 e0       	ldi	r31, 0x00	; 0
    1c10:	ea 5e       	subi	r30, 0xEA	; 234
    1c12:	fc 4f       	sbci	r31, 0xFC	; 252
    1c14:	e0 81       	ld	r30, Z
    1c16:	e1 17       	cp	r30, r17
    1c18:	a8 f4       	brcc	.+42     	; 0x1c44 <nastav+0x98>
	  p_udaj = pct_dni[bcdToDec(udaje.mes)-1];						// pokial je vacsi nastav max. pocet dni a
	  if (((bcdToDec(udaje.rok) % 4) == 0) && (udaje.mes == 2)) 	// pokial je februar a priestupny rok tak este zvys den
    1c1a:	80 91 3a 04 	lds	r24, 0x043A
    1c1e:	28 2f       	mov	r18, r24
    1c20:	22 95       	swap	r18
    1c22:	2f 70       	andi	r18, 0x0F	; 15
    1c24:	23 9f       	mul	r18, r19
    1c26:	90 01       	movw	r18, r0
    1c28:	11 24       	eor	r1, r1
    1c2a:	8f 70       	andi	r24, 0x0F	; 15
    1c2c:	82 0f       	add	r24, r18
    1c2e:	90 e0       	ldi	r25, 0x00	; 0
    1c30:	83 70       	andi	r24, 0x03	; 3
    1c32:	90 70       	andi	r25, 0x00	; 0
    1c34:	89 2b       	or	r24, r25
    1c36:	29 f4       	brne	.+10     	; 0x1c42 <nastav+0x96>
    1c38:	42 30       	cpi	r20, 0x02	; 2
    1c3a:	19 f4       	brne	.+6      	; 0x1c42 <nastav+0x96>
	    p_udaj++;												// jedna sa o strukturu (nie o zobrazovacie hodnoty)
    1c3c:	1e 2f       	mov	r17, r30
    1c3e:	1f 5f       	subi	r17, 0xFF	; 255
    1c40:	01 c0       	rjmp	.+2      	; 0x1c44 <nastav+0x98>
    1c42:	1e 2f       	mov	r17, r30
    1c44:	4f 2c       	mov	r4, r15
    1c46:	55 24       	eor	r5, r5
	}
  while (1) {
  	LCDGotoXY(0,1);
    sprintf(lcd_dis[1], str_ud, p_udaj, (addr == 0) ? val&0x7f : val);	// vyplnenie str_pis (o max hodnoty val-pom)
    1c48:	6f e7       	ldi	r22, 0x7F	; 127
    1c4a:	c6 2e       	mov	r12, r22
    1c4c:	d1 2c       	mov	r13, r1
    1c4e:	c4 20       	and	r12, r4
    1c50:	d5 20       	and	r13, r5
    1c52:	5d e0       	ldi	r21, 0x0D	; 13
    1c54:	85 2e       	mov	r8, r21
    1c56:	54 e0       	ldi	r21, 0x04	; 4
    1c58:	95 2e       	mov	r9, r21
    1c5a:	48 ec       	ldi	r20, 0xC8	; 200
    1c5c:	a4 2e       	mov	r10, r20
    1c5e:	b1 2c       	mov	r11, r1
	if (bit_is_set(PINC, 1)) {										// zvacsovanie hodnoty pri stlacani tlacitka 1
	  if (p_udaj < val) {									
	    p_udaj++;
	    if ((bcdToDec(p_udaj) % 10) == 0)							//osetrenie hex cislic na BCD (vynechanie pismen pricitanim 6)
		  p_udaj += 6;	
	  } else p_udaj = ((addr == 5)||(addr == 4)) ? 1 : 0;		//pokial je Den a Mesiac nastav min na 1 (inak zacinaj od nuly)
    1c60:	40 2f       	mov	r20, r16
    1c62:	44 50       	subi	r20, 0x04	; 4
    1c64:	49 83       	std	Y+1, r20	; 0x01
    sprintf(lcd_dis[1], str_ud, p_udaj, (addr == 0) ? val&0x7f : val);	// vyplnenie str_pis (o max hodnoty val-pom)
	LCDstring(lcd_dis[1], 16);											//16 znakov kvoli >
	if (bit_is_set(PINC, 1)) {										// zvacsovanie hodnoty pri stlacani tlacitka 1
	  if (p_udaj < val) {									
	    p_udaj++;
	    if ((bcdToDec(p_udaj) % 10) == 0)							//osetrenie hex cislic na BCD (vynechanie pismen pricitanim 6)
    1c66:	3a e0       	ldi	r19, 0x0A	; 10
    1c68:	e3 2e       	mov	r14, r19
	  p_udaj = pct_dni[bcdToDec(udaje.mes)-1];						// pokial je vacsi nastav max. pocet dni a
	  if (((bcdToDec(udaje.rok) % 4) == 0) && (udaje.mes == 2)) 	// pokial je februar a priestupny rok tak este zvys den
	    p_udaj++;												// jedna sa o strukturu (nie o zobrazovacie hodnoty)
	}
  while (1) {
  	LCDGotoXY(0,1);
    1c6a:	80 e0       	ldi	r24, 0x00	; 0
    1c6c:	61 e0       	ldi	r22, 0x01	; 1
    1c6e:	0e 94 ef 01 	call	0x3de	; 0x3de <LCDGotoXY>
    sprintf(lcd_dis[1], str_ud, p_udaj, (addr == 0) ? val&0x7f : val);	// vyplnenie str_pis (o max hodnoty val-pom)
    1c72:	00 23       	and	r16, r16
    1c74:	11 f4       	brne	.+4      	; 0x1c7a <nastav+0xce>
    1c76:	c6 01       	movw	r24, r12
    1c78:	01 c0       	rjmp	.+2      	; 0x1c7c <nastav+0xd0>
    1c7a:	c2 01       	movw	r24, r4
    1c7c:	28 2f       	mov	r18, r24
    1c7e:	ad b7       	in	r26, 0x3d	; 61
    1c80:	be b7       	in	r27, 0x3e	; 62
    1c82:	18 97       	sbiw	r26, 0x08	; 8
    1c84:	0f b6       	in	r0, 0x3f	; 63
    1c86:	f8 94       	cli
    1c88:	be bf       	out	0x3e, r27	; 62
    1c8a:	0f be       	out	0x3f, r0	; 63
    1c8c:	ad bf       	out	0x3d, r26	; 61
    1c8e:	ed b7       	in	r30, 0x3d	; 61
    1c90:	fe b7       	in	r31, 0x3e	; 62
    1c92:	31 96       	adiw	r30, 0x01	; 1
    1c94:	12 96       	adiw	r26, 0x02	; 2
    1c96:	9c 92       	st	X, r9
    1c98:	8e 92       	st	-X, r8
    1c9a:	11 97       	sbiw	r26, 0x01	; 1
    1c9c:	73 82       	std	Z+3, r7	; 0x03
    1c9e:	62 82       	std	Z+2, r6	; 0x02
    1ca0:	14 83       	std	Z+4, r17	; 0x04
    1ca2:	15 82       	std	Z+5, r1	; 0x05
    1ca4:	26 83       	std	Z+6, r18	; 0x06
    1ca6:	97 83       	std	Z+7, r25	; 0x07
    1ca8:	0e 94 24 11 	call	0x2248	; 0x2248 <sprintf>
	LCDstring(lcd_dis[1], 16);											//16 znakov kvoli >
    1cac:	ed b7       	in	r30, 0x3d	; 61
    1cae:	fe b7       	in	r31, 0x3e	; 62
    1cb0:	38 96       	adiw	r30, 0x08	; 8
    1cb2:	0f b6       	in	r0, 0x3f	; 63
    1cb4:	f8 94       	cli
    1cb6:	fe bf       	out	0x3e, r31	; 62
    1cb8:	0f be       	out	0x3f, r0	; 63
    1cba:	ed bf       	out	0x3d, r30	; 61
    1cbc:	c4 01       	movw	r24, r8
    1cbe:	60 e1       	ldi	r22, 0x10	; 16
    1cc0:	0e 94 da 01 	call	0x3b4	; 0x3b4 <LCDstring>
	if (bit_is_set(PINC, 1)) {										// zvacsovanie hodnoty pri stlacani tlacitka 1
    1cc4:	31 9b       	sbis	0x06, 1	; 6
    1cc6:	1f c0       	rjmp	.+62     	; 0x1d06 <nastav+0x15a>
	  if (p_udaj < val) {									
    1cc8:	1f 15       	cp	r17, r15
    1cca:	88 f4       	brcc	.+34     	; 0x1cee <nastav+0x142>
	    p_udaj++;
    1ccc:	1f 5f       	subi	r17, 0xFF	; 255
	    if ((bcdToDec(p_udaj) % 10) == 0)							//osetrenie hex cislic na BCD (vynechanie pismen pricitanim 6)
    1cce:	21 2f       	mov	r18, r17
    1cd0:	22 95       	swap	r18
    1cd2:	2f 70       	andi	r18, 0x0F	; 15
    1cd4:	2e 9d       	mul	r18, r14
    1cd6:	90 01       	movw	r18, r0
    1cd8:	11 24       	eor	r1, r1
    1cda:	81 2f       	mov	r24, r17
    1cdc:	8f 70       	andi	r24, 0x0F	; 15
    1cde:	82 0f       	add	r24, r18
    1ce0:	6a e0       	ldi	r22, 0x0A	; 10
    1ce2:	0e 94 99 13 	call	0x2732	; 0x2732 <__udivmodqi4>
    1ce6:	99 23       	and	r25, r25
    1ce8:	39 f4       	brne	.+14     	; 0x1cf8 <nastav+0x14c>
		  p_udaj += 6;	
    1cea:	1a 5f       	subi	r17, 0xFA	; 250
    1cec:	05 c0       	rjmp	.+10     	; 0x1cf8 <nastav+0x14c>
	  } else p_udaj = ((addr == 5)||(addr == 4)) ? 1 : 0;		//pokial je Den a Mesiac nastav min na 1 (inak zacinaj od nuly)
    1cee:	10 e0       	ldi	r17, 0x00	; 0
    1cf0:	f9 81       	ldd	r31, Y+1	; 0x01
    1cf2:	f2 30       	cpi	r31, 0x02	; 2
    1cf4:	08 f4       	brcc	.+2      	; 0x1cf8 <nastav+0x14c>
    1cf6:	11 e0       	ldi	r17, 0x01	; 1
    1cf8:	88 ee       	ldi	r24, 0xE8	; 232
    1cfa:	93 e0       	ldi	r25, 0x03	; 3
    1cfc:	f5 01       	movw	r30, r10
    1cfe:	31 97       	sbiw	r30, 0x01	; 1
    1d00:	f1 f7       	brne	.-4      	; 0x1cfe <nastav+0x152>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1d02:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1d04:	d9 f7       	brne	.-10     	; 0x1cfc <nastav+0x150>
	  _delay_ms(100);
	}
	if (bit_is_set(PINC, 2)) {
    1d06:	32 9b       	sbis	0x06, 2	; 6
    1d08:	28 c0       	rjmp	.+80     	; 0x1d5a <nastav+0x1ae>
	  if (p_udaj > ((addr == 4) || (addr == 5)) ? 1 : 0) {
    1d0a:	21 2f       	mov	r18, r17
    1d0c:	30 e0       	ldi	r19, 0x00	; 0
    1d0e:	80 e0       	ldi	r24, 0x00	; 0
    1d10:	90 e0       	ldi	r25, 0x00	; 0
    1d12:	49 81       	ldd	r20, Y+1	; 0x01
    1d14:	42 30       	cpi	r20, 0x02	; 2
    1d16:	10 f4       	brcc	.+4      	; 0x1d1c <nastav+0x170>
    1d18:	81 e0       	ldi	r24, 0x01	; 1
    1d1a:	90 e0       	ldi	r25, 0x00	; 0
    1d1c:	82 17       	cp	r24, r18
    1d1e:	93 07       	cpc	r25, r19
    1d20:	14 f0       	brlt	.+4      	; 0x1d26 <nastav+0x17a>
    1d22:	1f 2d       	mov	r17, r15
    1d24:	13 c0       	rjmp	.+38     	; 0x1d4c <nastav+0x1a0>
	    if ((bcdToDec(p_udaj--) % 10) == 0)
    1d26:	41 2f       	mov	r20, r17
    1d28:	41 50       	subi	r20, 0x01	; 1
    1d2a:	21 2f       	mov	r18, r17
    1d2c:	22 95       	swap	r18
    1d2e:	2f 70       	andi	r18, 0x0F	; 15
    1d30:	2e 9d       	mul	r18, r14
    1d32:	90 01       	movw	r18, r0
    1d34:	11 24       	eor	r1, r1
    1d36:	81 2f       	mov	r24, r17
    1d38:	8f 70       	andi	r24, 0x0F	; 15
    1d3a:	82 0f       	add	r24, r18
    1d3c:	6a e0       	ldi	r22, 0x0A	; 10
    1d3e:	0e 94 99 13 	call	0x2732	; 0x2732 <__udivmodqi4>
    1d42:	99 23       	and	r25, r25
    1d44:	11 f0       	breq	.+4      	; 0x1d4a <nastav+0x19e>
    1d46:	14 2f       	mov	r17, r20
    1d48:	01 c0       	rjmp	.+2      	; 0x1d4c <nastav+0x1a0>
		  p_udaj -= 6;
    1d4a:	17 50       	subi	r17, 0x07	; 7
    1d4c:	88 ee       	ldi	r24, 0xE8	; 232
    1d4e:	93 e0       	ldi	r25, 0x03	; 3
    1d50:	f5 01       	movw	r30, r10
    1d52:	31 97       	sbiw	r30, 0x01	; 1
    1d54:	f1 f7       	brne	.-4      	; 0x1d52 <nastav+0x1a6>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1d56:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1d58:	d9 f7       	brne	.-10     	; 0x1d50 <nastav+0x1a4>
	  } else p_udaj = val;
	  _delay_ms(100);
	}
	if (bit_is_set(PINC, 0)) {										//pri stlaceni tlacitka 0 uloz hodnoty do DS1307
    1d5a:	30 9b       	sbis	0x06, 0	; 6
    1d5c:	0e c0       	rjmp	.+28     	; 0x1d7a <nastav+0x1ce>
	  write_ds1307(addr, p_udaj);
    1d5e:	80 2f       	mov	r24, r16
    1d60:	61 2f       	mov	r22, r17
    1d62:	0e 94 31 01 	call	0x262	; 0x262 <write_ds1307>
	  if (addr == 5)
    1d66:	05 30       	cpi	r16, 0x05	; 5
    1d68:	29 f4       	brne	.+10     	; 0x1d74 <nastav+0x1c8>
	    udaje.mes = read_ds1307(addr);
    1d6a:	85 e0       	ldi	r24, 0x05	; 5
    1d6c:	0e 94 45 01 	call	0x28a	; 0x28a <read_ds1307>
    1d70:	80 93 39 04 	sts	0x0439, r24
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    1d74:	30 99       	sbic	0x06, 0	; 6
    1d76:	fe cf       	rjmp	.-4      	; 0x1d74 <nastav+0x1c8>
    1d78:	04 c0       	rjmp	.+8      	; 0x1d82 <nastav+0x1d6>
	  if (addr == 5)
	    udaje.mes = read_ds1307(addr);
	  cakaj(0);
	  break;
	}
	if (bit_is_set(PINC, 4)) {
    1d7a:	34 9b       	sbis	0x06, 4	; 6
    1d7c:	76 cf       	rjmp	.-276    	; 0x1c6a <nastav+0xbe>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    1d7e:	34 99       	sbic	0x06, 4	; 6
    1d80:	fe cf       	rjmp	.-4      	; 0x1d7e <nastav+0x1d2>
	if (bit_is_set(PINC, 4)) {
	  cakaj(4);
	  return;
	}
  }
}
    1d82:	0f 90       	pop	r0
    1d84:	cf 91       	pop	r28
    1d86:	df 91       	pop	r29
    1d88:	1f 91       	pop	r17
    1d8a:	0f 91       	pop	r16
    1d8c:	ff 90       	pop	r15
    1d8e:	ef 90       	pop	r14
    1d90:	df 90       	pop	r13
    1d92:	cf 90       	pop	r12
    1d94:	bf 90       	pop	r11
    1d96:	af 90       	pop	r10
    1d98:	9f 90       	pop	r9
    1d9a:	8f 90       	pop	r8
    1d9c:	7f 90       	pop	r7
    1d9e:	6f 90       	pop	r6
    1da0:	5f 90       	pop	r5
    1da2:	4f 90       	pop	r4
    1da4:	08 95       	ret

00001da6 <nastav_datum>:
//----------------------------------------------------------------------
char nastav_datum(void)
{
  unsigned char pom;

  nastav(str_pis[5], 0x99, 6);			// nastavenie roku
    1da6:	80 91 15 03 	lds	r24, 0x0315
    1daa:	90 91 16 03 	lds	r25, 0x0316
    1dae:	69 e9       	ldi	r22, 0x99	; 153
    1db0:	46 e0       	ldi	r20, 0x06	; 6
    1db2:	0e 94 d6 0d 	call	0x1bac	; 0x1bac <nastav>
  nastav(str_pis[4], 0x12, 5);			//nastavenie mesiaca
    1db6:	80 91 13 03 	lds	r24, 0x0313
    1dba:	90 91 14 03 	lds	r25, 0x0314
    1dbe:	62 e1       	ldi	r22, 0x12	; 18
    1dc0:	45 e0       	ldi	r20, 0x05	; 5
    1dc2:	0e 94 d6 0d 	call	0x1bac	; 0x1bac <nastav>
  pom = pct_dni[(unsigned char)bcdToDec(udaje.mes)-1];
    1dc6:	20 91 39 04 	lds	r18, 0x0439
    1dca:	82 2f       	mov	r24, r18
    1dcc:	82 95       	swap	r24
    1dce:	8f 70       	andi	r24, 0x0F	; 15
    1dd0:	3a e0       	ldi	r19, 0x0A	; 10
    1dd2:	83 9f       	mul	r24, r19
    1dd4:	c0 01       	movw	r24, r0
    1dd6:	11 24       	eor	r1, r1
    1dd8:	e2 2f       	mov	r30, r18
    1dda:	ef 70       	andi	r30, 0x0F	; 15
    1ddc:	e8 0f       	add	r30, r24
    1dde:	f0 e0       	ldi	r31, 0x00	; 0
    1de0:	ea 5e       	subi	r30, 0xEA	; 234
    1de2:	fc 4f       	sbci	r31, 0xFC	; 252
    1de4:	60 81       	ld	r22, Z
  if ((udaje.mes == 2) && ((bcdToDec(udaje.rok) % 4) == 0))			//ak je februar a rok delitelny 4 potom
    1de6:	22 30       	cpi	r18, 0x02	; 2
    1de8:	81 f4       	brne	.+32     	; 0x1e0a <nastav_datum+0x64>
    1dea:	80 91 3a 04 	lds	r24, 0x043A
    1dee:	28 2f       	mov	r18, r24
    1df0:	22 95       	swap	r18
    1df2:	2f 70       	andi	r18, 0x0F	; 15
    1df4:	23 9f       	mul	r18, r19
    1df6:	90 01       	movw	r18, r0
    1df8:	11 24       	eor	r1, r1
    1dfa:	8f 70       	andi	r24, 0x0F	; 15
    1dfc:	82 0f       	add	r24, r18
    1dfe:	90 e0       	ldi	r25, 0x00	; 0
    1e00:	83 70       	andi	r24, 0x03	; 3
    1e02:	90 70       	andi	r25, 0x00	; 0
    1e04:	89 2b       	or	r24, r25
    1e06:	09 f4       	brne	.+2      	; 0x1e0a <nastav_datum+0x64>
    pom++;															//zvacsi zobrazene dni (pom) o 1 (29)
    1e08:	6f 5f       	subi	r22, 0xFF	; 255
  nastav(str_pis[3], pom, 4);		// nastavenie dna	// pom - max zobrazena hodnota
    1e0a:	80 91 11 03 	lds	r24, 0x0311
    1e0e:	90 91 12 03 	lds	r25, 0x0312
    1e12:	44 e0       	ldi	r20, 0x04	; 4
    1e14:	0e 94 d6 0d 	call	0x1bac	; 0x1bac <nastav>
  return 0;
}
    1e18:	80 e0       	ldi	r24, 0x00	; 0
    1e1a:	08 95       	ret

00001e1c <nastav_cas>:
  }
}
//----------------------------------------------------------------------
char nastav_cas(void)
{
  CHbit_nastav();							// pri nastaveni casu stopni cas
    1e1c:	0e 94 87 02 	call	0x50e	; 0x50e <CHbit_nastav>
  ch_bit = 1;
    1e20:	81 e0       	ldi	r24, 0x01	; 1
    1e22:	80 93 1e 04 	sts	0x041E, r24
  nastav(str_pis[2], 0x23, 2);		// nastavenie kazdeho udaju
    1e26:	80 91 0f 03 	lds	r24, 0x030F
    1e2a:	90 91 10 03 	lds	r25, 0x0310
    1e2e:	63 e2       	ldi	r22, 0x23	; 35
    1e30:	42 e0       	ldi	r20, 0x02	; 2
    1e32:	0e 94 d6 0d 	call	0x1bac	; 0x1bac <nastav>
  nastav(str_pis[1], 0x59, 1);
    1e36:	80 91 0d 03 	lds	r24, 0x030D
    1e3a:	90 91 0e 03 	lds	r25, 0x030E
    1e3e:	69 e5       	ldi	r22, 0x59	; 89
    1e40:	41 e0       	ldi	r20, 0x01	; 1
    1e42:	0e 94 d6 0d 	call	0x1bac	; 0x1bac <nastav>
  nastav(str_pis[0], 0x59, 0);
    1e46:	80 91 0b 03 	lds	r24, 0x030B
    1e4a:	90 91 0c 03 	lds	r25, 0x030C
    1e4e:	69 e5       	ldi	r22, 0x59	; 89
    1e50:	40 e0       	ldi	r20, 0x00	; 0
    1e52:	0e 94 d6 0d 	call	0x1bac	; 0x1bac <nastav>
  CHbit_nuluj();
    1e56:	0e 94 92 02 	call	0x524	; 0x524 <CHbit_nuluj>
  ch_bit = 0;
    1e5a:	10 92 1e 04 	sts	0x041E, r1
  return 0;
}
    1e5e:	80 e0       	ldi	r24, 0x00	; 0
    1e60:	08 95       	ret

00001e62 <zobraz_mon_temp>:
	}
  }
}
//----------------------------------------------------------------------
void zobraz_mon_temp(void)
{
    1e62:	cf 92       	push	r12
    1e64:	df 92       	push	r13
    1e66:	ef 92       	push	r14
    1e68:	ff 92       	push	r15
    1e6a:	0f 93       	push	r16
    1e6c:	1f 93       	push	r17
    1e6e:	cf 93       	push	r28
    1e70:	df 93       	push	r29
  unsigned char i;  

  LCDclr();
    1e72:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <LCDclr>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    1e76:	31 99       	sbic	0x06, 1	; 6
    1e78:	fe cf       	rjmp	.-4      	; 0x1e76 <zobraz_mon_temp+0x14>
  LCDclr();
  cakaj(1);
  
  for (;;) {
    LCDhome();
    sprintf(lcd_dis[0], "MIN:%+2d\xdf", mon_udaje.min_temp);	// pre zobrazenie monitorovanej teploty pouzit lcd_dis
    1e7a:	cc ef       	ldi	r28, 0xFC	; 252
    1e7c:	d3 e0       	ldi	r29, 0x03	; 3
    1e7e:	ec e0       	ldi	r30, 0x0C	; 12
    1e80:	ce 2e       	mov	r12, r30
    1e82:	e2 e0       	ldi	r30, 0x02	; 2
    1e84:	de 2e       	mov	r13, r30
    sprintf(lcd_dis[1], "MAX:%+2d\xdf", mon_udaje.max_temp);
    1e86:	8e 01       	movw	r16, r28
    1e88:	0f 5e       	subi	r16, 0xEF	; 239
    1e8a:	1f 4f       	sbci	r17, 0xFF	; 255
    1e8c:	76 e1       	ldi	r23, 0x16	; 22
    1e8e:	e7 2e       	mov	r14, r23
    1e90:	72 e0       	ldi	r23, 0x02	; 2
    1e92:	f7 2e       	mov	r15, r23

  LCDclr();
  cakaj(1);
  
  for (;;) {
    LCDhome();
    1e94:	0e 94 d6 01 	call	0x3ac	; 0x3ac <LCDhome>
    sprintf(lcd_dis[0], "MIN:%+2d\xdf", mon_udaje.min_temp);	// pre zobrazenie monitorovanej teploty pouzit lcd_dis
    1e98:	00 d0       	rcall	.+0      	; 0x1e9a <zobraz_mon_temp+0x38>
    1e9a:	00 d0       	rcall	.+0      	; 0x1e9c <zobraz_mon_temp+0x3a>
    1e9c:	00 d0       	rcall	.+0      	; 0x1e9e <zobraz_mon_temp+0x3c>
    1e9e:	ed b7       	in	r30, 0x3d	; 61
    1ea0:	fe b7       	in	r31, 0x3e	; 62
    1ea2:	31 96       	adiw	r30, 0x01	; 1
    1ea4:	ad b7       	in	r26, 0x3d	; 61
    1ea6:	be b7       	in	r27, 0x3e	; 62
    1ea8:	12 96       	adiw	r26, 0x02	; 2
    1eaa:	dc 93       	st	X, r29
    1eac:	ce 93       	st	-X, r28
    1eae:	11 97       	sbiw	r26, 0x01	; 1
    1eb0:	d3 82       	std	Z+3, r13	; 0x03
    1eb2:	c2 82       	std	Z+2, r12	; 0x02
    1eb4:	80 91 2b 04 	lds	r24, 0x042B
    1eb8:	84 83       	std	Z+4, r24	; 0x04
    1eba:	15 82       	std	Z+5, r1	; 0x05
    1ebc:	0e 94 24 11 	call	0x2248	; 0x2248 <sprintf>
    sprintf(lcd_dis[1], "MAX:%+2d\xdf", mon_udaje.max_temp);
    1ec0:	ed b7       	in	r30, 0x3d	; 61
    1ec2:	fe b7       	in	r31, 0x3e	; 62
    1ec4:	31 96       	adiw	r30, 0x01	; 1
    1ec6:	ad b7       	in	r26, 0x3d	; 61
    1ec8:	be b7       	in	r27, 0x3e	; 62
    1eca:	12 96       	adiw	r26, 0x02	; 2
    1ecc:	1c 93       	st	X, r17
    1ece:	0e 93       	st	-X, r16
    1ed0:	11 97       	sbiw	r26, 0x01	; 1
    1ed2:	f3 82       	std	Z+3, r15	; 0x03
    1ed4:	e2 82       	std	Z+2, r14	; 0x02
    1ed6:	80 91 2f 04 	lds	r24, 0x042F
    1eda:	84 83       	std	Z+4, r24	; 0x04
    1edc:	15 82       	std	Z+5, r1	; 0x05
    1ede:	0e 94 24 11 	call	0x2248	; 0x2248 <sprintf>
    LCDstring(lcd_dis[0], strlen(lcd_dis[0]));LCDsendChar('C');
    1ee2:	de 01       	movw	r26, r28
    1ee4:	0d 90       	ld	r0, X+
    1ee6:	00 20       	and	r0, r0
    1ee8:	e9 f7       	brne	.-6      	; 0x1ee4 <zobraz_mon_temp+0x82>
    1eea:	11 97       	sbiw	r26, 0x01	; 1
    1eec:	ac 1b       	sub	r26, r28
    1eee:	bd 0b       	sbc	r27, r29
    1ef0:	8d b7       	in	r24, 0x3d	; 61
    1ef2:	9e b7       	in	r25, 0x3e	; 62
    1ef4:	06 96       	adiw	r24, 0x06	; 6
    1ef6:	0f b6       	in	r0, 0x3f	; 63
    1ef8:	f8 94       	cli
    1efa:	9e bf       	out	0x3e, r25	; 62
    1efc:	0f be       	out	0x3f, r0	; 63
    1efe:	8d bf       	out	0x3d, r24	; 61
    1f00:	ce 01       	movw	r24, r28
    1f02:	6a 2f       	mov	r22, r26
    1f04:	0e 94 da 01 	call	0x3b4	; 0x3b4 <LCDstring>
    1f08:	83 e4       	ldi	r24, 0x43	; 67
    1f0a:	0e 94 5c 01 	call	0x2b8	; 0x2b8 <LCDsendChar>
    LCDGotoXY(0,1);
    1f0e:	80 e0       	ldi	r24, 0x00	; 0
    1f10:	61 e0       	ldi	r22, 0x01	; 1
    1f12:	0e 94 ef 01 	call	0x3de	; 0x3de <LCDGotoXY>
    LCDstring(lcd_dis[1], strlen(lcd_dis[1]));LCDsendChar('C');
    1f16:	f8 01       	movw	r30, r16
    1f18:	01 90       	ld	r0, Z+
    1f1a:	00 20       	and	r0, r0
    1f1c:	e9 f7       	brne	.-6      	; 0x1f18 <zobraz_mon_temp+0xb6>
    1f1e:	ee 50       	subi	r30, 0x0E	; 14
    1f20:	f4 40       	sbci	r31, 0x04	; 4
    1f22:	c8 01       	movw	r24, r16
    1f24:	6e 2f       	mov	r22, r30
    1f26:	0e 94 da 01 	call	0x3b4	; 0x3b4 <LCDstring>
    1f2a:	83 e4       	ldi	r24, 0x43	; 67
    1f2c:	0e 94 5c 01 	call	0x2b8	; 0x2b8 <LCDsendChar>
	if (bit_is_set(PINC, 1)) {									// pri stlaceni tlacitka 1 vrat sa spat na default zobrazovanie
    1f30:	31 9b       	sbis	0x06, 1	; 6
    1f32:	05 c0       	rjmp	.+10     	; 0x1f3e <zobraz_mon_temp+0xdc>
	  LCDclr();
    1f34:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <LCDclr>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    1f38:	31 99       	sbic	0x06, 1	; 6
    1f3a:	fe cf       	rjmp	.-4      	; 0x1f38 <zobraz_mon_temp+0xd6>
    1f3c:	40 c0       	rjmp	.+128    	; 0x1fbe <zobraz_mon_temp+0x15c>
	if (bit_is_set(PINC, 1)) {									// pri stlaceni tlacitka 1 vrat sa spat na default zobrazovanie
	  LCDclr();
	  cakaj(1);
	  break;
	}
	if (bit_is_set(PINC, 0)) {									// pri stlaceni tlacitka 0 uloz zaznam do EEPROM
    1f3e:	30 9b       	sbis	0x06, 0	; 6
    1f40:	a9 cf       	rjmp	.-174    	; 0x1e94 <zobraz_mon_temp+0x32>
	  for (i = 0; i < 8; i++) {
	    EEPROM_CAKAJ;
		eeprom_write_byte(i,p_mon[i]);
    1f42:	20 91 69 02 	lds	r18, 0x0269
    1f46:	30 91 6a 02 	lds	r19, 0x026A
    1f4a:	80 e0       	ldi	r24, 0x00	; 0
    1f4c:	90 e0       	ldi	r25, 0x00	; 0
	  cakaj(1);
	  break;
	}
	if (bit_is_set(PINC, 0)) {									// pri stlaceni tlacitka 0 uloz zaznam do EEPROM
	  for (i = 0; i < 8; i++) {
	    EEPROM_CAKAJ;
    1f4e:	f9 99       	sbic	0x1f, 1	; 31
    1f50:	fe cf       	rjmp	.-4      	; 0x1f4e <zobraz_mon_temp+0xec>
		eeprom_write_byte(i,p_mon[i]);
    1f52:	f9 01       	movw	r30, r18
    1f54:	e8 0f       	add	r30, r24
    1f56:	f9 1f       	adc	r31, r25
    1f58:	e0 81       	ld	r30, Z
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    1f5a:	f9 99       	sbic	0x1f, 1	; 31
    1f5c:	fe cf       	rjmp	.-4      	; 0x1f5a <zobraz_mon_temp+0xf8>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    1f5e:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    1f60:	92 bd       	out	0x22, r25	; 34
    1f62:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
    1f64:	e0 bd       	out	0x20, r30	; 32

    __asm__ __volatile__ (
    1f66:	0f b6       	in	r0, 0x3f	; 63
    1f68:	f8 94       	cli
    1f6a:	fa 9a       	sbi	0x1f, 2	; 31
    1f6c:	f9 9a       	sbi	0x1f, 1	; 31
    1f6e:	0f be       	out	0x3f, r0	; 63
    1f70:	01 96       	adiw	r24, 0x01	; 1
	  LCDclr();
	  cakaj(1);
	  break;
	}
	if (bit_is_set(PINC, 0)) {									// pri stlaceni tlacitka 0 uloz zaznam do EEPROM
	  for (i = 0; i < 8; i++) {
    1f72:	88 30       	cpi	r24, 0x08	; 8
    1f74:	91 05       	cpc	r25, r1
    1f76:	59 f7       	brne	.-42     	; 0x1f4e <zobraz_mon_temp+0xec>
	    EEPROM_CAKAJ;
		eeprom_write_byte(i,p_mon[i]);
	  }
	  LCDclr();
    1f78:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <LCDclr>
	  strcpy(lcd_dis[0], "Hodnoty ulozene ");
    1f7c:	8c ef       	ldi	r24, 0xFC	; 252
    1f7e:	93 e0       	ldi	r25, 0x03	; 3
    1f80:	60 e2       	ldi	r22, 0x20	; 32
    1f82:	72 e0       	ldi	r23, 0x02	; 2
    1f84:	0e 94 dc 10 	call	0x21b8	; 0x21b8 <strcpy>
	  strcpy(lcd_dis[1], "v pamati        ");
    1f88:	8d e0       	ldi	r24, 0x0D	; 13
    1f8a:	94 e0       	ldi	r25, 0x04	; 4
    1f8c:	61 e3       	ldi	r22, 0x31	; 49
    1f8e:	72 e0       	ldi	r23, 0x02	; 2
    1f90:	0e 94 dc 10 	call	0x21b8	; 0x21b8 <strcpy>
	  LCDstringXY(0, 0, lcd_dis[0], 16);
    1f94:	80 e0       	ldi	r24, 0x00	; 0
    1f96:	60 e0       	ldi	r22, 0x00	; 0
    1f98:	4c ef       	ldi	r20, 0xFC	; 252
    1f9a:	53 e0       	ldi	r21, 0x03	; 3
    1f9c:	20 e1       	ldi	r18, 0x10	; 16
    1f9e:	0e 94 25 03 	call	0x64a	; 0x64a <LCDstringXY>
	  LCDstringXY(0, 1, lcd_dis[1], 16);
    1fa2:	80 e0       	ldi	r24, 0x00	; 0
    1fa4:	61 e0       	ldi	r22, 0x01	; 1
    1fa6:	4d e0       	ldi	r20, 0x0D	; 13
    1fa8:	54 e0       	ldi	r21, 0x04	; 4
    1faa:	20 e1       	ldi	r18, 0x10	; 16
    1fac:	0e 94 25 03 	call	0x64a	; 0x64a <LCDstringXY>
	  while (1) {
	    if (bit_is_set(PINC, 0)) {
    1fb0:	30 9b       	sbis	0x06, 0	; 6
    1fb2:	fe cf       	rjmp	.-4      	; 0x1fb0 <zobraz_mon_temp+0x14e>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    1fb4:	30 99       	sbic	0x06, 0	; 6
    1fb6:	fe cf       	rjmp	.-4      	; 0x1fb4 <zobraz_mon_temp+0x152>
	    if (bit_is_set(PINC, 0)) {
		  cakaj(0);
		  break;
		}  
	  }
	  LCDclr();
    1fb8:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <LCDclr>
    1fbc:	6b cf       	rjmp	.-298    	; 0x1e94 <zobraz_mon_temp+0x32>
	}
  }
}
    1fbe:	df 91       	pop	r29
    1fc0:	cf 91       	pop	r28
    1fc2:	1f 91       	pop	r17
    1fc4:	0f 91       	pop	r16
    1fc6:	ff 90       	pop	r15
    1fc8:	ef 90       	pop	r14
    1fca:	df 90       	pop	r13
    1fcc:	cf 90       	pop	r12
    1fce:	08 95       	ret

00001fd0 <display1>:
#ifndef Clock_F
#define Clock_F

//----------------------------------------------------------------------
void display1(void)					//samotne vypisanie (stav po spusteni)
{
    1fd0:	0f 93       	push	r16
    1fd2:	1f 93       	push	r17
    1fd4:	cf 93       	push	r28
    1fd6:	df 93       	push	r29
  LCDhome();
    1fd8:	0e 94 d6 01 	call	0x3ac	; 0x3ac <LCDhome>
  sprintf(lcd_dis[0], "%2x:%02x:%02x%+6d", udaje.hod, udaje.min, udaje.sek, ((udaje.teplota == 85) || (udaje.teplota == 84) || (udaje.teplota == 127)) ? 0 : udaje.teplota);				//prichystane na vypis
    1fdc:	cc ef       	ldi	r28, 0xFC	; 252
    1fde:	d3 e0       	ldi	r29, 0x03	; 3
    1fe0:	40 91 36 04 	lds	r20, 0x0436
    1fe4:	50 91 35 04 	lds	r21, 0x0435
    1fe8:	60 91 34 04 	lds	r22, 0x0434
    1fec:	90 91 33 04 	lds	r25, 0x0433
    1ff0:	89 2f       	mov	r24, r25
    1ff2:	84 55       	subi	r24, 0x54	; 84
    1ff4:	82 30       	cpi	r24, 0x02	; 2
    1ff6:	28 f0       	brcs	.+10     	; 0x2002 <display1+0x32>
    1ff8:	9f 37       	cpi	r25, 0x7F	; 127
    1ffa:	19 f0       	breq	.+6      	; 0x2002 <display1+0x32>
    1ffc:	29 2f       	mov	r18, r25
    1ffe:	30 e0       	ldi	r19, 0x00	; 0
    2000:	02 c0       	rjmp	.+4      	; 0x2006 <display1+0x36>
    2002:	20 e0       	ldi	r18, 0x00	; 0
    2004:	30 e0       	ldi	r19, 0x00	; 0
    2006:	8d b7       	in	r24, 0x3d	; 61
    2008:	9e b7       	in	r25, 0x3e	; 62
    200a:	0c 97       	sbiw	r24, 0x0c	; 12
    200c:	0f b6       	in	r0, 0x3f	; 63
    200e:	f8 94       	cli
    2010:	9e bf       	out	0x3e, r25	; 62
    2012:	0f be       	out	0x3f, r0	; 63
    2014:	8d bf       	out	0x3d, r24	; 61
    2016:	ed b7       	in	r30, 0x3d	; 61
    2018:	fe b7       	in	r31, 0x3e	; 62
    201a:	31 96       	adiw	r30, 0x01	; 1
    201c:	ad b7       	in	r26, 0x3d	; 61
    201e:	be b7       	in	r27, 0x3e	; 62
    2020:	12 96       	adiw	r26, 0x02	; 2
    2022:	dc 93       	st	X, r29
    2024:	ce 93       	st	-X, r28
    2026:	11 97       	sbiw	r26, 0x01	; 1
    2028:	82 e4       	ldi	r24, 0x42	; 66
    202a:	92 e0       	ldi	r25, 0x02	; 2
    202c:	93 83       	std	Z+3, r25	; 0x03
    202e:	82 83       	std	Z+2, r24	; 0x02
    2030:	44 83       	std	Z+4, r20	; 0x04
    2032:	15 82       	std	Z+5, r1	; 0x05
    2034:	56 83       	std	Z+6, r21	; 0x06
    2036:	17 82       	std	Z+7, r1	; 0x07
    2038:	60 87       	std	Z+8, r22	; 0x08
    203a:	11 86       	std	Z+9, r1	; 0x09
    203c:	33 87       	std	Z+11, r19	; 0x0b
    203e:	22 87       	std	Z+10, r18	; 0x0a
    2040:	0e 94 24 11 	call	0x2248	; 0x2248 <sprintf>
  sprintf(lcd_dis[1], "%3s  %2x.%2x. 20%02x", dni[udaje.mDen - 1], udaje.den, udaje.mes, udaje.rok);	//taktiez vyplnim lcd_dis pole ktore je
    2044:	ad b7       	in	r26, 0x3d	; 61
    2046:	be b7       	in	r27, 0x3e	; 62
    2048:	11 96       	adiw	r26, 0x01	; 1
    204a:	8e 01       	movw	r16, r28
    204c:	0f 5e       	subi	r16, 0xEF	; 239
    204e:	1f 4f       	sbci	r17, 0xFF	; 255
    2050:	ed b7       	in	r30, 0x3d	; 61
    2052:	fe b7       	in	r31, 0x3e	; 62
    2054:	12 83       	std	Z+2, r17	; 0x02
    2056:	01 83       	std	Z+1, r16	; 0x01
    2058:	84 e5       	ldi	r24, 0x54	; 84
    205a:	92 e0       	ldi	r25, 0x02	; 2
    205c:	13 96       	adiw	r26, 0x03	; 3
    205e:	9c 93       	st	X, r25
    2060:	8e 93       	st	-X, r24
    2062:	12 97       	sbiw	r26, 0x02	; 2
    2064:	e0 91 37 04 	lds	r30, 0x0437
    2068:	f0 e0       	ldi	r31, 0x00	; 0
    206a:	ee 0f       	add	r30, r30
    206c:	ff 1f       	adc	r31, r31
    206e:	e7 57       	subi	r30, 0x77	; 119
    2070:	fd 4f       	sbci	r31, 0xFD	; 253
    2072:	80 81       	ld	r24, Z
    2074:	91 81       	ldd	r25, Z+1	; 0x01
    2076:	15 96       	adiw	r26, 0x05	; 5
    2078:	9c 93       	st	X, r25
    207a:	8e 93       	st	-X, r24
    207c:	14 97       	sbiw	r26, 0x04	; 4
    207e:	80 91 38 04 	lds	r24, 0x0438
    2082:	16 96       	adiw	r26, 0x06	; 6
    2084:	8c 93       	st	X, r24
    2086:	16 97       	sbiw	r26, 0x06	; 6
    2088:	17 96       	adiw	r26, 0x07	; 7
    208a:	1c 92       	st	X, r1
    208c:	17 97       	sbiw	r26, 0x07	; 7
    208e:	80 91 39 04 	lds	r24, 0x0439
    2092:	18 96       	adiw	r26, 0x08	; 8
    2094:	8c 93       	st	X, r24
    2096:	18 97       	sbiw	r26, 0x08	; 8
    2098:	19 96       	adiw	r26, 0x09	; 9
    209a:	1c 92       	st	X, r1
    209c:	19 97       	sbiw	r26, 0x09	; 9
    209e:	80 91 3a 04 	lds	r24, 0x043A
    20a2:	1a 96       	adiw	r26, 0x0a	; 10
    20a4:	8c 93       	st	X, r24
    20a6:	1a 97       	sbiw	r26, 0x0a	; 10
    20a8:	1b 96       	adiw	r26, 0x0b	; 11
    20aa:	1c 92       	st	X, r1
    20ac:	0e 94 24 11 	call	0x2248	; 0x2248 <sprintf>
  LCDstring(lcd_dis[0], strlen(lcd_dis[0]));
    20b0:	de 01       	movw	r26, r28
    20b2:	0d 90       	ld	r0, X+
    20b4:	00 20       	and	r0, r0
    20b6:	e9 f7       	brne	.-6      	; 0x20b2 <display1+0xe2>
    20b8:	11 97       	sbiw	r26, 0x01	; 1
    20ba:	ac 1b       	sub	r26, r28
    20bc:	bd 0b       	sbc	r27, r29
    20be:	8d b7       	in	r24, 0x3d	; 61
    20c0:	9e b7       	in	r25, 0x3e	; 62
    20c2:	0c 96       	adiw	r24, 0x0c	; 12
    20c4:	0f b6       	in	r0, 0x3f	; 63
    20c6:	f8 94       	cli
    20c8:	9e bf       	out	0x3e, r25	; 62
    20ca:	0f be       	out	0x3f, r0	; 63
    20cc:	8d bf       	out	0x3d, r24	; 61
    20ce:	ce 01       	movw	r24, r28
    20d0:	6a 2f       	mov	r22, r26
    20d2:	0e 94 da 01 	call	0x3b4	; 0x3b4 <LCDstring>
  LCDsendChar(0xdf);LCDsendChar('C');
    20d6:	8f ed       	ldi	r24, 0xDF	; 223
    20d8:	0e 94 5c 01 	call	0x2b8	; 0x2b8 <LCDsendChar>
    20dc:	83 e4       	ldi	r24, 0x43	; 67
    20de:	0e 94 5c 01 	call	0x2b8	; 0x2b8 <LCDsendChar>
  LCDGotoXY(0,1);
    20e2:	80 e0       	ldi	r24, 0x00	; 0
    20e4:	61 e0       	ldi	r22, 0x01	; 1
    20e6:	0e 94 ef 01 	call	0x3de	; 0x3de <LCDGotoXY>
  LCDstring(lcd_dis[1], strlen(lcd_dis[1]));
    20ea:	f8 01       	movw	r30, r16
    20ec:	01 90       	ld	r0, Z+
    20ee:	00 20       	and	r0, r0
    20f0:	e9 f7       	brne	.-6      	; 0x20ec <display1+0x11c>
    20f2:	ee 50       	subi	r30, 0x0E	; 14
    20f4:	f4 40       	sbci	r31, 0x04	; 4
    20f6:	c8 01       	movw	r24, r16
    20f8:	6e 2f       	mov	r22, r30
    20fa:	0e 94 da 01 	call	0x3b4	; 0x3b4 <LCDstring>
}
    20fe:	df 91       	pop	r29
    2100:	cf 91       	pop	r28
    2102:	1f 91       	pop	r17
    2104:	0f 91       	pop	r16
    2106:	08 95       	ret

00002108 <main>:
  TIMSK0 = 1;
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
int main(void)
{
    2108:	1f 93       	push	r17
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void nastav_casovac0(char tcra, char tcrb, char tnt, char s)
{
  TCCR0A=tcra;
    210a:	14 bc       	out	0x24, r1	; 36
  TCCR0B=tcrb;
    210c:	84 e0       	ldi	r24, 0x04	; 4
    210e:	85 bd       	out	0x25, r24	; 37
  TCNT0=tnt;
    2110:	16 bc       	out	0x26, r1	; 38
  TIMSK0=s;
    2112:	11 e0       	ldi	r17, 0x01	; 1
    2114:	10 93 6e 00 	sts	0x006E, r17
}
//----------------------------------------------------------------------
void nastav_casovac2(char tcra, char tcrb, char tnt, char s)
{
  TCCR2A=tcra;
    2118:	10 92 b0 00 	sts	0x00B0, r1
  TCCR2B=tcrb;
    211c:	87 e0       	ldi	r24, 0x07	; 7
    211e:	80 93 b1 00 	sts	0x00B1, r24
  TCNT2=tnt;
    2122:	10 92 b2 00 	sts	0x00B2, r1
  TIMSK2=s;  
    2126:	10 93 70 00 	sts	0x0070, r17
{
  unsigned char p;

  nastav_casovac0(0, 4, 0, 1);
  nastav_casovac2(0, 7, 0, 1);
  udaje.teplota = 84;
    212a:	84 e5       	ldi	r24, 0x54	; 84
    212c:	80 93 33 04 	sts	0x0433, r24
}
//----------------------------------------------------------------------
/* 19200kbps 8N1 */
void USART_Init(void)
{
  UCSR0A = 0x00;
    2130:	10 92 c0 00 	sts	0x00C0, r1
  UCSR0B = 0x98;
    2134:	88 e9       	ldi	r24, 0x98	; 152
    2136:	80 93 c1 00 	sts	0x00C1, r24
  UCSR0C = 0x06;
    213a:	86 e0       	ldi	r24, 0x06	; 6
    213c:	80 93 c2 00 	sts	0x00C2, r24
  UBRR0H = 0x00;
    2140:	10 92 c5 00 	sts	0x00C5, r1
  UBRR0L = 0x19;
    2144:	89 e1       	ldi	r24, 0x19	; 25
    2146:	80 93 c4 00 	sts	0x00C4, r24
  USART_Init();
  LCDinit();
    214a:	0e 94 9e 01 	call	0x33c	; 0x33c <LCDinit>
  LCDcursorOFF();
    214e:	0e 94 5f 02 	call	0x4be	; 0x4be <LCDcursorOFF>
  CHbit_nuluj();			// pre istotu (pri "nekorektnom" vypnuti, tj. pocas konfiguracie casu - vid pozn.)  
    2152:	0e 94 92 02 	call	0x524	; 0x524 <CHbit_nuluj>

  DDRD &= ~0x10;			//tlacitko pre podsvietenie
    2156:	54 98       	cbi	0x0a, 4	; 10
  DDRD |= 4;				//vystup pre podsvietenie displeja
    2158:	52 9a       	sbi	0x0a, 2	; 10
  DDRC = 0x8;				//DDRC (vstup) 0,1,2,4,5 - tlacitka, (vystup) 3 - speaker
    215a:	88 e0       	ldi	r24, 0x08	; 8
    215c:	87 b9       	out	0x07, r24	; 7
  PORTC &= ~0x8;			// PORTC 3 - log 0 na vystupe
    215e:	43 98       	cbi	0x08, 3	; 8
  alarm.al_den = 1;
    2160:	10 93 27 04 	sts	0x0427, r17
    2164:	20 e0       	ldi	r18, 0x00	; 0
    2166:	30 e0       	ldi	r19, 0x00	; 0

  for (p = 0; p < 8; p++) {
    EEPROM_CAKAJ;
    2168:	f9 99       	sbic	0x1f, 1	; 31
    216a:	fe cf       	rjmp	.-4      	; 0x2168 <main+0x60>
    p_mon[p] = eeprom_read_byte(p);
    216c:	e0 91 69 02 	lds	r30, 0x0269
    2170:	f0 91 6a 02 	lds	r31, 0x026A
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2174:	f9 99       	sbic	0x1f, 1	; 31
    2176:	fe cf       	rjmp	.-4      	; 0x2174 <main+0x6c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2178:	32 bd       	out	0x22, r19	; 34
    217a:	21 bd       	out	0x21, r18	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    217c:	f8 9a       	sbi	0x1f, 0	; 31
    217e:	80 b5       	in	r24, 0x20	; 32
    2180:	e2 0f       	add	r30, r18
    2182:	f3 1f       	adc	r31, r19
    2184:	80 83       	st	Z, r24
    2186:	2f 5f       	subi	r18, 0xFF	; 255
    2188:	3f 4f       	sbci	r19, 0xFF	; 255
  DDRD |= 4;				//vystup pre podsvietenie displeja
  DDRC = 0x8;				//DDRC (vstup) 0,1,2,4,5 - tlacitka, (vystup) 3 - speaker
  PORTC &= ~0x8;			// PORTC 3 - log 0 na vystupe
  alarm.al_den = 1;

  for (p = 0; p < 8; p++) {
    218a:	28 30       	cpi	r18, 0x08	; 8
    218c:	31 05       	cpc	r19, r1
    218e:	61 f7       	brne	.-40     	; 0x2168 <main+0x60>
    EEPROM_CAKAJ;
    p_mon[p] = eeprom_read_byte(p);
  }
  
  asm("sei");
    2190:	78 94       	sei

  while (1) {
    display1();
    2192:	0e 94 e8 0f 	call	0x1fd0	; 0x1fd0 <display1>
	if (prac_stav == 0) {
    2196:	80 91 f4 03 	lds	r24, 0x03F4
    219a:	88 23       	and	r24, r24
    219c:	d1 f7       	brne	.-12     	; 0x2192 <main+0x8a>
	  if (bit_is_set(PINC, 0))
    219e:	30 9b       	sbis	0x06, 0	; 6
    21a0:	02 c0       	rjmp	.+4      	; 0x21a6 <main+0x9e>
	    konfig_hodiny();
    21a2:	0e 94 72 09 	call	0x12e4	; 0x12e4 <konfig_hodiny>
	  if (bit_is_set(PINC, 1)) {
    21a6:	31 9b       	sbis	0x06, 1	; 6
    21a8:	f4 cf       	rjmp	.-24     	; 0x2192 <main+0x8a>
	    if (udaje.mon_temp == 1)
    21aa:	80 91 3c 04 	lds	r24, 0x043C
    21ae:	81 30       	cpi	r24, 0x01	; 1
    21b0:	81 f7       	brne	.-32     	; 0x2192 <main+0x8a>
		  zobraz_mon_temp();
    21b2:	0e 94 31 0f 	call	0x1e62	; 0x1e62 <zobraz_mon_temp>
    21b6:	ed cf       	rjmp	.-38     	; 0x2192 <main+0x8a>

000021b8 <strcpy>:
    21b8:	fb 01       	movw	r30, r22
    21ba:	dc 01       	movw	r26, r24
    21bc:	01 90       	ld	r0, Z+
    21be:	0d 92       	st	X+, r0
    21c0:	00 20       	and	r0, r0
    21c2:	e1 f7       	brne	.-8      	; 0x21bc <strcpy+0x4>
    21c4:	08 95       	ret

000021c6 <fputc>:
    21c6:	0f 93       	push	r16
    21c8:	1f 93       	push	r17
    21ca:	cf 93       	push	r28
    21cc:	df 93       	push	r29
    21ce:	8c 01       	movw	r16, r24
    21d0:	eb 01       	movw	r28, r22
    21d2:	8b 81       	ldd	r24, Y+3	; 0x03
    21d4:	81 ff       	sbrs	r24, 1
    21d6:	1b c0       	rjmp	.+54     	; 0x220e <fputc+0x48>
    21d8:	82 ff       	sbrs	r24, 2
    21da:	0d c0       	rjmp	.+26     	; 0x21f6 <fputc+0x30>
    21dc:	2e 81       	ldd	r18, Y+6	; 0x06
    21de:	3f 81       	ldd	r19, Y+7	; 0x07
    21e0:	8c 81       	ldd	r24, Y+4	; 0x04
    21e2:	9d 81       	ldd	r25, Y+5	; 0x05
    21e4:	28 17       	cp	r18, r24
    21e6:	39 07       	cpc	r19, r25
    21e8:	64 f4       	brge	.+24     	; 0x2202 <fputc+0x3c>
    21ea:	e8 81       	ld	r30, Y
    21ec:	f9 81       	ldd	r31, Y+1	; 0x01
    21ee:	01 93       	st	Z+, r16
    21f0:	f9 83       	std	Y+1, r31	; 0x01
    21f2:	e8 83       	st	Y, r30
    21f4:	06 c0       	rjmp	.+12     	; 0x2202 <fputc+0x3c>
    21f6:	e8 85       	ldd	r30, Y+8	; 0x08
    21f8:	f9 85       	ldd	r31, Y+9	; 0x09
    21fa:	80 2f       	mov	r24, r16
    21fc:	09 95       	icall
    21fe:	89 2b       	or	r24, r25
    2200:	31 f4       	brne	.+12     	; 0x220e <fputc+0x48>
    2202:	8e 81       	ldd	r24, Y+6	; 0x06
    2204:	9f 81       	ldd	r25, Y+7	; 0x07
    2206:	01 96       	adiw	r24, 0x01	; 1
    2208:	9f 83       	std	Y+7, r25	; 0x07
    220a:	8e 83       	std	Y+6, r24	; 0x06
    220c:	02 c0       	rjmp	.+4      	; 0x2212 <fputc+0x4c>
    220e:	0f ef       	ldi	r16, 0xFF	; 255
    2210:	1f ef       	ldi	r17, 0xFF	; 255
    2212:	c8 01       	movw	r24, r16
    2214:	df 91       	pop	r29
    2216:	cf 91       	pop	r28
    2218:	1f 91       	pop	r17
    221a:	0f 91       	pop	r16
    221c:	08 95       	ret

0000221e <printf>:
    221e:	a0 e0       	ldi	r26, 0x00	; 0
    2220:	b0 e0       	ldi	r27, 0x00	; 0
    2222:	e5 e1       	ldi	r30, 0x15	; 21
    2224:	f1 e1       	ldi	r31, 0x11	; 17
    2226:	0c 94 dc 13 	jmp	0x27b8	; 0x27b8 <__prologue_saves__+0x20>
    222a:	fe 01       	movw	r30, r28
    222c:	35 96       	adiw	r30, 0x05	; 5
    222e:	61 91       	ld	r22, Z+
    2230:	71 91       	ld	r23, Z+
    2232:	80 91 4f 04 	lds	r24, 0x044F
    2236:	90 91 50 04 	lds	r25, 0x0450
    223a:	af 01       	movw	r20, r30
    223c:	0e 94 48 11 	call	0x2290	; 0x2290 <vfprintf>
    2240:	20 96       	adiw	r28, 0x00	; 0
    2242:	e2 e0       	ldi	r30, 0x02	; 2
    2244:	0c 94 f8 13 	jmp	0x27f0	; 0x27f0 <__epilogue_restores__+0x20>

00002248 <sprintf>:
    2248:	ae e0       	ldi	r26, 0x0E	; 14
    224a:	b0 e0       	ldi	r27, 0x00	; 0
    224c:	ea e2       	ldi	r30, 0x2A	; 42
    224e:	f1 e1       	ldi	r31, 0x11	; 17
    2250:	0c 94 da 13 	jmp	0x27b4	; 0x27b4 <__prologue_saves__+0x1c>
    2254:	0d 89       	ldd	r16, Y+21	; 0x15
    2256:	1e 89       	ldd	r17, Y+22	; 0x16
    2258:	86 e0       	ldi	r24, 0x06	; 6
    225a:	8c 83       	std	Y+4, r24	; 0x04
    225c:	1a 83       	std	Y+2, r17	; 0x02
    225e:	09 83       	std	Y+1, r16	; 0x01
    2260:	8f ef       	ldi	r24, 0xFF	; 255
    2262:	9f e7       	ldi	r25, 0x7F	; 127
    2264:	9e 83       	std	Y+6, r25	; 0x06
    2266:	8d 83       	std	Y+5, r24	; 0x05
    2268:	9e 01       	movw	r18, r28
    226a:	27 5e       	subi	r18, 0xE7	; 231
    226c:	3f 4f       	sbci	r19, 0xFF	; 255
    226e:	ce 01       	movw	r24, r28
    2270:	01 96       	adiw	r24, 0x01	; 1
    2272:	6f 89       	ldd	r22, Y+23	; 0x17
    2274:	78 8d       	ldd	r23, Y+24	; 0x18
    2276:	a9 01       	movw	r20, r18
    2278:	0e 94 48 11 	call	0x2290	; 0x2290 <vfprintf>
    227c:	2f 81       	ldd	r18, Y+7	; 0x07
    227e:	38 85       	ldd	r19, Y+8	; 0x08
    2280:	02 0f       	add	r16, r18
    2282:	13 1f       	adc	r17, r19
    2284:	f8 01       	movw	r30, r16
    2286:	10 82       	st	Z, r1
    2288:	2e 96       	adiw	r28, 0x0e	; 14
    228a:	e4 e0       	ldi	r30, 0x04	; 4
    228c:	0c 94 f6 13 	jmp	0x27ec	; 0x27ec <__epilogue_restores__+0x1c>

00002290 <vfprintf>:
    2290:	ab e0       	ldi	r26, 0x0B	; 11
    2292:	b0 e0       	ldi	r27, 0x00	; 0
    2294:	ee e4       	ldi	r30, 0x4E	; 78
    2296:	f1 e1       	ldi	r31, 0x11	; 17
    2298:	0c 94 cc 13 	jmp	0x2798	; 0x2798 <__prologue_saves__>
    229c:	3c 01       	movw	r6, r24
    229e:	2b 01       	movw	r4, r22
    22a0:	5a 01       	movw	r10, r20
    22a2:	fc 01       	movw	r30, r24
    22a4:	17 82       	std	Z+7, r1	; 0x07
    22a6:	16 82       	std	Z+6, r1	; 0x06
    22a8:	83 81       	ldd	r24, Z+3	; 0x03
    22aa:	81 fd       	sbrc	r24, 1
    22ac:	03 c0       	rjmp	.+6      	; 0x22b4 <vfprintf+0x24>
    22ae:	6f ef       	ldi	r22, 0xFF	; 255
    22b0:	7f ef       	ldi	r23, 0xFF	; 255
    22b2:	c6 c1       	rjmp	.+908    	; 0x2640 <vfprintf+0x3b0>
    22b4:	9a e0       	ldi	r25, 0x0A	; 10
    22b6:	89 2e       	mov	r8, r25
    22b8:	1e 01       	movw	r2, r28
    22ba:	08 94       	sec
    22bc:	21 1c       	adc	r2, r1
    22be:	31 1c       	adc	r3, r1
    22c0:	f3 01       	movw	r30, r6
    22c2:	23 81       	ldd	r18, Z+3	; 0x03
    22c4:	f2 01       	movw	r30, r4
    22c6:	23 fd       	sbrc	r18, 3
    22c8:	85 91       	lpm	r24, Z+
    22ca:	23 ff       	sbrs	r18, 3
    22cc:	81 91       	ld	r24, Z+
    22ce:	2f 01       	movw	r4, r30
    22d0:	88 23       	and	r24, r24
    22d2:	09 f4       	brne	.+2      	; 0x22d6 <vfprintf+0x46>
    22d4:	b2 c1       	rjmp	.+868    	; 0x263a <vfprintf+0x3aa>
    22d6:	85 32       	cpi	r24, 0x25	; 37
    22d8:	39 f4       	brne	.+14     	; 0x22e8 <vfprintf+0x58>
    22da:	23 fd       	sbrc	r18, 3
    22dc:	85 91       	lpm	r24, Z+
    22de:	23 ff       	sbrs	r18, 3
    22e0:	81 91       	ld	r24, Z+
    22e2:	2f 01       	movw	r4, r30
    22e4:	85 32       	cpi	r24, 0x25	; 37
    22e6:	29 f4       	brne	.+10     	; 0x22f2 <vfprintf+0x62>
    22e8:	90 e0       	ldi	r25, 0x00	; 0
    22ea:	b3 01       	movw	r22, r6
    22ec:	0e 94 e3 10 	call	0x21c6	; 0x21c6 <fputc>
    22f0:	e7 cf       	rjmp	.-50     	; 0x22c0 <vfprintf+0x30>
    22f2:	98 2f       	mov	r25, r24
    22f4:	ff 24       	eor	r15, r15
    22f6:	ee 24       	eor	r14, r14
    22f8:	99 24       	eor	r9, r9
    22fa:	ff e1       	ldi	r31, 0x1F	; 31
    22fc:	ff 15       	cp	r31, r15
    22fe:	d0 f0       	brcs	.+52     	; 0x2334 <vfprintf+0xa4>
    2300:	9b 32       	cpi	r25, 0x2B	; 43
    2302:	69 f0       	breq	.+26     	; 0x231e <vfprintf+0x8e>
    2304:	9c 32       	cpi	r25, 0x2C	; 44
    2306:	28 f4       	brcc	.+10     	; 0x2312 <vfprintf+0x82>
    2308:	90 32       	cpi	r25, 0x20	; 32
    230a:	59 f0       	breq	.+22     	; 0x2322 <vfprintf+0x92>
    230c:	93 32       	cpi	r25, 0x23	; 35
    230e:	91 f4       	brne	.+36     	; 0x2334 <vfprintf+0xa4>
    2310:	0e c0       	rjmp	.+28     	; 0x232e <vfprintf+0x9e>
    2312:	9d 32       	cpi	r25, 0x2D	; 45
    2314:	49 f0       	breq	.+18     	; 0x2328 <vfprintf+0x98>
    2316:	90 33       	cpi	r25, 0x30	; 48
    2318:	69 f4       	brne	.+26     	; 0x2334 <vfprintf+0xa4>
    231a:	41 e0       	ldi	r20, 0x01	; 1
    231c:	24 c0       	rjmp	.+72     	; 0x2366 <vfprintf+0xd6>
    231e:	52 e0       	ldi	r21, 0x02	; 2
    2320:	f5 2a       	or	r15, r21
    2322:	84 e0       	ldi	r24, 0x04	; 4
    2324:	f8 2a       	or	r15, r24
    2326:	28 c0       	rjmp	.+80     	; 0x2378 <vfprintf+0xe8>
    2328:	98 e0       	ldi	r25, 0x08	; 8
    232a:	f9 2a       	or	r15, r25
    232c:	25 c0       	rjmp	.+74     	; 0x2378 <vfprintf+0xe8>
    232e:	e0 e1       	ldi	r30, 0x10	; 16
    2330:	fe 2a       	or	r15, r30
    2332:	22 c0       	rjmp	.+68     	; 0x2378 <vfprintf+0xe8>
    2334:	f7 fc       	sbrc	r15, 7
    2336:	29 c0       	rjmp	.+82     	; 0x238a <vfprintf+0xfa>
    2338:	89 2f       	mov	r24, r25
    233a:	80 53       	subi	r24, 0x30	; 48
    233c:	8a 30       	cpi	r24, 0x0A	; 10
    233e:	70 f4       	brcc	.+28     	; 0x235c <vfprintf+0xcc>
    2340:	f6 fe       	sbrs	r15, 6
    2342:	05 c0       	rjmp	.+10     	; 0x234e <vfprintf+0xbe>
    2344:	98 9c       	mul	r9, r8
    2346:	90 2c       	mov	r9, r0
    2348:	11 24       	eor	r1, r1
    234a:	98 0e       	add	r9, r24
    234c:	15 c0       	rjmp	.+42     	; 0x2378 <vfprintf+0xe8>
    234e:	e8 9c       	mul	r14, r8
    2350:	e0 2c       	mov	r14, r0
    2352:	11 24       	eor	r1, r1
    2354:	e8 0e       	add	r14, r24
    2356:	f0 e2       	ldi	r31, 0x20	; 32
    2358:	ff 2a       	or	r15, r31
    235a:	0e c0       	rjmp	.+28     	; 0x2378 <vfprintf+0xe8>
    235c:	9e 32       	cpi	r25, 0x2E	; 46
    235e:	29 f4       	brne	.+10     	; 0x236a <vfprintf+0xda>
    2360:	f6 fc       	sbrc	r15, 6
    2362:	6b c1       	rjmp	.+726    	; 0x263a <vfprintf+0x3aa>
    2364:	40 e4       	ldi	r20, 0x40	; 64
    2366:	f4 2a       	or	r15, r20
    2368:	07 c0       	rjmp	.+14     	; 0x2378 <vfprintf+0xe8>
    236a:	9c 36       	cpi	r25, 0x6C	; 108
    236c:	19 f4       	brne	.+6      	; 0x2374 <vfprintf+0xe4>
    236e:	50 e8       	ldi	r21, 0x80	; 128
    2370:	f5 2a       	or	r15, r21
    2372:	02 c0       	rjmp	.+4      	; 0x2378 <vfprintf+0xe8>
    2374:	98 36       	cpi	r25, 0x68	; 104
    2376:	49 f4       	brne	.+18     	; 0x238a <vfprintf+0xfa>
    2378:	f2 01       	movw	r30, r4
    237a:	23 fd       	sbrc	r18, 3
    237c:	95 91       	lpm	r25, Z+
    237e:	23 ff       	sbrs	r18, 3
    2380:	91 91       	ld	r25, Z+
    2382:	2f 01       	movw	r4, r30
    2384:	99 23       	and	r25, r25
    2386:	09 f0       	breq	.+2      	; 0x238a <vfprintf+0xfa>
    2388:	b8 cf       	rjmp	.-144    	; 0x22fa <vfprintf+0x6a>
    238a:	89 2f       	mov	r24, r25
    238c:	85 54       	subi	r24, 0x45	; 69
    238e:	83 30       	cpi	r24, 0x03	; 3
    2390:	18 f0       	brcs	.+6      	; 0x2398 <vfprintf+0x108>
    2392:	80 52       	subi	r24, 0x20	; 32
    2394:	83 30       	cpi	r24, 0x03	; 3
    2396:	38 f4       	brcc	.+14     	; 0x23a6 <vfprintf+0x116>
    2398:	44 e0       	ldi	r20, 0x04	; 4
    239a:	50 e0       	ldi	r21, 0x00	; 0
    239c:	a4 0e       	add	r10, r20
    239e:	b5 1e       	adc	r11, r21
    23a0:	5f e3       	ldi	r21, 0x3F	; 63
    23a2:	59 83       	std	Y+1, r21	; 0x01
    23a4:	0f c0       	rjmp	.+30     	; 0x23c4 <vfprintf+0x134>
    23a6:	93 36       	cpi	r25, 0x63	; 99
    23a8:	31 f0       	breq	.+12     	; 0x23b6 <vfprintf+0x126>
    23aa:	93 37       	cpi	r25, 0x73	; 115
    23ac:	79 f0       	breq	.+30     	; 0x23cc <vfprintf+0x13c>
    23ae:	93 35       	cpi	r25, 0x53	; 83
    23b0:	09 f0       	breq	.+2      	; 0x23b4 <vfprintf+0x124>
    23b2:	56 c0       	rjmp	.+172    	; 0x2460 <vfprintf+0x1d0>
    23b4:	20 c0       	rjmp	.+64     	; 0x23f6 <vfprintf+0x166>
    23b6:	f5 01       	movw	r30, r10
    23b8:	80 81       	ld	r24, Z
    23ba:	89 83       	std	Y+1, r24	; 0x01
    23bc:	42 e0       	ldi	r20, 0x02	; 2
    23be:	50 e0       	ldi	r21, 0x00	; 0
    23c0:	a4 0e       	add	r10, r20
    23c2:	b5 1e       	adc	r11, r21
    23c4:	61 01       	movw	r12, r2
    23c6:	01 e0       	ldi	r16, 0x01	; 1
    23c8:	10 e0       	ldi	r17, 0x00	; 0
    23ca:	12 c0       	rjmp	.+36     	; 0x23f0 <vfprintf+0x160>
    23cc:	f5 01       	movw	r30, r10
    23ce:	c0 80       	ld	r12, Z
    23d0:	d1 80       	ldd	r13, Z+1	; 0x01
    23d2:	f6 fc       	sbrc	r15, 6
    23d4:	03 c0       	rjmp	.+6      	; 0x23dc <vfprintf+0x14c>
    23d6:	6f ef       	ldi	r22, 0xFF	; 255
    23d8:	7f ef       	ldi	r23, 0xFF	; 255
    23da:	02 c0       	rjmp	.+4      	; 0x23e0 <vfprintf+0x150>
    23dc:	69 2d       	mov	r22, r9
    23de:	70 e0       	ldi	r23, 0x00	; 0
    23e0:	42 e0       	ldi	r20, 0x02	; 2
    23e2:	50 e0       	ldi	r21, 0x00	; 0
    23e4:	a4 0e       	add	r10, r20
    23e6:	b5 1e       	adc	r11, r21
    23e8:	c6 01       	movw	r24, r12
    23ea:	0e 94 30 13 	call	0x2660	; 0x2660 <strnlen>
    23ee:	8c 01       	movw	r16, r24
    23f0:	5f e7       	ldi	r21, 0x7F	; 127
    23f2:	f5 22       	and	r15, r21
    23f4:	14 c0       	rjmp	.+40     	; 0x241e <vfprintf+0x18e>
    23f6:	f5 01       	movw	r30, r10
    23f8:	c0 80       	ld	r12, Z
    23fa:	d1 80       	ldd	r13, Z+1	; 0x01
    23fc:	f6 fc       	sbrc	r15, 6
    23fe:	03 c0       	rjmp	.+6      	; 0x2406 <vfprintf+0x176>
    2400:	6f ef       	ldi	r22, 0xFF	; 255
    2402:	7f ef       	ldi	r23, 0xFF	; 255
    2404:	02 c0       	rjmp	.+4      	; 0x240a <vfprintf+0x17a>
    2406:	69 2d       	mov	r22, r9
    2408:	70 e0       	ldi	r23, 0x00	; 0
    240a:	42 e0       	ldi	r20, 0x02	; 2
    240c:	50 e0       	ldi	r21, 0x00	; 0
    240e:	a4 0e       	add	r10, r20
    2410:	b5 1e       	adc	r11, r21
    2412:	c6 01       	movw	r24, r12
    2414:	0e 94 25 13 	call	0x264a	; 0x264a <strnlen_P>
    2418:	8c 01       	movw	r16, r24
    241a:	50 e8       	ldi	r21, 0x80	; 128
    241c:	f5 2a       	or	r15, r21
    241e:	f3 fe       	sbrs	r15, 3
    2420:	07 c0       	rjmp	.+14     	; 0x2430 <vfprintf+0x1a0>
    2422:	1a c0       	rjmp	.+52     	; 0x2458 <vfprintf+0x1c8>
    2424:	80 e2       	ldi	r24, 0x20	; 32
    2426:	90 e0       	ldi	r25, 0x00	; 0
    2428:	b3 01       	movw	r22, r6
    242a:	0e 94 e3 10 	call	0x21c6	; 0x21c6 <fputc>
    242e:	ea 94       	dec	r14
    2430:	8e 2d       	mov	r24, r14
    2432:	90 e0       	ldi	r25, 0x00	; 0
    2434:	08 17       	cp	r16, r24
    2436:	19 07       	cpc	r17, r25
    2438:	a8 f3       	brcs	.-22     	; 0x2424 <vfprintf+0x194>
    243a:	0e c0       	rjmp	.+28     	; 0x2458 <vfprintf+0x1c8>
    243c:	f6 01       	movw	r30, r12
    243e:	f7 fc       	sbrc	r15, 7
    2440:	85 91       	lpm	r24, Z+
    2442:	f7 fe       	sbrs	r15, 7
    2444:	81 91       	ld	r24, Z+
    2446:	6f 01       	movw	r12, r30
    2448:	90 e0       	ldi	r25, 0x00	; 0
    244a:	b3 01       	movw	r22, r6
    244c:	0e 94 e3 10 	call	0x21c6	; 0x21c6 <fputc>
    2450:	e1 10       	cpse	r14, r1
    2452:	ea 94       	dec	r14
    2454:	01 50       	subi	r16, 0x01	; 1
    2456:	10 40       	sbci	r17, 0x00	; 0
    2458:	01 15       	cp	r16, r1
    245a:	11 05       	cpc	r17, r1
    245c:	79 f7       	brne	.-34     	; 0x243c <vfprintf+0x1ac>
    245e:	ea c0       	rjmp	.+468    	; 0x2634 <vfprintf+0x3a4>
    2460:	94 36       	cpi	r25, 0x64	; 100
    2462:	11 f0       	breq	.+4      	; 0x2468 <vfprintf+0x1d8>
    2464:	99 36       	cpi	r25, 0x69	; 105
    2466:	69 f5       	brne	.+90     	; 0x24c2 <vfprintf+0x232>
    2468:	f7 fe       	sbrs	r15, 7
    246a:	08 c0       	rjmp	.+16     	; 0x247c <vfprintf+0x1ec>
    246c:	f5 01       	movw	r30, r10
    246e:	20 81       	ld	r18, Z
    2470:	31 81       	ldd	r19, Z+1	; 0x01
    2472:	42 81       	ldd	r20, Z+2	; 0x02
    2474:	53 81       	ldd	r21, Z+3	; 0x03
    2476:	84 e0       	ldi	r24, 0x04	; 4
    2478:	90 e0       	ldi	r25, 0x00	; 0
    247a:	0a c0       	rjmp	.+20     	; 0x2490 <vfprintf+0x200>
    247c:	f5 01       	movw	r30, r10
    247e:	80 81       	ld	r24, Z
    2480:	91 81       	ldd	r25, Z+1	; 0x01
    2482:	9c 01       	movw	r18, r24
    2484:	44 27       	eor	r20, r20
    2486:	37 fd       	sbrc	r19, 7
    2488:	40 95       	com	r20
    248a:	54 2f       	mov	r21, r20
    248c:	82 e0       	ldi	r24, 0x02	; 2
    248e:	90 e0       	ldi	r25, 0x00	; 0
    2490:	a8 0e       	add	r10, r24
    2492:	b9 1e       	adc	r11, r25
    2494:	9f e6       	ldi	r25, 0x6F	; 111
    2496:	f9 22       	and	r15, r25
    2498:	57 ff       	sbrs	r21, 7
    249a:	09 c0       	rjmp	.+18     	; 0x24ae <vfprintf+0x21e>
    249c:	50 95       	com	r21
    249e:	40 95       	com	r20
    24a0:	30 95       	com	r19
    24a2:	21 95       	neg	r18
    24a4:	3f 4f       	sbci	r19, 0xFF	; 255
    24a6:	4f 4f       	sbci	r20, 0xFF	; 255
    24a8:	5f 4f       	sbci	r21, 0xFF	; 255
    24aa:	e0 e8       	ldi	r30, 0x80	; 128
    24ac:	fe 2a       	or	r15, r30
    24ae:	ca 01       	movw	r24, r20
    24b0:	b9 01       	movw	r22, r18
    24b2:	a1 01       	movw	r20, r2
    24b4:	2a e0       	ldi	r18, 0x0A	; 10
    24b6:	30 e0       	ldi	r19, 0x00	; 0
    24b8:	0e 94 3b 13 	call	0x2676	; 0x2676 <__ultoa_invert>
    24bc:	d8 2e       	mov	r13, r24
    24be:	d2 18       	sub	r13, r2
    24c0:	40 c0       	rjmp	.+128    	; 0x2542 <vfprintf+0x2b2>
    24c2:	95 37       	cpi	r25, 0x75	; 117
    24c4:	29 f4       	brne	.+10     	; 0x24d0 <vfprintf+0x240>
    24c6:	1f 2d       	mov	r17, r15
    24c8:	1f 7e       	andi	r17, 0xEF	; 239
    24ca:	2a e0       	ldi	r18, 0x0A	; 10
    24cc:	30 e0       	ldi	r19, 0x00	; 0
    24ce:	1d c0       	rjmp	.+58     	; 0x250a <vfprintf+0x27a>
    24d0:	1f 2d       	mov	r17, r15
    24d2:	19 7f       	andi	r17, 0xF9	; 249
    24d4:	9f 36       	cpi	r25, 0x6F	; 111
    24d6:	61 f0       	breq	.+24     	; 0x24f0 <vfprintf+0x260>
    24d8:	90 37       	cpi	r25, 0x70	; 112
    24da:	20 f4       	brcc	.+8      	; 0x24e4 <vfprintf+0x254>
    24dc:	98 35       	cpi	r25, 0x58	; 88
    24de:	09 f0       	breq	.+2      	; 0x24e2 <vfprintf+0x252>
    24e0:	ac c0       	rjmp	.+344    	; 0x263a <vfprintf+0x3aa>
    24e2:	0f c0       	rjmp	.+30     	; 0x2502 <vfprintf+0x272>
    24e4:	90 37       	cpi	r25, 0x70	; 112
    24e6:	39 f0       	breq	.+14     	; 0x24f6 <vfprintf+0x266>
    24e8:	98 37       	cpi	r25, 0x78	; 120
    24ea:	09 f0       	breq	.+2      	; 0x24ee <vfprintf+0x25e>
    24ec:	a6 c0       	rjmp	.+332    	; 0x263a <vfprintf+0x3aa>
    24ee:	04 c0       	rjmp	.+8      	; 0x24f8 <vfprintf+0x268>
    24f0:	28 e0       	ldi	r18, 0x08	; 8
    24f2:	30 e0       	ldi	r19, 0x00	; 0
    24f4:	0a c0       	rjmp	.+20     	; 0x250a <vfprintf+0x27a>
    24f6:	10 61       	ori	r17, 0x10	; 16
    24f8:	14 fd       	sbrc	r17, 4
    24fa:	14 60       	ori	r17, 0x04	; 4
    24fc:	20 e1       	ldi	r18, 0x10	; 16
    24fe:	30 e0       	ldi	r19, 0x00	; 0
    2500:	04 c0       	rjmp	.+8      	; 0x250a <vfprintf+0x27a>
    2502:	14 fd       	sbrc	r17, 4
    2504:	16 60       	ori	r17, 0x06	; 6
    2506:	20 e1       	ldi	r18, 0x10	; 16
    2508:	32 e0       	ldi	r19, 0x02	; 2
    250a:	17 ff       	sbrs	r17, 7
    250c:	08 c0       	rjmp	.+16     	; 0x251e <vfprintf+0x28e>
    250e:	f5 01       	movw	r30, r10
    2510:	60 81       	ld	r22, Z
    2512:	71 81       	ldd	r23, Z+1	; 0x01
    2514:	82 81       	ldd	r24, Z+2	; 0x02
    2516:	93 81       	ldd	r25, Z+3	; 0x03
    2518:	44 e0       	ldi	r20, 0x04	; 4
    251a:	50 e0       	ldi	r21, 0x00	; 0
    251c:	08 c0       	rjmp	.+16     	; 0x252e <vfprintf+0x29e>
    251e:	f5 01       	movw	r30, r10
    2520:	80 81       	ld	r24, Z
    2522:	91 81       	ldd	r25, Z+1	; 0x01
    2524:	bc 01       	movw	r22, r24
    2526:	80 e0       	ldi	r24, 0x00	; 0
    2528:	90 e0       	ldi	r25, 0x00	; 0
    252a:	42 e0       	ldi	r20, 0x02	; 2
    252c:	50 e0       	ldi	r21, 0x00	; 0
    252e:	a4 0e       	add	r10, r20
    2530:	b5 1e       	adc	r11, r21
    2532:	a1 01       	movw	r20, r2
    2534:	0e 94 3b 13 	call	0x2676	; 0x2676 <__ultoa_invert>
    2538:	d8 2e       	mov	r13, r24
    253a:	d2 18       	sub	r13, r2
    253c:	8f e7       	ldi	r24, 0x7F	; 127
    253e:	f8 2e       	mov	r15, r24
    2540:	f1 22       	and	r15, r17
    2542:	f6 fe       	sbrs	r15, 6
    2544:	0b c0       	rjmp	.+22     	; 0x255c <vfprintf+0x2cc>
    2546:	5e ef       	ldi	r21, 0xFE	; 254
    2548:	f5 22       	and	r15, r21
    254a:	d9 14       	cp	r13, r9
    254c:	38 f4       	brcc	.+14     	; 0x255c <vfprintf+0x2cc>
    254e:	f4 fe       	sbrs	r15, 4
    2550:	07 c0       	rjmp	.+14     	; 0x2560 <vfprintf+0x2d0>
    2552:	f2 fc       	sbrc	r15, 2
    2554:	05 c0       	rjmp	.+10     	; 0x2560 <vfprintf+0x2d0>
    2556:	8f ee       	ldi	r24, 0xEF	; 239
    2558:	f8 22       	and	r15, r24
    255a:	02 c0       	rjmp	.+4      	; 0x2560 <vfprintf+0x2d0>
    255c:	1d 2d       	mov	r17, r13
    255e:	01 c0       	rjmp	.+2      	; 0x2562 <vfprintf+0x2d2>
    2560:	19 2d       	mov	r17, r9
    2562:	f4 fe       	sbrs	r15, 4
    2564:	0d c0       	rjmp	.+26     	; 0x2580 <vfprintf+0x2f0>
    2566:	fe 01       	movw	r30, r28
    2568:	ed 0d       	add	r30, r13
    256a:	f1 1d       	adc	r31, r1
    256c:	80 81       	ld	r24, Z
    256e:	80 33       	cpi	r24, 0x30	; 48
    2570:	19 f4       	brne	.+6      	; 0x2578 <vfprintf+0x2e8>
    2572:	99 ee       	ldi	r25, 0xE9	; 233
    2574:	f9 22       	and	r15, r25
    2576:	08 c0       	rjmp	.+16     	; 0x2588 <vfprintf+0x2f8>
    2578:	1f 5f       	subi	r17, 0xFF	; 255
    257a:	f2 fe       	sbrs	r15, 2
    257c:	05 c0       	rjmp	.+10     	; 0x2588 <vfprintf+0x2f8>
    257e:	03 c0       	rjmp	.+6      	; 0x2586 <vfprintf+0x2f6>
    2580:	8f 2d       	mov	r24, r15
    2582:	86 78       	andi	r24, 0x86	; 134
    2584:	09 f0       	breq	.+2      	; 0x2588 <vfprintf+0x2f8>
    2586:	1f 5f       	subi	r17, 0xFF	; 255
    2588:	0f 2d       	mov	r16, r15
    258a:	f3 fc       	sbrc	r15, 3
    258c:	14 c0       	rjmp	.+40     	; 0x25b6 <vfprintf+0x326>
    258e:	f0 fe       	sbrs	r15, 0
    2590:	0f c0       	rjmp	.+30     	; 0x25b0 <vfprintf+0x320>
    2592:	1e 15       	cp	r17, r14
    2594:	10 f0       	brcs	.+4      	; 0x259a <vfprintf+0x30a>
    2596:	9d 2c       	mov	r9, r13
    2598:	0b c0       	rjmp	.+22     	; 0x25b0 <vfprintf+0x320>
    259a:	9d 2c       	mov	r9, r13
    259c:	9e 0c       	add	r9, r14
    259e:	91 1a       	sub	r9, r17
    25a0:	1e 2d       	mov	r17, r14
    25a2:	06 c0       	rjmp	.+12     	; 0x25b0 <vfprintf+0x320>
    25a4:	80 e2       	ldi	r24, 0x20	; 32
    25a6:	90 e0       	ldi	r25, 0x00	; 0
    25a8:	b3 01       	movw	r22, r6
    25aa:	0e 94 e3 10 	call	0x21c6	; 0x21c6 <fputc>
    25ae:	1f 5f       	subi	r17, 0xFF	; 255
    25b0:	1e 15       	cp	r17, r14
    25b2:	c0 f3       	brcs	.-16     	; 0x25a4 <vfprintf+0x314>
    25b4:	04 c0       	rjmp	.+8      	; 0x25be <vfprintf+0x32e>
    25b6:	1e 15       	cp	r17, r14
    25b8:	10 f4       	brcc	.+4      	; 0x25be <vfprintf+0x32e>
    25ba:	e1 1a       	sub	r14, r17
    25bc:	01 c0       	rjmp	.+2      	; 0x25c0 <vfprintf+0x330>
    25be:	ee 24       	eor	r14, r14
    25c0:	04 ff       	sbrs	r16, 4
    25c2:	0f c0       	rjmp	.+30     	; 0x25e2 <vfprintf+0x352>
    25c4:	80 e3       	ldi	r24, 0x30	; 48
    25c6:	90 e0       	ldi	r25, 0x00	; 0
    25c8:	b3 01       	movw	r22, r6
    25ca:	0e 94 e3 10 	call	0x21c6	; 0x21c6 <fputc>
    25ce:	02 ff       	sbrs	r16, 2
    25d0:	1d c0       	rjmp	.+58     	; 0x260c <vfprintf+0x37c>
    25d2:	01 fd       	sbrc	r16, 1
    25d4:	03 c0       	rjmp	.+6      	; 0x25dc <vfprintf+0x34c>
    25d6:	88 e7       	ldi	r24, 0x78	; 120
    25d8:	90 e0       	ldi	r25, 0x00	; 0
    25da:	0e c0       	rjmp	.+28     	; 0x25f8 <vfprintf+0x368>
    25dc:	88 e5       	ldi	r24, 0x58	; 88
    25de:	90 e0       	ldi	r25, 0x00	; 0
    25e0:	0b c0       	rjmp	.+22     	; 0x25f8 <vfprintf+0x368>
    25e2:	80 2f       	mov	r24, r16
    25e4:	86 78       	andi	r24, 0x86	; 134
    25e6:	91 f0       	breq	.+36     	; 0x260c <vfprintf+0x37c>
    25e8:	01 ff       	sbrs	r16, 1
    25ea:	02 c0       	rjmp	.+4      	; 0x25f0 <vfprintf+0x360>
    25ec:	8b e2       	ldi	r24, 0x2B	; 43
    25ee:	01 c0       	rjmp	.+2      	; 0x25f2 <vfprintf+0x362>
    25f0:	80 e2       	ldi	r24, 0x20	; 32
    25f2:	f7 fc       	sbrc	r15, 7
    25f4:	8d e2       	ldi	r24, 0x2D	; 45
    25f6:	90 e0       	ldi	r25, 0x00	; 0
    25f8:	b3 01       	movw	r22, r6
    25fa:	0e 94 e3 10 	call	0x21c6	; 0x21c6 <fputc>
    25fe:	06 c0       	rjmp	.+12     	; 0x260c <vfprintf+0x37c>
    2600:	80 e3       	ldi	r24, 0x30	; 48
    2602:	90 e0       	ldi	r25, 0x00	; 0
    2604:	b3 01       	movw	r22, r6
    2606:	0e 94 e3 10 	call	0x21c6	; 0x21c6 <fputc>
    260a:	9a 94       	dec	r9
    260c:	d9 14       	cp	r13, r9
    260e:	c0 f3       	brcs	.-16     	; 0x2600 <vfprintf+0x370>
    2610:	da 94       	dec	r13
    2612:	f1 01       	movw	r30, r2
    2614:	ed 0d       	add	r30, r13
    2616:	f1 1d       	adc	r31, r1
    2618:	80 81       	ld	r24, Z
    261a:	90 e0       	ldi	r25, 0x00	; 0
    261c:	b3 01       	movw	r22, r6
    261e:	0e 94 e3 10 	call	0x21c6	; 0x21c6 <fputc>
    2622:	dd 20       	and	r13, r13
    2624:	a9 f7       	brne	.-22     	; 0x2610 <vfprintf+0x380>
    2626:	06 c0       	rjmp	.+12     	; 0x2634 <vfprintf+0x3a4>
    2628:	80 e2       	ldi	r24, 0x20	; 32
    262a:	90 e0       	ldi	r25, 0x00	; 0
    262c:	b3 01       	movw	r22, r6
    262e:	0e 94 e3 10 	call	0x21c6	; 0x21c6 <fputc>
    2632:	ea 94       	dec	r14
    2634:	ee 20       	and	r14, r14
    2636:	c1 f7       	brne	.-16     	; 0x2628 <vfprintf+0x398>
    2638:	43 ce       	rjmp	.-890    	; 0x22c0 <vfprintf+0x30>
    263a:	f3 01       	movw	r30, r6
    263c:	66 81       	ldd	r22, Z+6	; 0x06
    263e:	77 81       	ldd	r23, Z+7	; 0x07
    2640:	cb 01       	movw	r24, r22
    2642:	2b 96       	adiw	r28, 0x0b	; 11
    2644:	e2 e1       	ldi	r30, 0x12	; 18
    2646:	0c 94 e8 13 	jmp	0x27d0	; 0x27d0 <__epilogue_restores__>

0000264a <strnlen_P>:
    264a:	fc 01       	movw	r30, r24
    264c:	05 90       	lpm	r0, Z+
    264e:	61 50       	subi	r22, 0x01	; 1
    2650:	70 40       	sbci	r23, 0x00	; 0
    2652:	01 10       	cpse	r0, r1
    2654:	d8 f7       	brcc	.-10     	; 0x264c <strnlen_P+0x2>
    2656:	80 95       	com	r24
    2658:	90 95       	com	r25
    265a:	8e 0f       	add	r24, r30
    265c:	9f 1f       	adc	r25, r31
    265e:	08 95       	ret

00002660 <strnlen>:
    2660:	fc 01       	movw	r30, r24
    2662:	61 50       	subi	r22, 0x01	; 1
    2664:	70 40       	sbci	r23, 0x00	; 0
    2666:	01 90       	ld	r0, Z+
    2668:	01 10       	cpse	r0, r1
    266a:	d8 f7       	brcc	.-10     	; 0x2662 <strnlen+0x2>
    266c:	80 95       	com	r24
    266e:	90 95       	com	r25
    2670:	8e 0f       	add	r24, r30
    2672:	9f 1f       	adc	r25, r31
    2674:	08 95       	ret

00002676 <__ultoa_invert>:
    2676:	fa 01       	movw	r30, r20
    2678:	aa 27       	eor	r26, r26
    267a:	28 30       	cpi	r18, 0x08	; 8
    267c:	51 f1       	breq	.+84     	; 0x26d2 <__ultoa_invert+0x5c>
    267e:	20 31       	cpi	r18, 0x10	; 16
    2680:	81 f1       	breq	.+96     	; 0x26e2 <__ultoa_invert+0x6c>
    2682:	e8 94       	clt
    2684:	6f 93       	push	r22
    2686:	6e 7f       	andi	r22, 0xFE	; 254
    2688:	6e 5f       	subi	r22, 0xFE	; 254
    268a:	7f 4f       	sbci	r23, 0xFF	; 255
    268c:	8f 4f       	sbci	r24, 0xFF	; 255
    268e:	9f 4f       	sbci	r25, 0xFF	; 255
    2690:	af 4f       	sbci	r26, 0xFF	; 255
    2692:	b1 e0       	ldi	r27, 0x01	; 1
    2694:	3e d0       	rcall	.+124    	; 0x2712 <__ultoa_invert+0x9c>
    2696:	b4 e0       	ldi	r27, 0x04	; 4
    2698:	3c d0       	rcall	.+120    	; 0x2712 <__ultoa_invert+0x9c>
    269a:	67 0f       	add	r22, r23
    269c:	78 1f       	adc	r23, r24
    269e:	89 1f       	adc	r24, r25
    26a0:	9a 1f       	adc	r25, r26
    26a2:	a1 1d       	adc	r26, r1
    26a4:	68 0f       	add	r22, r24
    26a6:	79 1f       	adc	r23, r25
    26a8:	8a 1f       	adc	r24, r26
    26aa:	91 1d       	adc	r25, r1
    26ac:	a1 1d       	adc	r26, r1
    26ae:	6a 0f       	add	r22, r26
    26b0:	71 1d       	adc	r23, r1
    26b2:	81 1d       	adc	r24, r1
    26b4:	91 1d       	adc	r25, r1
    26b6:	a1 1d       	adc	r26, r1
    26b8:	20 d0       	rcall	.+64     	; 0x26fa <__ultoa_invert+0x84>
    26ba:	09 f4       	brne	.+2      	; 0x26be <__ultoa_invert+0x48>
    26bc:	68 94       	set
    26be:	3f 91       	pop	r19
    26c0:	2a e0       	ldi	r18, 0x0A	; 10
    26c2:	26 9f       	mul	r18, r22
    26c4:	11 24       	eor	r1, r1
    26c6:	30 19       	sub	r19, r0
    26c8:	30 5d       	subi	r19, 0xD0	; 208
    26ca:	31 93       	st	Z+, r19
    26cc:	de f6       	brtc	.-74     	; 0x2684 <__ultoa_invert+0xe>
    26ce:	cf 01       	movw	r24, r30
    26d0:	08 95       	ret
    26d2:	46 2f       	mov	r20, r22
    26d4:	47 70       	andi	r20, 0x07	; 7
    26d6:	40 5d       	subi	r20, 0xD0	; 208
    26d8:	41 93       	st	Z+, r20
    26da:	b3 e0       	ldi	r27, 0x03	; 3
    26dc:	0f d0       	rcall	.+30     	; 0x26fc <__ultoa_invert+0x86>
    26de:	c9 f7       	brne	.-14     	; 0x26d2 <__ultoa_invert+0x5c>
    26e0:	f6 cf       	rjmp	.-20     	; 0x26ce <__ultoa_invert+0x58>
    26e2:	46 2f       	mov	r20, r22
    26e4:	4f 70       	andi	r20, 0x0F	; 15
    26e6:	40 5d       	subi	r20, 0xD0	; 208
    26e8:	4a 33       	cpi	r20, 0x3A	; 58
    26ea:	18 f0       	brcs	.+6      	; 0x26f2 <__ultoa_invert+0x7c>
    26ec:	49 5d       	subi	r20, 0xD9	; 217
    26ee:	31 fd       	sbrc	r19, 1
    26f0:	40 52       	subi	r20, 0x20	; 32
    26f2:	41 93       	st	Z+, r20
    26f4:	02 d0       	rcall	.+4      	; 0x26fa <__ultoa_invert+0x84>
    26f6:	a9 f7       	brne	.-22     	; 0x26e2 <__ultoa_invert+0x6c>
    26f8:	ea cf       	rjmp	.-44     	; 0x26ce <__ultoa_invert+0x58>
    26fa:	b4 e0       	ldi	r27, 0x04	; 4
    26fc:	a6 95       	lsr	r26
    26fe:	97 95       	ror	r25
    2700:	87 95       	ror	r24
    2702:	77 95       	ror	r23
    2704:	67 95       	ror	r22
    2706:	ba 95       	dec	r27
    2708:	c9 f7       	brne	.-14     	; 0x26fc <__ultoa_invert+0x86>
    270a:	00 97       	sbiw	r24, 0x00	; 0
    270c:	61 05       	cpc	r22, r1
    270e:	71 05       	cpc	r23, r1
    2710:	08 95       	ret
    2712:	9b 01       	movw	r18, r22
    2714:	ac 01       	movw	r20, r24
    2716:	0a 2e       	mov	r0, r26
    2718:	06 94       	lsr	r0
    271a:	57 95       	ror	r21
    271c:	47 95       	ror	r20
    271e:	37 95       	ror	r19
    2720:	27 95       	ror	r18
    2722:	ba 95       	dec	r27
    2724:	c9 f7       	brne	.-14     	; 0x2718 <__ultoa_invert+0xa2>
    2726:	62 0f       	add	r22, r18
    2728:	73 1f       	adc	r23, r19
    272a:	84 1f       	adc	r24, r20
    272c:	95 1f       	adc	r25, r21
    272e:	a0 1d       	adc	r26, r0
    2730:	08 95       	ret

00002732 <__udivmodqi4>:
    2732:	99 1b       	sub	r25, r25
    2734:	79 e0       	ldi	r23, 0x09	; 9
    2736:	04 c0       	rjmp	.+8      	; 0x2740 <__udivmodqi4_ep>

00002738 <__udivmodqi4_loop>:
    2738:	99 1f       	adc	r25, r25
    273a:	96 17       	cp	r25, r22
    273c:	08 f0       	brcs	.+2      	; 0x2740 <__udivmodqi4_ep>
    273e:	96 1b       	sub	r25, r22

00002740 <__udivmodqi4_ep>:
    2740:	88 1f       	adc	r24, r24
    2742:	7a 95       	dec	r23
    2744:	c9 f7       	brne	.-14     	; 0x2738 <__udivmodqi4_loop>
    2746:	80 95       	com	r24
    2748:	08 95       	ret

0000274a <__divmodhi4>:
    274a:	97 fb       	bst	r25, 7
    274c:	09 2e       	mov	r0, r25
    274e:	07 26       	eor	r0, r23
    2750:	0a d0       	rcall	.+20     	; 0x2766 <__divmodhi4_neg1>
    2752:	77 fd       	sbrc	r23, 7
    2754:	04 d0       	rcall	.+8      	; 0x275e <__divmodhi4_neg2>
    2756:	0c d0       	rcall	.+24     	; 0x2770 <__udivmodhi4>
    2758:	06 d0       	rcall	.+12     	; 0x2766 <__divmodhi4_neg1>
    275a:	00 20       	and	r0, r0
    275c:	1a f4       	brpl	.+6      	; 0x2764 <__divmodhi4_exit>

0000275e <__divmodhi4_neg2>:
    275e:	70 95       	com	r23
    2760:	61 95       	neg	r22
    2762:	7f 4f       	sbci	r23, 0xFF	; 255

00002764 <__divmodhi4_exit>:
    2764:	08 95       	ret

00002766 <__divmodhi4_neg1>:
    2766:	f6 f7       	brtc	.-4      	; 0x2764 <__divmodhi4_exit>
    2768:	90 95       	com	r25
    276a:	81 95       	neg	r24
    276c:	9f 4f       	sbci	r25, 0xFF	; 255
    276e:	08 95       	ret

00002770 <__udivmodhi4>:
    2770:	aa 1b       	sub	r26, r26
    2772:	bb 1b       	sub	r27, r27
    2774:	51 e1       	ldi	r21, 0x11	; 17
    2776:	07 c0       	rjmp	.+14     	; 0x2786 <__udivmodhi4_ep>

00002778 <__udivmodhi4_loop>:
    2778:	aa 1f       	adc	r26, r26
    277a:	bb 1f       	adc	r27, r27
    277c:	a6 17       	cp	r26, r22
    277e:	b7 07       	cpc	r27, r23
    2780:	10 f0       	brcs	.+4      	; 0x2786 <__udivmodhi4_ep>
    2782:	a6 1b       	sub	r26, r22
    2784:	b7 0b       	sbc	r27, r23

00002786 <__udivmodhi4_ep>:
    2786:	88 1f       	adc	r24, r24
    2788:	99 1f       	adc	r25, r25
    278a:	5a 95       	dec	r21
    278c:	a9 f7       	brne	.-22     	; 0x2778 <__udivmodhi4_loop>
    278e:	80 95       	com	r24
    2790:	90 95       	com	r25
    2792:	bc 01       	movw	r22, r24
    2794:	cd 01       	movw	r24, r26
    2796:	08 95       	ret

00002798 <__prologue_saves__>:
    2798:	2f 92       	push	r2
    279a:	3f 92       	push	r3
    279c:	4f 92       	push	r4
    279e:	5f 92       	push	r5
    27a0:	6f 92       	push	r6
    27a2:	7f 92       	push	r7
    27a4:	8f 92       	push	r8
    27a6:	9f 92       	push	r9
    27a8:	af 92       	push	r10
    27aa:	bf 92       	push	r11
    27ac:	cf 92       	push	r12
    27ae:	df 92       	push	r13
    27b0:	ef 92       	push	r14
    27b2:	ff 92       	push	r15
    27b4:	0f 93       	push	r16
    27b6:	1f 93       	push	r17
    27b8:	cf 93       	push	r28
    27ba:	df 93       	push	r29
    27bc:	cd b7       	in	r28, 0x3d	; 61
    27be:	de b7       	in	r29, 0x3e	; 62
    27c0:	ca 1b       	sub	r28, r26
    27c2:	db 0b       	sbc	r29, r27
    27c4:	0f b6       	in	r0, 0x3f	; 63
    27c6:	f8 94       	cli
    27c8:	de bf       	out	0x3e, r29	; 62
    27ca:	0f be       	out	0x3f, r0	; 63
    27cc:	cd bf       	out	0x3d, r28	; 61
    27ce:	09 94       	ijmp

000027d0 <__epilogue_restores__>:
    27d0:	2a 88       	ldd	r2, Y+18	; 0x12
    27d2:	39 88       	ldd	r3, Y+17	; 0x11
    27d4:	48 88       	ldd	r4, Y+16	; 0x10
    27d6:	5f 84       	ldd	r5, Y+15	; 0x0f
    27d8:	6e 84       	ldd	r6, Y+14	; 0x0e
    27da:	7d 84       	ldd	r7, Y+13	; 0x0d
    27dc:	8c 84       	ldd	r8, Y+12	; 0x0c
    27de:	9b 84       	ldd	r9, Y+11	; 0x0b
    27e0:	aa 84       	ldd	r10, Y+10	; 0x0a
    27e2:	b9 84       	ldd	r11, Y+9	; 0x09
    27e4:	c8 84       	ldd	r12, Y+8	; 0x08
    27e6:	df 80       	ldd	r13, Y+7	; 0x07
    27e8:	ee 80       	ldd	r14, Y+6	; 0x06
    27ea:	fd 80       	ldd	r15, Y+5	; 0x05
    27ec:	0c 81       	ldd	r16, Y+4	; 0x04
    27ee:	1b 81       	ldd	r17, Y+3	; 0x03
    27f0:	aa 81       	ldd	r26, Y+2	; 0x02
    27f2:	b9 81       	ldd	r27, Y+1	; 0x01
    27f4:	ce 0f       	add	r28, r30
    27f6:	d1 1d       	adc	r29, r1
    27f8:	0f b6       	in	r0, 0x3f	; 63
    27fa:	f8 94       	cli
    27fc:	de bf       	out	0x3e, r29	; 62
    27fe:	0f be       	out	0x3f, r0	; 63
    2800:	cd bf       	out	0x3d, r28	; 61
    2802:	ed 01       	movw	r28, r26
    2804:	08 95       	ret

00002806 <_exit>:
    2806:	f8 94       	cli

00002808 <__stop_program>:
    2808:	ff cf       	rjmp	.-2      	; 0x2808 <__stop_program>
