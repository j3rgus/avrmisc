
zamok_displej.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000004f0  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000028  00800060  000004f0  00000564  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .debug_aranges 00000020  00000000  00000000  0000058c  2**0
                  CONTENTS, READONLY, DEBUGGING
  3 .debug_pubnames 0000019f  00000000  00000000  000005ac  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   00000be8  00000000  00000000  0000074b  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_abbrev 00000245  00000000  00000000  00001333  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_line   00000939  00000000  00000000  00001578  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_frame  000001b0  00000000  00000000  00001eb4  2**2
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_str    00000292  00000000  00000000  00002064  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    00000666  00000000  00000000  000022f6  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00000030  00000000  00000000  0000295c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	12 c0       	rjmp	.+36     	; 0x26 <__ctors_end>
   2:	24 c0       	rjmp	.+72     	; 0x4c <__bad_interrupt>
   4:	23 c0       	rjmp	.+70     	; 0x4c <__bad_interrupt>
   6:	22 c0       	rjmp	.+68     	; 0x4c <__bad_interrupt>
   8:	21 c0       	rjmp	.+66     	; 0x4c <__bad_interrupt>
   a:	20 c0       	rjmp	.+64     	; 0x4c <__bad_interrupt>
   c:	1f c0       	rjmp	.+62     	; 0x4c <__bad_interrupt>
   e:	1e c0       	rjmp	.+60     	; 0x4c <__bad_interrupt>
  10:	1d c0       	rjmp	.+58     	; 0x4c <__bad_interrupt>
  12:	1c c0       	rjmp	.+56     	; 0x4c <__bad_interrupt>
  14:	1b c0       	rjmp	.+54     	; 0x4c <__bad_interrupt>
  16:	1a c0       	rjmp	.+52     	; 0x4c <__bad_interrupt>
  18:	19 c0       	rjmp	.+50     	; 0x4c <__bad_interrupt>
  1a:	18 c0       	rjmp	.+48     	; 0x4c <__bad_interrupt>
  1c:	17 c0       	rjmp	.+46     	; 0x4c <__bad_interrupt>
  1e:	16 c0       	rjmp	.+44     	; 0x4c <__bad_interrupt>
  20:	15 c0       	rjmp	.+42     	; 0x4c <__bad_interrupt>
  22:	14 c0       	rjmp	.+40     	; 0x4c <__bad_interrupt>
  24:	13 c0       	rjmp	.+38     	; 0x4c <__bad_interrupt>

00000026 <__ctors_end>:
  26:	11 24       	eor	r1, r1
  28:	1f be       	out	0x3f, r1	; 63
  2a:	cf e5       	ldi	r28, 0x5F	; 95
  2c:	d4 e0       	ldi	r29, 0x04	; 4
  2e:	de bf       	out	0x3e, r29	; 62
  30:	cd bf       	out	0x3d, r28	; 61

00000032 <__do_copy_data>:
  32:	10 e0       	ldi	r17, 0x00	; 0
  34:	a0 e6       	ldi	r26, 0x60	; 96
  36:	b0 e0       	ldi	r27, 0x00	; 0
  38:	e0 ef       	ldi	r30, 0xF0	; 240
  3a:	f4 e0       	ldi	r31, 0x04	; 4
  3c:	02 c0       	rjmp	.+4      	; 0x42 <.do_copy_data_start>

0000003e <.do_copy_data_loop>:
  3e:	05 90       	lpm	r0, Z+
  40:	0d 92       	st	X+, r0

00000042 <.do_copy_data_start>:
  42:	a8 38       	cpi	r26, 0x88	; 136
  44:	b1 07       	cpc	r27, r17
  46:	d9 f7       	brne	.-10     	; 0x3e <.do_copy_data_loop>
  48:	c4 d1       	rcall	.+904    	; 0x3d2 <main>
  4a:	50 c2       	rjmp	.+1184   	; 0x4ec <_exit>

0000004c <__bad_interrupt>:
  4c:	d9 cf       	rjmp	.-78     	; 0x0 <__vectors>

0000004e <LCDsendChar>:
#include <avr/pgmspace.h>
#include <util/delay.h>

void LCDsendChar(uint8_t ch)		//Sends Char to LCD
{
	LDP=(ch&0b11110000);
  4e:	28 2f       	mov	r18, r24
  50:	20 7f       	andi	r18, 0xF0	; 240
  52:	28 bb       	out	0x18, r18	; 24
	LCP|=1<<LCD_RS;
  54:	c0 9a       	sbi	0x18, 0	; 24
	LCP|=1<<LCD_E;		
  56:	c2 9a       	sbi	0x18, 2	; 24
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
  58:	20 ea       	ldi	r18, 0xA0	; 160
  5a:	3f e0       	ldi	r19, 0x0F	; 15
  5c:	f9 01       	movw	r30, r18
  5e:	31 97       	sbiw	r30, 0x01	; 1
  60:	f1 f7       	brne	.-4      	; 0x5e <LCDsendChar+0x10>
	_delay_ms(1);
	LCP&=~(1<<LCD_E);	
  62:	c2 98       	cbi	0x18, 2	; 24
	LCP&=~(1<<LCD_RS);
  64:	c0 98       	cbi	0x18, 0	; 24
  66:	f9 01       	movw	r30, r18
  68:	31 97       	sbiw	r30, 0x01	; 1
  6a:	f1 f7       	brne	.-4      	; 0x68 <LCDsendChar+0x1a>
	_delay_ms(1);
	LDP=((ch&0b00001111)<<4);
  6c:	90 e0       	ldi	r25, 0x00	; 0
  6e:	44 e0       	ldi	r20, 0x04	; 4
  70:	88 0f       	add	r24, r24
  72:	99 1f       	adc	r25, r25
  74:	4a 95       	dec	r20
  76:	e1 f7       	brne	.-8      	; 0x70 <LCDsendChar+0x22>
  78:	88 bb       	out	0x18, r24	; 24
	LCP|=1<<LCD_RS;
  7a:	c0 9a       	sbi	0x18, 0	; 24
	LCP|=1<<LCD_E;		
  7c:	c2 9a       	sbi	0x18, 2	; 24
  7e:	c9 01       	movw	r24, r18
  80:	01 97       	sbiw	r24, 0x01	; 1
  82:	f1 f7       	brne	.-4      	; 0x80 <LCDsendChar+0x32>
	_delay_ms(1);
	LCP&=~(1<<LCD_E);	
  84:	c2 98       	cbi	0x18, 2	; 24
	LCP&=~(1<<LCD_RS);
  86:	c0 98       	cbi	0x18, 0	; 24
  88:	c9 01       	movw	r24, r18
  8a:	01 97       	sbiw	r24, 0x01	; 1
  8c:	f1 f7       	brne	.-4      	; 0x8a <LCDsendChar+0x3c>
	_delay_ms(1);
}
  8e:	08 95       	ret

00000090 <LCDsendCommand>:
void LCDsendCommand(uint8_t cmd)	//Sends Command to LCD
{
	LDP=(cmd&0b11110000);
  90:	28 2f       	mov	r18, r24
  92:	20 7f       	andi	r18, 0xF0	; 240
  94:	28 bb       	out	0x18, r18	; 24
	LCP|=1<<LCD_E;		
  96:	c2 9a       	sbi	0x18, 2	; 24
  98:	20 ea       	ldi	r18, 0xA0	; 160
  9a:	3f e0       	ldi	r19, 0x0F	; 15
  9c:	f9 01       	movw	r30, r18
  9e:	31 97       	sbiw	r30, 0x01	; 1
  a0:	f1 f7       	brne	.-4      	; 0x9e <LCDsendCommand+0xe>
	_delay_ms(1);
	LCP&=~(1<<LCD_E);
  a2:	c2 98       	cbi	0x18, 2	; 24
  a4:	f9 01       	movw	r30, r18
  a6:	31 97       	sbiw	r30, 0x01	; 1
  a8:	f1 f7       	brne	.-4      	; 0xa6 <LCDsendCommand+0x16>
	_delay_ms(1);
	LDP=((cmd&0b00001111)<<4);	
  aa:	90 e0       	ldi	r25, 0x00	; 0
  ac:	54 e0       	ldi	r21, 0x04	; 4
  ae:	88 0f       	add	r24, r24
  b0:	99 1f       	adc	r25, r25
  b2:	5a 95       	dec	r21
  b4:	e1 f7       	brne	.-8      	; 0xae <LCDsendCommand+0x1e>
  b6:	88 bb       	out	0x18, r24	; 24
	LCP|=1<<LCD_E;		
  b8:	c2 9a       	sbi	0x18, 2	; 24
  ba:	c9 01       	movw	r24, r18
  bc:	01 97       	sbiw	r24, 0x01	; 1
  be:	f1 f7       	brne	.-4      	; 0xbc <LCDsendCommand+0x2c>
	_delay_ms(1);
	LCP&=~(1<<LCD_E);
  c0:	c2 98       	cbi	0x18, 2	; 24
  c2:	c9 01       	movw	r24, r18
  c4:	01 97       	sbiw	r24, 0x01	; 1
  c6:	f1 f7       	brne	.-4      	; 0xc4 <LCDsendCommand+0x34>
	_delay_ms(1);
}
  c8:	08 95       	ret

000000ca <LCDinit>:
  ca:	80 e6       	ldi	r24, 0x60	; 96
  cc:	9a ee       	ldi	r25, 0xEA	; 234
  ce:	01 97       	sbiw	r24, 0x01	; 1
  d0:	f1 f7       	brne	.-4      	; 0xce <LCDinit+0x4>
void LCDinit(void)//Initializes LCD
{
	_delay_ms(15);
	LDP=0x00;
  d2:	18 ba       	out	0x18, r1	; 24
	LCP=0x00;
  d4:	18 ba       	out	0x18, r1	; 24
	LDDR|=1<<LCD_D7|1<<LCD_D6|1<<LCD_D5|1<<LCD_D4;
  d6:	87 b3       	in	r24, 0x17	; 23
  d8:	80 6f       	ori	r24, 0xF0	; 240
  da:	87 bb       	out	0x17, r24	; 23
	LCDR|=1<<LCD_E|1<<LCD_RW|1<<LCD_RS;
  dc:	87 b3       	in	r24, 0x17	; 23
  de:	87 60       	ori	r24, 0x07	; 7
  e0:	87 bb       	out	0x17, r24	; 23
   //---------one------
	LDP=0<<LCD_D7|0<<LCD_D6|1<<LCD_D5|1<<LCD_D4; //4 bit mode
  e2:	80 e3       	ldi	r24, 0x30	; 48
  e4:	88 bb       	out	0x18, r24	; 24
	LCP|=1<<LCD_E|0<<LCD_RW|0<<LCD_RS;		
  e6:	c2 9a       	sbi	0x18, 2	; 24
  e8:	20 ea       	ldi	r18, 0xA0	; 160
  ea:	3f e0       	ldi	r19, 0x0F	; 15
  ec:	f9 01       	movw	r30, r18
  ee:	31 97       	sbiw	r30, 0x01	; 1
  f0:	f1 f7       	brne	.-4      	; 0xee <LCDinit+0x24>
	_delay_ms(1);
	LCP&=~(1<<LCD_E);
  f2:	c2 98       	cbi	0x18, 2	; 24
  f4:	f9 01       	movw	r30, r18
  f6:	31 97       	sbiw	r30, 0x01	; 1
  f8:	f1 f7       	brne	.-4      	; 0xf6 <LCDinit+0x2c>
	_delay_ms(1);
	//-----------two-----------
	LDP=0<<LCD_D7|0<<LCD_D6|1<<LCD_D5|1<<LCD_D4; //4 bit mode
  fa:	88 bb       	out	0x18, r24	; 24
	LCP|=1<<LCD_E|0<<LCD_RW|0<<LCD_RS;		
  fc:	c2 9a       	sbi	0x18, 2	; 24
  fe:	c9 01       	movw	r24, r18
 100:	01 97       	sbiw	r24, 0x01	; 1
 102:	f1 f7       	brne	.-4      	; 0x100 <LCDinit+0x36>
	_delay_ms(1);
	LCP&=~(1<<LCD_E);
 104:	c2 98       	cbi	0x18, 2	; 24
 106:	c9 01       	movw	r24, r18
 108:	01 97       	sbiw	r24, 0x01	; 1
 10a:	f1 f7       	brne	.-4      	; 0x108 <LCDinit+0x3e>
	_delay_ms(1);
	//-------three-------------
	LDP=0<<LCD_D7|0<<LCD_D6|1<<LCD_D5|0<<LCD_D4; //4 bit mode
 10c:	80 e2       	ldi	r24, 0x20	; 32
 10e:	88 bb       	out	0x18, r24	; 24
	LCP|=1<<LCD_E|0<<LCD_RW|0<<LCD_RS;		
 110:	c2 9a       	sbi	0x18, 2	; 24
 112:	c9 01       	movw	r24, r18
 114:	01 97       	sbiw	r24, 0x01	; 1
 116:	f1 f7       	brne	.-4      	; 0x114 <LCDinit+0x4a>
	_delay_ms(1);
	LCP&=~(1<<LCD_E);
 118:	c2 98       	cbi	0x18, 2	; 24
 11a:	c9 01       	movw	r24, r18
 11c:	01 97       	sbiw	r24, 0x01	; 1
 11e:	f1 f7       	brne	.-4      	; 0x11c <LCDinit+0x52>
	_delay_ms(1);
	//--------4 bit--dual line---------------
	LCDsendCommand(0b00101000);
 120:	88 e2       	ldi	r24, 0x28	; 40
 122:	b6 df       	rcall	.-148    	; 0x90 <LCDsendCommand>
   //-----increment address, cursor shift------
	LCDsendCommand(0b00001110);
 124:	8e e0       	ldi	r24, 0x0E	; 14
 126:	b4 df       	rcall	.-152    	; 0x90 <LCDsendCommand>


}			
 128:	08 95       	ret

0000012a <LCDclr>:
void LCDclr(void)				//Clears LCD
{
	LCDsendCommand(1<<LCD_CLR);
 12a:	81 e0       	ldi	r24, 0x01	; 1
 12c:	b1 df       	rcall	.-158    	; 0x90 <LCDsendCommand>
}
 12e:	08 95       	ret

00000130 <LCDhome>:
void LCDhome(void)			//LCD cursor home
{
	LCDsendCommand(1<<LCD_HOME);
 130:	82 e0       	ldi	r24, 0x02	; 2
 132:	ae df       	rcall	.-164    	; 0x90 <LCDsendCommand>
}
 134:	08 95       	ret

00000136 <LCDstring>:
void LCDstring(uint8_t* data, uint8_t nBytes)	//Outputs string to LCD
{
 136:	0f 93       	push	r16
 138:	1f 93       	push	r17
 13a:	cf 93       	push	r28
 13c:	df 93       	push	r29
 13e:	06 2f       	mov	r16, r22
register uint8_t i;

	// check to make sure we have a good pointer
	if (!data) return;
 140:	00 97       	sbiw	r24, 0x00	; 0
 142:	41 f0       	breq	.+16     	; 0x154 <LCDstring+0x1e>
 144:	ec 01       	movw	r28, r24
 146:	10 e0       	ldi	r17, 0x00	; 0
 148:	03 c0       	rjmp	.+6      	; 0x150 <LCDstring+0x1a>

	// print data
	for(i=0; i<nBytes; i++)
	{
		LCDsendChar(data[i]);
 14a:	89 91       	ld	r24, Y+
 14c:	80 df       	rcall	.-256    	; 0x4e <LCDsendChar>

	// check to make sure we have a good pointer
	if (!data) return;

	// print data
	for(i=0; i<nBytes; i++)
 14e:	1f 5f       	subi	r17, 0xFF	; 255
 150:	10 17       	cp	r17, r16
 152:	d8 f3       	brcs	.-10     	; 0x14a <LCDstring+0x14>
	{
		LCDsendChar(data[i]);
	}
}
 154:	df 91       	pop	r29
 156:	cf 91       	pop	r28
 158:	1f 91       	pop	r17
 15a:	0f 91       	pop	r16
 15c:	08 95       	ret

0000015e <LCDGotoXY>:
void LCDGotoXY(uint8_t x, uint8_t y)	//Cursor to X Y position
{
	register uint8_t DDRAMAddr;
	// remap lines into proper order
	switch(y)
 15e:	62 30       	cpi	r22, 0x02	; 2
 160:	31 f0       	breq	.+12     	; 0x16e <LCDGotoXY+0x10>
 162:	63 30       	cpi	r22, 0x03	; 3
 164:	31 f0       	breq	.+12     	; 0x172 <LCDGotoXY+0x14>
 166:	61 30       	cpi	r22, 0x01	; 1
 168:	29 f4       	brne	.+10     	; 0x174 <LCDGotoXY+0x16>
	{
	case 0: DDRAMAddr = LCD_LINE0_DDRAMADDR+x; break;
	case 1: DDRAMAddr = LCD_LINE1_DDRAMADDR+x; break;
 16a:	80 5c       	subi	r24, 0xC0	; 192
 16c:	03 c0       	rjmp	.+6      	; 0x174 <LCDGotoXY+0x16>
	case 2: DDRAMAddr = LCD_LINE2_DDRAMADDR+x; break;
 16e:	8c 5e       	subi	r24, 0xEC	; 236
 170:	01 c0       	rjmp	.+2      	; 0x174 <LCDGotoXY+0x16>
	case 3: DDRAMAddr = LCD_LINE3_DDRAMADDR+x; break;
 172:	8c 5a       	subi	r24, 0xAC	; 172
	default: DDRAMAddr = LCD_LINE0_DDRAMADDR+x;
	}
	// set data address
	LCDsendCommand(1<<LCD_DDRAM | DDRAMAddr);
 174:	80 68       	ori	r24, 0x80	; 128
 176:	8c df       	rcall	.-232    	; 0x90 <LCDsendCommand>
	
}
 178:	08 95       	ret

0000017a <CopyStringtoLCD>:
//Copies string from flash memory to LCD at x y position
//const uint8_t welcomeln1[] PROGMEM="AVR LCD DEMO\0";
//CopyStringtoLCD(welcomeln1, 3, 1);	
void CopyStringtoLCD(const uint8_t *FlashLoc, uint8_t x, uint8_t y)
{
 17a:	1f 93       	push	r17
 17c:	cf 93       	push	r28
 17e:	df 93       	push	r29
 180:	ec 01       	movw	r28, r24
 182:	86 2f       	mov	r24, r22
	uint8_t i;
	LCDGotoXY(x,y);
 184:	64 2f       	mov	r22, r20
 186:	eb df       	rcall	.-42     	; 0x15e <LCDGotoXY>
 188:	10 e0       	ldi	r17, 0x00	; 0
 18a:	02 c0       	rjmp	.+4      	; 0x190 <CopyStringtoLCD+0x16>
	for(i=0;(uint8_t)pgm_read_byte(&FlashLoc[i]);i++)
	{
		LCDsendChar((uint8_t)pgm_read_byte(&FlashLoc[i]));
 18c:	60 df       	rcall	.-320    	; 0x4e <LCDsendChar>
//CopyStringtoLCD(welcomeln1, 3, 1);	
void CopyStringtoLCD(const uint8_t *FlashLoc, uint8_t x, uint8_t y)
{
	uint8_t i;
	LCDGotoXY(x,y);
	for(i=0;(uint8_t)pgm_read_byte(&FlashLoc[i]);i++)
 18e:	1f 5f       	subi	r17, 0xFF	; 255
 190:	fe 01       	movw	r30, r28
 192:	e1 0f       	add	r30, r17
 194:	f1 1d       	adc	r31, r1
 196:	84 91       	lpm	r24, Z+
 198:	88 23       	and	r24, r24
 19a:	c1 f7       	brne	.-16     	; 0x18c <CopyStringtoLCD+0x12>
	{
		LCDsendChar((uint8_t)pgm_read_byte(&FlashLoc[i]));
	}
}
 19c:	df 91       	pop	r29
 19e:	cf 91       	pop	r28
 1a0:	1f 91       	pop	r17
 1a2:	08 95       	ret

000001a4 <LCDdefinechar>:
0b00000000,
0b00000000
};
LCDdefinechar(backslash,0);
*/
void LCDdefinechar(const uint8_t *pc,uint8_t char_code){
 1a4:	ef 92       	push	r14
 1a6:	ff 92       	push	r15
 1a8:	0f 93       	push	r16
 1aa:	1f 93       	push	r17
 1ac:	cf 93       	push	r28
 1ae:	df 93       	push	r29
 1b0:	7c 01       	movw	r14, r24
 1b2:	16 2f       	mov	r17, r22
	uint8_t a, pcc;
	uint16_t i;
	a=(char_code<<3)|0x40;
 1b4:	11 0f       	add	r17, r17
 1b6:	11 0f       	add	r17, r17
 1b8:	11 0f       	add	r17, r17
 1ba:	10 64       	ori	r17, 0x40	; 64
 1bc:	c0 e0       	ldi	r28, 0x00	; 0
 1be:	d0 e0       	ldi	r29, 0x00	; 0
	for (i=0; i<8; i++){
		pcc=pgm_read_byte(&pc[i]);
 1c0:	f7 01       	movw	r30, r14
 1c2:	ec 0f       	add	r30, r28
 1c4:	fd 1f       	adc	r31, r29
 1c6:	04 91       	lpm	r16, Z+
		LCDsendCommand(a++);
 1c8:	81 2f       	mov	r24, r17
 1ca:	8c 0f       	add	r24, r28
 1cc:	61 df       	rcall	.-318    	; 0x90 <LCDsendCommand>
		LCDsendChar(pcc);
 1ce:	80 2f       	mov	r24, r16
 1d0:	3e df       	rcall	.-388    	; 0x4e <LCDsendChar>
*/
void LCDdefinechar(const uint8_t *pc,uint8_t char_code){
	uint8_t a, pcc;
	uint16_t i;
	a=(char_code<<3)|0x40;
	for (i=0; i<8; i++){
 1d2:	21 96       	adiw	r28, 0x01	; 1
 1d4:	c8 30       	cpi	r28, 0x08	; 8
 1d6:	d1 05       	cpc	r29, r1
 1d8:	99 f7       	brne	.-26     	; 0x1c0 <LCDdefinechar+0x1c>
		pcc=pgm_read_byte(&pc[i]);
		LCDsendCommand(a++);
		LCDsendChar(pcc);
		}
}
 1da:	df 91       	pop	r29
 1dc:	cf 91       	pop	r28
 1de:	1f 91       	pop	r17
 1e0:	0f 91       	pop	r16
 1e2:	ff 90       	pop	r15
 1e4:	ef 90       	pop	r14
 1e6:	08 95       	ret

000001e8 <LCDshiftLeft>:

void LCDshiftLeft(uint8_t n)	//Scrol n of characters Right
{
 1e8:	0f 93       	push	r16
 1ea:	1f 93       	push	r17
 1ec:	08 2f       	mov	r16, r24
 1ee:	10 e0       	ldi	r17, 0x00	; 0
 1f0:	03 c0       	rjmp	.+6      	; 0x1f8 <LCDshiftLeft+0x10>
	for (uint8_t i=0;i<n;i++)
	{
		LCDsendCommand(0x1E);
 1f2:	8e e1       	ldi	r24, 0x1E	; 30
 1f4:	4d df       	rcall	.-358    	; 0x90 <LCDsendCommand>
		}
}

void LCDshiftLeft(uint8_t n)	//Scrol n of characters Right
{
	for (uint8_t i=0;i<n;i++)
 1f6:	1f 5f       	subi	r17, 0xFF	; 255
 1f8:	10 17       	cp	r17, r16
 1fa:	d8 f3       	brcs	.-10     	; 0x1f2 <LCDshiftLeft+0xa>
	{
		LCDsendCommand(0x1E);
	}
}
 1fc:	1f 91       	pop	r17
 1fe:	0f 91       	pop	r16
 200:	08 95       	ret

00000202 <LCDshiftRight>:
void LCDshiftRight(uint8_t n)	//Scrol n of characters Left
{
 202:	0f 93       	push	r16
 204:	1f 93       	push	r17
 206:	08 2f       	mov	r16, r24
 208:	10 e0       	ldi	r17, 0x00	; 0
 20a:	03 c0       	rjmp	.+6      	; 0x212 <LCDshiftRight+0x10>
	for (uint8_t i=0;i<n;i++)
	{
		LCDsendCommand(0x18);
 20c:	88 e1       	ldi	r24, 0x18	; 24
 20e:	40 df       	rcall	.-384    	; 0x90 <LCDsendCommand>
		LCDsendCommand(0x1E);
	}
}
void LCDshiftRight(uint8_t n)	//Scrol n of characters Left
{
	for (uint8_t i=0;i<n;i++)
 210:	1f 5f       	subi	r17, 0xFF	; 255
 212:	10 17       	cp	r17, r16
 214:	d8 f3       	brcs	.-10     	; 0x20c <LCDshiftRight+0xa>
	{
		LCDsendCommand(0x18);
	}
}
 216:	1f 91       	pop	r17
 218:	0f 91       	pop	r16
 21a:	08 95       	ret

0000021c <LCDcursorOn>:
void LCDcursorOn(void) //displays LCD cursor
{
	LCDsendCommand(0x0E);
 21c:	8e e0       	ldi	r24, 0x0E	; 14
 21e:	38 df       	rcall	.-400    	; 0x90 <LCDsendCommand>
}
 220:	08 95       	ret

00000222 <LCDcursorOnBlink>:
void LCDcursorOnBlink(void)	//displays LCD blinking cursor
{
	LCDsendCommand(0x0F);
 222:	8f e0       	ldi	r24, 0x0F	; 15
 224:	35 df       	rcall	.-406    	; 0x90 <LCDsendCommand>
}
 226:	08 95       	ret

00000228 <LCDcursorOFF>:
void LCDcursorOFF(void)	//turns OFF cursor
{
	LCDsendCommand(0x0C);
 228:	8c e0       	ldi	r24, 0x0C	; 12
 22a:	32 df       	rcall	.-412    	; 0x90 <LCDsendCommand>
}
 22c:	08 95       	ret

0000022e <LCDblank>:
void LCDblank(void)		//blanks LCD
{
	LCDsendCommand(0x08);
 22e:	88 e0       	ldi	r24, 0x08	; 8
 230:	2f df       	rcall	.-418    	; 0x90 <LCDsendCommand>
}
 232:	08 95       	ret

00000234 <LCDvisible>:
void LCDvisible(void)		//Shows LCD
{
	LCDsendCommand(0x0C);
 234:	8c e0       	ldi	r24, 0x0C	; 12
 236:	2c df       	rcall	.-424    	; 0x90 <LCDsendCommand>
}
 238:	08 95       	ret

0000023a <LCDcursorLeft>:
void LCDcursorLeft(uint8_t n)	//Moves cursor by n poisitions left
{
 23a:	0f 93       	push	r16
 23c:	1f 93       	push	r17
 23e:	08 2f       	mov	r16, r24
 240:	10 e0       	ldi	r17, 0x00	; 0
 242:	03 c0       	rjmp	.+6      	; 0x24a <LCDcursorLeft+0x10>
	for (uint8_t i=0;i<n;i++)
	{
		LCDsendCommand(0x10);
 244:	80 e1       	ldi	r24, 0x10	; 16
 246:	24 df       	rcall	.-440    	; 0x90 <LCDsendCommand>
{
	LCDsendCommand(0x0C);
}
void LCDcursorLeft(uint8_t n)	//Moves cursor by n poisitions left
{
	for (uint8_t i=0;i<n;i++)
 248:	1f 5f       	subi	r17, 0xFF	; 255
 24a:	10 17       	cp	r17, r16
 24c:	d8 f3       	brcs	.-10     	; 0x244 <LCDcursorLeft+0xa>
	{
		LCDsendCommand(0x10);
	}
}
 24e:	1f 91       	pop	r17
 250:	0f 91       	pop	r16
 252:	08 95       	ret

00000254 <LCDcursorRight>:
void LCDcursorRight(uint8_t n)	//Moves cursor by n poisitions left
{
 254:	0f 93       	push	r16
 256:	1f 93       	push	r17
 258:	08 2f       	mov	r16, r24
 25a:	10 e0       	ldi	r17, 0x00	; 0
 25c:	03 c0       	rjmp	.+6      	; 0x264 <LCDcursorRight+0x10>
	for (uint8_t i=0;i<n;i++)
	{
		LCDsendCommand(0x14);
 25e:	84 e1       	ldi	r24, 0x14	; 20
 260:	17 df       	rcall	.-466    	; 0x90 <LCDsendCommand>
		LCDsendCommand(0x10);
	}
}
void LCDcursorRight(uint8_t n)	//Moves cursor by n poisitions left
{
	for (uint8_t i=0;i<n;i++)
 262:	1f 5f       	subi	r17, 0xFF	; 255
 264:	10 17       	cp	r17, r16
 266:	d8 f3       	brcs	.-10     	; 0x25e <LCDcursorRight+0xa>
	{
		LCDsendCommand(0x14);
	}
}
 268:	1f 91       	pop	r17
 26a:	0f 91       	pop	r16
 26c:	08 95       	ret

0000026e <testuj>:
#define EEPROM_CAKAJ while (!eeprom_is_ready()) ;
#define F_CPU 16000000UL

int testuj(int n)						//1 - vynulovany
{
	if (bit_is_set(PIND,n)) 
 26e:	20 b3       	in	r18, 0x10	; 16
 270:	30 e0       	ldi	r19, 0x00	; 0
 272:	02 c0       	rjmp	.+4      	; 0x278 <testuj+0xa>
 274:	35 95       	asr	r19
 276:	27 95       	ror	r18
 278:	8a 95       	dec	r24
 27a:	e2 f7       	brpl	.-8      	; 0x274 <testuj+0x6>
 27c:	20 95       	com	r18
 27e:	30 95       	com	r19
 280:	21 70       	andi	r18, 0x01	; 1
 282:	30 70       	andi	r19, 0x00	; 0
		return 0;
	else
		return 1;
}
 284:	c9 01       	movw	r24, r18
 286:	08 95       	ret

00000288 <zapis>:

void zapis(char p[4])
{
 288:	20 e0       	ldi	r18, 0x00	; 0
 28a:	30 e0       	ldi	r19, 0x00	; 0
	int i;
	for (i = 0; i < 4; i++) {
		EEPROM_CAKAJ;
 28c:	e1 99       	sbic	0x1c, 1	; 28
 28e:	fe cf       	rjmp	.-4      	; 0x28c <zapis+0x4>
		eeprom_write_byte(i,p[i]);
 290:	fc 01       	movw	r30, r24
 292:	e2 0f       	add	r30, r18
 294:	f3 1f       	adc	r31, r19
 296:	e0 81       	ld	r30, Z
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
 298:	e1 99       	sbic	0x1c, 1	; 28
 29a:	fe cf       	rjmp	.-4      	; 0x298 <zapis+0x10>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
 29c:	3f bb       	out	0x1f, r19	; 31
 29e:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
 2a0:	ed bb       	out	0x1d, r30	; 29

    __asm__ __volatile__ (
 2a2:	0f b6       	in	r0, 0x3f	; 63
 2a4:	f8 94       	cli
 2a6:	e2 9a       	sbi	0x1c, 2	; 28
 2a8:	e1 9a       	sbi	0x1c, 1	; 28
 2aa:	0f be       	out	0x3f, r0	; 63
}

void zapis(char p[4])
{
	int i;
	for (i = 0; i < 4; i++) {
 2ac:	2f 5f       	subi	r18, 0xFF	; 255
 2ae:	3f 4f       	sbci	r19, 0xFF	; 255
 2b0:	24 30       	cpi	r18, 0x04	; 4
 2b2:	31 05       	cpc	r19, r1
 2b4:	59 f7       	brne	.-42     	; 0x28c <zapis+0x4>
		EEPROM_CAKAJ;
		eeprom_write_byte(i,p[i]);
	}
}
 2b6:	08 95       	ret

000002b8 <nastavene>:

int nastavene(void)
{
 2b8:	20 e0       	ldi	r18, 0x00	; 0
 2ba:	30 e0       	ldi	r19, 0x00	; 0
	int i;

	for (i = 0; i < 4; i++) {
		EEPROM_CAKAJ;
 2bc:	e1 99       	sbic	0x1c, 1	; 28
 2be:	fe cf       	rjmp	.-4      	; 0x2bc <nastavene+0x4>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
 2c0:	e1 99       	sbic	0x1c, 1	; 28
 2c2:	fe cf       	rjmp	.-4      	; 0x2c0 <nastavene+0x8>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
 2c4:	3f bb       	out	0x1f, r19	; 31
 2c6:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
 2c8:	e0 9a       	sbi	0x1c, 0	; 28
 2ca:	8d b3       	in	r24, 0x1d	; 29
		if (eeprom_read_byte(i) == 0xff)
 2cc:	8f 3f       	cpi	r24, 0xFF	; 255
 2ce:	19 f4       	brne	.+6      	; 0x2d6 <nastavene+0x1e>
 2d0:	20 e0       	ldi	r18, 0x00	; 0
 2d2:	30 e0       	ldi	r19, 0x00	; 0
 2d4:	07 c0       	rjmp	.+14     	; 0x2e4 <nastavene+0x2c>

int nastavene(void)
{
	int i;

	for (i = 0; i < 4; i++) {
 2d6:	2f 5f       	subi	r18, 0xFF	; 255
 2d8:	3f 4f       	sbci	r19, 0xFF	; 255
 2da:	24 30       	cpi	r18, 0x04	; 4
 2dc:	31 05       	cpc	r19, r1
 2de:	71 f7       	brne	.-36     	; 0x2bc <nastavene+0x4>
 2e0:	21 e0       	ldi	r18, 0x01	; 1
 2e2:	30 e0       	ldi	r19, 0x00	; 0
		EEPROM_CAKAJ;
		if (eeprom_read_byte(i) == 0xff)
			return 0;
	}
	return 1;
}
 2e4:	c9 01       	movw	r24, r18
 2e6:	08 95       	ret

000002e8 <cisti_eeprom>:

void cisti_eeprom(void)
{
 2e8:	80 e0       	ldi	r24, 0x00	; 0
 2ea:	90 e0       	ldi	r25, 0x00	; 0
#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
#endif
    EEDR = __value;
 2ec:	2f ef       	ldi	r18, 0xFF	; 255
	int i;

	for (i = 0; i < 4; i++) {
		EEPROM_CAKAJ;
 2ee:	e1 99       	sbic	0x1c, 1	; 28
 2f0:	fe cf       	rjmp	.-4      	; 0x2ee <cisti_eeprom+0x6>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
 2f2:	e1 99       	sbic	0x1c, 1	; 28
 2f4:	fe cf       	rjmp	.-4      	; 0x2f2 <cisti_eeprom+0xa>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
 2f6:	9f bb       	out	0x1f, r25	; 31
 2f8:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
 2fa:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
 2fc:	0f b6       	in	r0, 0x3f	; 63
 2fe:	f8 94       	cli
 300:	e2 9a       	sbi	0x1c, 2	; 28
 302:	e1 9a       	sbi	0x1c, 1	; 28
 304:	0f be       	out	0x3f, r0	; 63

void cisti_eeprom(void)
{
	int i;

	for (i = 0; i < 4; i++) {
 306:	01 96       	adiw	r24, 0x01	; 1
 308:	84 30       	cpi	r24, 0x04	; 4
 30a:	91 05       	cpc	r25, r1
 30c:	81 f7       	brne	.-32     	; 0x2ee <cisti_eeprom+0x6>
		EEPROM_CAKAJ;
		eeprom_write_byte(i,0xff);
	}
}
 30e:	08 95       	ret

00000310 <je_rovny>:

int je_rovny(char p[4]) 
{
 310:	ac 01       	movw	r20, r24
 312:	20 e0       	ldi	r18, 0x00	; 0
 314:	30 e0       	ldi	r19, 0x00	; 0
	int i;

	for (i = 0; i < 4; i++) {
		EEPROM_CAKAJ;
 316:	e1 99       	sbic	0x1c, 1	; 28
 318:	fe cf       	rjmp	.-4      	; 0x316 <je_rovny+0x6>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
 31a:	e1 99       	sbic	0x1c, 1	; 28
 31c:	fe cf       	rjmp	.-4      	; 0x31a <je_rovny+0xa>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
 31e:	3f bb       	out	0x1f, r19	; 31
 320:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
 322:	e0 9a       	sbi	0x1c, 0	; 28
 324:	8d b3       	in	r24, 0x1d	; 29
		if (eeprom_read_byte(i) != p[i]) {
 326:	fa 01       	movw	r30, r20
 328:	e2 0f       	add	r30, r18
 32a:	f3 1f       	adc	r31, r19
 32c:	90 81       	ld	r25, Z
 32e:	89 17       	cp	r24, r25
 330:	99 f0       	breq	.+38     	; 0x358 <je_rovny+0x48>
			LCDGotoXY(0,1);
 332:	80 e0       	ldi	r24, 0x00	; 0
 334:	61 e0       	ldi	r22, 0x01	; 1
 336:	13 df       	rcall	.-474    	; 0x15e <LCDGotoXY>
			LCDstring("Chybne", 6);
 338:	80 e6       	ldi	r24, 0x60	; 96
 33a:	90 e0       	ldi	r25, 0x00	; 0
 33c:	66 e0       	ldi	r22, 0x06	; 6
 33e:	fb de       	rcall	.-522    	; 0x136 <LCDstring>
 340:	80 ed       	ldi	r24, 0xD0	; 208
 342:	97 e0       	ldi	r25, 0x07	; 7
 344:	20 e9       	ldi	r18, 0x90	; 144
 346:	31 e0       	ldi	r19, 0x01	; 1
 348:	f9 01       	movw	r30, r18
 34a:	31 97       	sbiw	r30, 0x01	; 1
 34c:	f1 f7       	brne	.-4      	; 0x34a <je_rovny+0x3a>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 34e:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 350:	d9 f7       	brne	.-10     	; 0x348 <je_rovny+0x38>
 352:	20 e0       	ldi	r18, 0x00	; 0
 354:	30 e0       	ldi	r19, 0x00	; 0
 356:	2a c0       	rjmp	.+84     	; 0x3ac <je_rovny+0x9c>

int je_rovny(char p[4]) 
{
	int i;

	for (i = 0; i < 4; i++) {
 358:	2f 5f       	subi	r18, 0xFF	; 255
 35a:	3f 4f       	sbci	r19, 0xFF	; 255
 35c:	24 30       	cpi	r18, 0x04	; 4
 35e:	31 05       	cpc	r19, r1
 360:	d1 f6       	brne	.-76     	; 0x316 <je_rovny+0x6>
			LCDstring("Chybne", 6);
			_delay_ms(200);
			return 0;
		}
	}
	LCDGotoXY(0,1);
 362:	80 e0       	ldi	r24, 0x00	; 0
 364:	61 e0       	ldi	r22, 0x01	; 1
 366:	fb de       	rcall	.-522    	; 0x15e <LCDGotoXY>
 368:	80 e0       	ldi	r24, 0x00	; 0
 36a:	90 e0       	ldi	r25, 0x00	; 0
#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
#endif
    EEDR = __value;
 36c:	2f ef       	ldi	r18, 0xFF	; 255
void cisti_eeprom(void)
{
	int i;

	for (i = 0; i < 4; i++) {
		EEPROM_CAKAJ;
 36e:	e1 99       	sbic	0x1c, 1	; 28
 370:	fe cf       	rjmp	.-4      	; 0x36e <je_rovny+0x5e>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
 372:	e1 99       	sbic	0x1c, 1	; 28
 374:	fe cf       	rjmp	.-4      	; 0x372 <je_rovny+0x62>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
 376:	9f bb       	out	0x1f, r25	; 31
 378:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
 37a:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
 37c:	0f b6       	in	r0, 0x3f	; 63
 37e:	f8 94       	cli
 380:	e2 9a       	sbi	0x1c, 2	; 28
 382:	e1 9a       	sbi	0x1c, 1	; 28
 384:	0f be       	out	0x3f, r0	; 63

void cisti_eeprom(void)
{
	int i;

	for (i = 0; i < 4; i++) {
 386:	01 96       	adiw	r24, 0x01	; 1
 388:	84 30       	cpi	r24, 0x04	; 4
 38a:	91 05       	cpc	r25, r1
 38c:	81 f7       	brne	.-32     	; 0x36e <je_rovny+0x5e>
			return 0;
		}
	}
	LCDGotoXY(0,1);
	cisti_eeprom();
	LCDstring("Spravne", 7);
 38e:	87 e6       	ldi	r24, 0x67	; 103
 390:	90 e0       	ldi	r25, 0x00	; 0
 392:	67 e0       	ldi	r22, 0x07	; 7
 394:	d0 de       	rcall	.-608    	; 0x136 <LCDstring>
 396:	80 ed       	ldi	r24, 0xD0	; 208
 398:	97 e0       	ldi	r25, 0x07	; 7
 39a:	20 e9       	ldi	r18, 0x90	; 144
 39c:	31 e0       	ldi	r19, 0x01	; 1
 39e:	f9 01       	movw	r30, r18
 3a0:	31 97       	sbiw	r30, 0x01	; 1
 3a2:	f1 f7       	brne	.-4      	; 0x3a0 <je_rovny+0x90>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 3a4:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 3a6:	d9 f7       	brne	.-10     	; 0x39e <je_rovny+0x8e>
 3a8:	21 e0       	ldi	r18, 0x01	; 1
 3aa:	30 e0       	ldi	r19, 0x00	; 0
	_delay_ms(200);
	return 1;
}
 3ac:	c9 01       	movw	r24, r18
 3ae:	08 95       	ret

000003b0 <cisti_displej>:

void cisti_displej(int x, int y)
{
	LCDGotoXY(x,y);
 3b0:	d6 de       	rcall	.-596    	; 0x15e <LCDGotoXY>
	LCDstring("        ", 8);
 3b2:	8f e6       	ldi	r24, 0x6F	; 111
 3b4:	90 e0       	ldi	r25, 0x00	; 0
 3b6:	68 e0       	ldi	r22, 0x08	; 8
 3b8:	be de       	rcall	.-644    	; 0x136 <LCDstring>
}
 3ba:	08 95       	ret

000003bc <hviezdicky>:

void hviezdicky (int n)
{
	if (n <= 4) {
 3bc:	85 30       	cpi	r24, 0x05	; 5
 3be:	91 05       	cpc	r25, r1
 3c0:	3c f4       	brge	.+14     	; 0x3d0 <hviezdicky+0x14>
		LCDGotoXY(n-1,1);
 3c2:	81 50       	subi	r24, 0x01	; 1
 3c4:	61 e0       	ldi	r22, 0x01	; 1
 3c6:	cb de       	rcall	.-618    	; 0x15e <LCDGotoXY>
		LCDstring("*", 1);
 3c8:	88 e7       	ldi	r24, 0x78	; 120
 3ca:	90 e0       	ldi	r25, 0x00	; 0
 3cc:	61 e0       	ldi	r22, 0x01	; 1
 3ce:	b3 de       	rcall	.-666    	; 0x136 <LCDstring>
 3d0:	08 95       	ret

000003d2 <main>:
	}
}

int main(void)
{
 3d2:	8f 92       	push	r8
 3d4:	9f 92       	push	r9
 3d6:	af 92       	push	r10
 3d8:	bf 92       	push	r11
 3da:	cf 92       	push	r12
 3dc:	df 92       	push	r13
 3de:	ef 92       	push	r14
 3e0:	ff 92       	push	r15
 3e2:	0f 93       	push	r16
 3e4:	1f 93       	push	r17
 3e6:	df 93       	push	r29
 3e8:	cf 93       	push	r28
 3ea:	00 d0       	rcall	.+0      	; 0x3ec <main+0x1a>
 3ec:	00 d0       	rcall	.+0      	; 0x3ee <main+0x1c>
 3ee:	cd b7       	in	r28, 0x3d	; 61
 3f0:	de b7       	in	r29, 0x3e	; 62
	char heslo[4];
	int i = 0, n;					//0 citanie, 1 zapis

	DDRD = 0x00;
 3f2:	11 ba       	out	0x11, r1	; 17
	LCDinit();
 3f4:	6a de       	rcall	.-812    	; 0xca <LCDinit>
	LCDclr();
 3f6:	99 de       	rcall	.-718    	; 0x12a <LCDclr>
	LCDcursorOFF();
 3f8:	17 df       	rcall	.-466    	; 0x228 <LCDcursorOFF>
		LCDclr();
		LCDGotoXY(0,0);
		LCDstring("Vloz:", 5);
	}
		
	LCDGotoXY(0,1);
 3fa:	88 24       	eor	r8, r8
 3fc:	83 94       	inc	r8
	while (1) {
			if (bit_is_set(PIND,0)) {
				test1:
				if (testuj(0)) {
					heslo[i++] = 1;
 3fe:	7e 01       	movw	r14, r28
 400:	08 94       	sec
 402:	e1 1c       	adc	r14, r1
 404:	f1 1c       	adc	r15, r1
				else goto test1;
			}
			if (bit_is_set(PIND,1)) {
				test2:
				if (testuj(1)) {
					heslo[i++] = 2;
 406:	e2 e0       	ldi	r30, 0x02	; 2
 408:	9e 2e       	mov	r9, r30
				else goto test2;
			}
			if (bit_is_set(PIND,2)) {
				test3:
				if (testuj(2)) {
					heslo[i++] = 4;
 40a:	74 e0       	ldi	r23, 0x04	; 4
 40c:	a7 2e       	mov	r10, r23
				else goto test3;
			}
			if (bit_is_set(PIND,3)) {
				test4:
				if (testuj(3)) {
					heslo[i++] = 8;
 40e:	68 e0       	ldi	r22, 0x08	; 8
 410:	b6 2e       	mov	r11, r22
	LCDinit();
	LCDclr();
	LCDcursorOFF();
spat:
	
	if ((n = nastavene()) == 0) {
 412:	52 df       	rcall	.-348    	; 0x2b8 <nastavene>
 414:	6c 01       	movw	r12, r24
 416:	00 97       	sbiw	r24, 0x00	; 0
 418:	41 f4       	brne	.+16     	; 0x42a <main+0x58>
		LCDclr();
 41a:	87 de       	rcall	.-754    	; 0x12a <LCDclr>
		LCDGotoXY(0,0);
 41c:	80 e0       	ldi	r24, 0x00	; 0
 41e:	60 e0       	ldi	r22, 0x00	; 0
 420:	9e de       	rcall	.-708    	; 0x15e <LCDGotoXY>
		LCDstring("Nastav:", 7);
 422:	8a e7       	ldi	r24, 0x7A	; 122
 424:	90 e0       	ldi	r25, 0x00	; 0
 426:	67 e0       	ldi	r22, 0x07	; 7
 428:	07 c0       	rjmp	.+14     	; 0x438 <main+0x66>
	}
	else {
		LCDclr();
 42a:	7f de       	rcall	.-770    	; 0x12a <LCDclr>
		LCDGotoXY(0,0);
 42c:	80 e0       	ldi	r24, 0x00	; 0
 42e:	60 e0       	ldi	r22, 0x00	; 0
 430:	96 de       	rcall	.-724    	; 0x15e <LCDGotoXY>
		LCDstring("Vloz:", 5);
 432:	82 e8       	ldi	r24, 0x82	; 130
 434:	90 e0       	ldi	r25, 0x00	; 0
 436:	65 e0       	ldi	r22, 0x05	; 5
 438:	7e de       	rcall	.-772    	; 0x136 <LCDstring>
	}
		
	LCDGotoXY(0,1);
 43a:	80 e0       	ldi	r24, 0x00	; 0
 43c:	61 e0       	ldi	r22, 0x01	; 1
 43e:	8f de       	rcall	.-738    	; 0x15e <LCDGotoXY>
 440:	00 e0       	ldi	r16, 0x00	; 0
 442:	10 e0       	ldi	r17, 0x00	; 0
	while (1) {
			if (bit_is_set(PIND,0)) {
 444:	80 9b       	sbis	0x10, 0	; 16
 446:	03 c0       	rjmp	.+6      	; 0x44e <main+0x7c>
#define EEPROM_CAKAJ while (!eeprom_is_ready()) ;
#define F_CPU 16000000UL

int testuj(int n)						//1 - vynulovany
{
	if (bit_is_set(PIND,n)) 
 448:	80 99       	sbic	0x10, 0	; 16
 44a:	fe cf       	rjmp	.-4      	; 0x448 <main+0x76>
 44c:	37 c0       	rjmp	.+110    	; 0x4bc <__stack+0x5d>
					hviezdicky(i);
					goto pokracuj;;
				}
				else goto test1;
			}
			if (bit_is_set(PIND,1)) {
 44e:	81 9b       	sbis	0x10, 1	; 16
 450:	03 c0       	rjmp	.+6      	; 0x458 <main+0x86>
#define EEPROM_CAKAJ while (!eeprom_is_ready()) ;
#define F_CPU 16000000UL

int testuj(int n)						//1 - vynulovany
{
	if (bit_is_set(PIND,n)) 
 452:	81 99       	sbic	0x10, 1	; 16
 454:	fe cf       	rjmp	.-4      	; 0x452 <main+0x80>
 456:	37 c0       	rjmp	.+110    	; 0x4c6 <__stack+0x67>
					hviezdicky(i);
					goto pokracuj;;
				}
				else goto test2;
			}
			if (bit_is_set(PIND,2)) {
 458:	82 9b       	sbis	0x10, 2	; 16
 45a:	03 c0       	rjmp	.+6      	; 0x462 <__stack+0x3>
#define EEPROM_CAKAJ while (!eeprom_is_ready()) ;
#define F_CPU 16000000UL

int testuj(int n)						//1 - vynulovany
{
	if (bit_is_set(PIND,n)) 
 45c:	82 99       	sbic	0x10, 2	; 16
 45e:	fe cf       	rjmp	.-4      	; 0x45c <main+0x8a>
 460:	37 c0       	rjmp	.+110    	; 0x4d0 <__stack+0x71>
					hviezdicky(i);
					goto pokracuj;;
				}
				else goto test3;
			}
			if (bit_is_set(PIND,3)) {
 462:	83 9b       	sbis	0x10, 3	; 16
 464:	03 c0       	rjmp	.+6      	; 0x46c <__stack+0xd>
#define EEPROM_CAKAJ while (!eeprom_is_ready()) ;
#define F_CPU 16000000UL

int testuj(int n)						//1 - vynulovany
{
	if (bit_is_set(PIND,n)) 
 466:	83 99       	sbic	0x10, 3	; 16
 468:	fe cf       	rjmp	.-4      	; 0x466 <__stack+0x7>
 46a:	37 c0       	rjmp	.+110    	; 0x4da <__stack+0x7b>
					goto pokracuj;
				}
				else goto test4;
			}
			pokracuj:
			if (i >= 4) {
 46c:	04 30       	cpi	r16, 0x04	; 4
 46e:	11 05       	cpc	r17, r1
 470:	4c f3       	brlt	.-46     	; 0x444 <main+0x72>
				i = 0;
				if (n == 0) {
 472:	c1 14       	cp	r12, r1
 474:	d1 04       	cpc	r13, r1
 476:	b9 f4       	brne	.+46     	; 0x4a6 <__stack+0x47>
 478:	80 e0       	ldi	r24, 0x00	; 0
 47a:	90 e0       	ldi	r25, 0x00	; 0

void zapis(char p[4])
{
	int i;
	for (i = 0; i < 4; i++) {
		EEPROM_CAKAJ;
 47c:	e1 99       	sbic	0x1c, 1	; 28
 47e:	fe cf       	rjmp	.-4      	; 0x47c <__stack+0x1d>
		eeprom_write_byte(i,p[i]);
 480:	f7 01       	movw	r30, r14
 482:	e8 0f       	add	r30, r24
 484:	f9 1f       	adc	r31, r25
 486:	e0 81       	ld	r30, Z
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
 488:	e1 99       	sbic	0x1c, 1	; 28
 48a:	fe cf       	rjmp	.-4      	; 0x488 <__stack+0x29>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
 48c:	9f bb       	out	0x1f, r25	; 31
 48e:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
 490:	ed bb       	out	0x1d, r30	; 29

    __asm__ __volatile__ (
 492:	0f b6       	in	r0, 0x3f	; 63
 494:	f8 94       	cli
 496:	e2 9a       	sbi	0x1c, 2	; 28
 498:	e1 9a       	sbi	0x1c, 1	; 28
 49a:	0f be       	out	0x3f, r0	; 63
}

void zapis(char p[4])
{
	int i;
	for (i = 0; i < 4; i++) {
 49c:	01 96       	adiw	r24, 0x01	; 1
 49e:	84 30       	cpi	r24, 0x04	; 4
 4a0:	91 05       	cpc	r25, r1
 4a2:	61 f7       	brne	.-40     	; 0x47c <__stack+0x1d>
 4a4:	b6 cf       	rjmp	.-148    	; 0x412 <main+0x40>
				if (n == 0) {
					zapis(heslo);
					goto spat;
				}
				else 
					if (je_rovny(heslo) == 1) {
 4a6:	c7 01       	movw	r24, r14
 4a8:	33 df       	rcall	.-410    	; 0x310 <je_rovny>
 4aa:	01 97       	sbiw	r24, 0x01	; 1
 4ac:	09 f4       	brne	.+2      	; 0x4b0 <__stack+0x51>
 4ae:	b1 cf       	rjmp	.-158    	; 0x412 <main+0x40>
						goto spat;
					}	
					else cisti_displej(0,1);
 4b0:	80 e0       	ldi	r24, 0x00	; 0
 4b2:	90 e0       	ldi	r25, 0x00	; 0
 4b4:	61 e0       	ldi	r22, 0x01	; 1
 4b6:	70 e0       	ldi	r23, 0x00	; 0
 4b8:	7b df       	rcall	.-266    	; 0x3b0 <cisti_displej>
 4ba:	c2 cf       	rjmp	.-124    	; 0x440 <main+0x6e>
	LCDGotoXY(0,1);
	while (1) {
			if (bit_is_set(PIND,0)) {
				test1:
				if (testuj(0)) {
					heslo[i++] = 1;
 4bc:	f7 01       	movw	r30, r14
 4be:	e0 0f       	add	r30, r16
 4c0:	f1 1f       	adc	r31, r17
 4c2:	80 82       	st	Z, r8
 4c4:	0e c0       	rjmp	.+28     	; 0x4e2 <__stack+0x83>
				else goto test1;
			}
			if (bit_is_set(PIND,1)) {
				test2:
				if (testuj(1)) {
					heslo[i++] = 2;
 4c6:	f7 01       	movw	r30, r14
 4c8:	e0 0f       	add	r30, r16
 4ca:	f1 1f       	adc	r31, r17
 4cc:	90 82       	st	Z, r9
 4ce:	09 c0       	rjmp	.+18     	; 0x4e2 <__stack+0x83>
				else goto test2;
			}
			if (bit_is_set(PIND,2)) {
				test3:
				if (testuj(2)) {
					heslo[i++] = 4;
 4d0:	f7 01       	movw	r30, r14
 4d2:	e0 0f       	add	r30, r16
 4d4:	f1 1f       	adc	r31, r17
 4d6:	a0 82       	st	Z, r10
 4d8:	04 c0       	rjmp	.+8      	; 0x4e2 <__stack+0x83>
				else goto test3;
			}
			if (bit_is_set(PIND,3)) {
				test4:
				if (testuj(3)) {
					heslo[i++] = 8;
 4da:	f7 01       	movw	r30, r14
 4dc:	e0 0f       	add	r30, r16
 4de:	f1 1f       	adc	r31, r17
 4e0:	b0 82       	st	Z, r11
 4e2:	0f 5f       	subi	r16, 0xFF	; 255
 4e4:	1f 4f       	sbci	r17, 0xFF	; 255
					hviezdicky(i);
 4e6:	c8 01       	movw	r24, r16
 4e8:	69 df       	rcall	.-302    	; 0x3bc <hviezdicky>
 4ea:	c0 cf       	rjmp	.-128    	; 0x46c <__stack+0xd>

000004ec <_exit>:
 4ec:	f8 94       	cli

000004ee <__stop_program>:
 4ee:	ff cf       	rjmp	.-2      	; 0x4ee <__stop_program>
